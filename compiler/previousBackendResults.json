{
    "biometric": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> C_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> d_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> p_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger sum_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__12_0;\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_sum_1 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_min_sum_1 = std::uint32_t(10000);\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    sum_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_2 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__12_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}));\n    for (; _MPC_PLAINTEXT__12_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__12_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__12_0 != std::uint32_t(0)) {\n            vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__12_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, (vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}) + vectorized_access(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0})));\n\n    }\n\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_sum_2[_MPC_PLAINTEXT__14_0] = _3_0[_MPC_PLAINTEXT__14_0];\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            min_sum_2[_MPC_PLAINTEXT__14_0] = min_sum_4[(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__14_0] = (min_sum_2[_MPC_PLAINTEXT__14_0] > _8_0[_MPC_PLAINTEXT__14_0]);\n        min_sum_4[_MPC_PLAINTEXT__14_0] = _1_2[_MPC_PLAINTEXT__14_0].Mux(_8_0[_MPC_PLAINTEXT__14_0].Get(), min_sum_2[_MPC_PLAINTEXT__14_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _4_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_4[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n        min_index_4[_MPC_PLAINTEXT__15_0] = _1_2[_MPC_PLAINTEXT__15_0].Mux(_13_0[_MPC_PLAINTEXT__15_0].Get(), min_index_2[_MPC_PLAINTEXT__15_0].Get());\n\n    }\n\n    _10_0 = drop_dim_monoreturn(vectorized_access(min_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _11_0 = drop_dim_monoreturn(vectorized_access(min_index_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_10_0, _11_0);\n    return _2_1;\n\n}",
                "Y": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> C_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> d_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> p_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger sum_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__12_0;\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_sum_1 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_min_sum_1 = std::uint32_t(10000);\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    sum_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_2 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__12_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}));\n    for (; _MPC_PLAINTEXT__12_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__12_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__12_0 != std::uint32_t(0)) {\n            vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__12_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, (vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}) + vectorized_access(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0})));\n\n    }\n\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_sum_2[_MPC_PLAINTEXT__14_0] = _3_0[_MPC_PLAINTEXT__14_0];\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            min_sum_2[_MPC_PLAINTEXT__14_0] = min_sum_4[(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__14_0] = (min_sum_2[_MPC_PLAINTEXT__14_0] > _8_0[_MPC_PLAINTEXT__14_0]);\n        min_sum_4[_MPC_PLAINTEXT__14_0] = _1_2[_MPC_PLAINTEXT__14_0].Mux(_8_0[_MPC_PLAINTEXT__14_0].Get(), min_sum_2[_MPC_PLAINTEXT__14_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _4_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_4[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n        min_index_4[_MPC_PLAINTEXT__15_0] = _1_2[_MPC_PLAINTEXT__15_0].Mux(_13_0[_MPC_PLAINTEXT__15_0].Get(), min_index_2[_MPC_PLAINTEXT__15_0].Get());\n\n    }\n\n    _10_0 = drop_dim_monoreturn(vectorized_access(min_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _11_0 = drop_dim_monoreturn(vectorized_access(min_index_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_10_0, _11_0);\n    return _2_1;\n\n}",
                "mixed": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> C_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> d_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> p_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger sum_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__12_0;\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_sum_1 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_min_sum_1 = std::uint32_t(10000);\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    sum_2 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_sum_2 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3_A((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_4_Y((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__12_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}));\n    vectorized_assign(sum_3_A, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, (vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}).Get().Convert<encrypto::motion::MpcProtocol::kArithmeticGmw>()));\n\n    for (; _MPC_PLAINTEXT__12_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__12_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__12_0 != std::uint32_t(0)) {\n            vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(sum_4_Y, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__12_0 - std::uint32_t(1))}));\n                    vectorized_assign(sum_3_A, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, (vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}).Get().Convert<encrypto::motion::MpcProtocol::kArithmeticGmw>()));\n\n        }\n\n        vectorized_assign(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, (vectorized_access(sum_3_A, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}) + vectorized_access(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0})));\n            vectorized_assign(sum_4_Y, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, (vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n\n    }\n\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(sum_4_Y, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0_B((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_8_0_B, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _1_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_sum_2[_MPC_PLAINTEXT__14_0] = _3_0[_MPC_PLAINTEXT__14_0]; min_sum_2_B[_MPC_PLAINTEXT__14_0] = min_sum_2[_MPC_PLAINTEXT__14_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            min_sum_2[_MPC_PLAINTEXT__14_0] = min_sum_4_Y[(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))]; min_sum_2_B[_MPC_PLAINTEXT__14_0] = min_sum_2[_MPC_PLAINTEXT__14_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        _1_2[_MPC_PLAINTEXT__14_0] = (min_sum_2[_MPC_PLAINTEXT__14_0] > _8_0[_MPC_PLAINTEXT__14_0]); _1_2_B[_MPC_PLAINTEXT__14_0] = _1_2[_MPC_PLAINTEXT__14_0].Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        min_sum_4[_MPC_PLAINTEXT__14_0] = _1_2_B[_MPC_PLAINTEXT__14_0].Mux(_8_0_B[_MPC_PLAINTEXT__14_0].Get(), min_sum_2_B[_MPC_PLAINTEXT__14_0].Get()); min_sum_4_Y[_MPC_PLAINTEXT__14_0] = min_sum_4[_MPC_PLAINTEXT__14_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _4_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_4[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n        min_index_4[_MPC_PLAINTEXT__15_0] = _1_2_B[_MPC_PLAINTEXT__15_0].Mux(_13_0[_MPC_PLAINTEXT__15_0].Get(), min_index_2[_MPC_PLAINTEXT__15_0].Get());\n\n    }\n\n    _10_0 = drop_dim_monoreturn(vectorized_access(min_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _10_0_B; _10_0_B = drop_dim_monoreturn(vectorized_access(min_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    encrypto::motion::SecureUnsignedInteger _10_0_Y; _10_0_Y = drop_dim_monoreturn(vectorized_access(min_sum_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _11_0 = drop_dim_monoreturn(vectorized_access(min_index_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_10_0, _11_0);\n    return _2_1;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> C_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> d_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> p_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger sum_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__12_0;\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_sum_1 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_min_sum_1 = std::uint32_t(10000);\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    sum_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_2 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__12_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}));\n    for (; _MPC_PLAINTEXT__12_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__12_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__12_0 != std::uint32_t(0)) {\n            vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__12_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, (vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}) + vectorized_access(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0})));\n\n    }\n\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_sum_2[_MPC_PLAINTEXT__14_0] = _3_0[_MPC_PLAINTEXT__14_0];\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            min_sum_2[_MPC_PLAINTEXT__14_0] = min_sum_4[(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__14_0] = (min_sum_2[_MPC_PLAINTEXT__14_0] > _8_0[_MPC_PLAINTEXT__14_0]);\n        min_sum_4[_MPC_PLAINTEXT__14_0] = _1_2[_MPC_PLAINTEXT__14_0].Mux(_8_0[_MPC_PLAINTEXT__14_0].Get(), min_sum_2[_MPC_PLAINTEXT__14_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _4_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_4[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n        min_index_4[_MPC_PLAINTEXT__15_0] = _1_2[_MPC_PLAINTEXT__15_0].Mux(_13_0[_MPC_PLAINTEXT__15_0].Get(), min_index_2[_MPC_PLAINTEXT__15_0].Get());\n\n    }\n\n    _10_0 = drop_dim_monoreturn(vectorized_access(min_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _11_0 = drop_dim_monoreturn(vectorized_access(min_index_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_10_0, _11_0);\n    return _2_1;\n\n}",
                "Y": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> C_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> d_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> p_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger sum_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__12_0;\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_sum_1 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_min_sum_1 = std::uint32_t(10000);\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    sum_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_2 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__12_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}));\n    for (; _MPC_PLAINTEXT__12_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__12_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__12_0 != std::uint32_t(0)) {\n            vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__12_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, (vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}) + vectorized_access(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0})));\n\n    }\n\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_sum_2[_MPC_PLAINTEXT__14_0] = _3_0[_MPC_PLAINTEXT__14_0];\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            min_sum_2[_MPC_PLAINTEXT__14_0] = min_sum_4[(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__14_0] = (min_sum_2[_MPC_PLAINTEXT__14_0] > _8_0[_MPC_PLAINTEXT__14_0]);\n        min_sum_4[_MPC_PLAINTEXT__14_0] = _1_2[_MPC_PLAINTEXT__14_0].Mux(_8_0[_MPC_PLAINTEXT__14_0].Get(), min_sum_2[_MPC_PLAINTEXT__14_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _4_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_4[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n        min_index_4[_MPC_PLAINTEXT__15_0] = _1_2[_MPC_PLAINTEXT__15_0].Mux(_13_0[_MPC_PLAINTEXT__15_0].Get(), min_index_2[_MPC_PLAINTEXT__15_0].Get());\n\n    }\n\n    _10_0 = drop_dim_monoreturn(vectorized_access(min_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _11_0 = drop_dim_monoreturn(vectorized_access(min_index_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_10_0, _11_0);\n    return _2_1;\n\n}",
                "mixed": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> C_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> d_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> p_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger sum_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__12_0;\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_B = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_sum_1 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_min_sum_1 = std::uint32_t(10000);\n    min_index_1 = _MPC_CONSTANT_0_B;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    sum_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_2 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__12_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}));\n    for (; _MPC_PLAINTEXT__12_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__12_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__12_0 != std::uint32_t(0)) {\n            vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__12_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, (vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}) + vectorized_access(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0})));\n\n    }\n\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0_B((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_8_0_B, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_sum_2[_MPC_PLAINTEXT__14_0] = _3_0[_MPC_PLAINTEXT__14_0];\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            min_sum_2[_MPC_PLAINTEXT__14_0] = min_sum_4[(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__14_0] = (min_sum_2[_MPC_PLAINTEXT__14_0] > _8_0_B[_MPC_PLAINTEXT__14_0]);\n        min_sum_4[_MPC_PLAINTEXT__14_0] = _1_2[_MPC_PLAINTEXT__14_0].Mux(_8_0_B[_MPC_PLAINTEXT__14_0].Get(), min_sum_2[_MPC_PLAINTEXT__14_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _4_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_4[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n        min_index_4[_MPC_PLAINTEXT__15_0] = _1_2[_MPC_PLAINTEXT__15_0].Mux(_13_0[_MPC_PLAINTEXT__15_0].Get(), min_index_2[_MPC_PLAINTEXT__15_0].Get());\n\n    }\n\n    _10_0 = drop_dim_monoreturn(vectorized_access(min_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _11_0 = drop_dim_monoreturn(vectorized_access(min_index_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_10_0, _11_0);\n    return _2_1;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> C_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> d_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> p_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger sum_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__12_0;\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_sum_1 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_min_sum_1 = std::uint32_t(10000);\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    sum_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_2 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__12_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}));\n    for (; _MPC_PLAINTEXT__12_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__12_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__12_0 != std::uint32_t(0)) {\n            vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__12_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, (vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}) + vectorized_access(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0})));\n\n    }\n\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_sum_2[_MPC_PLAINTEXT__14_0] = _3_0[_MPC_PLAINTEXT__14_0];\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            min_sum_2[_MPC_PLAINTEXT__14_0] = min_sum_4[(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__14_0] = (min_sum_2[_MPC_PLAINTEXT__14_0] > _8_0[_MPC_PLAINTEXT__14_0]);\n        min_sum_4[_MPC_PLAINTEXT__14_0] = _1_2[_MPC_PLAINTEXT__14_0].Mux(_8_0[_MPC_PLAINTEXT__14_0].Get(), min_sum_2[_MPC_PLAINTEXT__14_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _4_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_4[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n        min_index_4[_MPC_PLAINTEXT__15_0] = _1_2[_MPC_PLAINTEXT__15_0].Mux(_13_0[_MPC_PLAINTEXT__15_0].Get(), min_index_2[_MPC_PLAINTEXT__15_0].Get());\n\n    }\n\n    _10_0 = drop_dim_monoreturn(vectorized_access(min_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _11_0 = drop_dim_monoreturn(vectorized_access(min_index_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_10_0, _11_0);\n    return _2_1;\n\n}",
                "Y": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> C_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> d_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> p_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger sum_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__12_0;\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_sum_1 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_min_sum_1 = std::uint32_t(10000);\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    sum_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_2 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__12_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}));\n    for (; _MPC_PLAINTEXT__12_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__12_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__12_0 != std::uint32_t(0)) {\n            vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__12_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, (vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}) + vectorized_access(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0})));\n\n    }\n\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_sum_2[_MPC_PLAINTEXT__14_0] = _3_0[_MPC_PLAINTEXT__14_0];\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            min_sum_2[_MPC_PLAINTEXT__14_0] = min_sum_4[(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__14_0] = (min_sum_2[_MPC_PLAINTEXT__14_0] > _8_0[_MPC_PLAINTEXT__14_0]);\n        min_sum_4[_MPC_PLAINTEXT__14_0] = _1_2[_MPC_PLAINTEXT__14_0].Mux(_8_0[_MPC_PLAINTEXT__14_0].Get(), min_sum_2[_MPC_PLAINTEXT__14_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _4_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_4[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n        min_index_4[_MPC_PLAINTEXT__15_0] = _1_2[_MPC_PLAINTEXT__15_0].Mux(_13_0[_MPC_PLAINTEXT__15_0].Get(), min_index_2[_MPC_PLAINTEXT__15_0].Get());\n\n    }\n\n    _10_0 = drop_dim_monoreturn(vectorized_access(min_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _11_0 = drop_dim_monoreturn(vectorized_access(min_index_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_10_0, _11_0);\n    return _2_1;\n\n}",
                "mixed": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> C_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> d_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_sum_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> p_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger sum_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__12_0;\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_sum_1 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_min_sum_1 = std::uint32_t(10000);\n    min_index_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    sum_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_2 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(d_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__12_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}));\n    for (; _MPC_PLAINTEXT__12_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__12_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__12_0 != std::uint32_t(0)) {\n            vectorized_assign(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__12_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}, (vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0}) + vectorized_access(p_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__12_0})));\n\n    }\n\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(sum_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0_Y((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_8_0_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_sum_2[_MPC_PLAINTEXT__14_0] = _3_0[_MPC_PLAINTEXT__14_0];\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            min_sum_2[_MPC_PLAINTEXT__14_0] = min_sum_4[(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__14_0] = (min_sum_2[_MPC_PLAINTEXT__14_0] > _8_0_Y[_MPC_PLAINTEXT__14_0]);\n        min_sum_4[_MPC_PLAINTEXT__14_0] = _1_2[_MPC_PLAINTEXT__14_0].Mux(_8_0_Y[_MPC_PLAINTEXT__14_0].Get(), min_sum_2[_MPC_PLAINTEXT__14_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _4_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_4[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n        min_index_4[_MPC_PLAINTEXT__15_0] = _1_2[_MPC_PLAINTEXT__15_0].Mux(_13_0[_MPC_PLAINTEXT__15_0].Get(), min_index_2[_MPC_PLAINTEXT__15_0].Get());\n\n    }\n\n    _10_0 = drop_dim_monoreturn(vectorized_access(min_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _11_0 = drop_dim_monoreturn(vectorized_access(min_index_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_10_0, _11_0);\n    return _2_1;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = sint(10000)\n    min_index_1 = sint(0)\n    sum_2 = sint(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1",
                "B": "program.options.binary = 32\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = siv32(10000)\n    min_index_1 = siv32(0)\n    sum_2 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = sint(10000)\n    min_index_1 = sint(0)\n    sum_2 = sint(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = sint(10000)\n    min_index_1 = sint(0)\n    sum_2 = sint(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1",
                "mixed": "program.options.binary = 32\nprogram.use_edabit(True)\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = sint(10000)\n    min_index_1 = sint(0)\n    sum_2 = sint(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = sint(10000)\n    min_index_1 = sint(0)\n    sum_2 = sint(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1",
                "B": "program.options.binary = 32\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = siv32(10000)\n    min_index_1 = siv32(0)\n    sum_2 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = sint(10000)\n    min_index_1 = sint(0)\n    sum_2 = sint(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = sint(10000)\n    min_index_1 = sint(0)\n    sum_2 = sint(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1",
                "mixed": "program.options.binary = 32\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    _8_0_B = [None] * (N_0)\n    # Function body\n    min_sum_1 = siv32(10000)\n    min_index_1 = siv32(0)\n    sum_2 = sint(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _random_iter in range(0,len(_8_0)):\n      _8_0_B[_random_iter] = _v.convertion_check(_8_0[_random_iter])\n    _8_0_B = siv32(_8_0_B)\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0_B, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0_B,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1"
            },
            "time": {
                "A": "program.options.binary = 32\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = sint(10000)\n    min_index_1 = sint(0)\n    sum_2 = sint(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1",
                "B": "program.options.binary = 32\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = siv32(10000)\n    min_index_1 = siv32(0)\n    sum_2 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = sint(10000)\n    min_index_1 = sint(0)\n    sum_2 = sint(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_sum_1 = sint(10000)\n    min_index_1 = sint(0)\n    sum_2 = sint(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef biometric(C_0, D_0, S_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0 * D_0)\n    _6_0 = [None] * (N_0 * D_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0)\n    d_3 = [None] * (N_0 * D_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_sum_2 = [None] * (N_0)\n    min_sum_4 = [None] * (N_0)\n    p_3 = [None] * (N_0 * D_0)\n    sum_3 = [None] * (N_0 * D_0)\n    sum_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    _8_0_B = [None] * (N_0)\n    # Function body\n    min_sum_1 = siv32(10000)\n    min_index_1 = siv32(0)\n    sum_2 = sint(0)\n    _6_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _7_0 = _v.lift(lambda indices: (C_0[indices[1]]), [N_0, D_0])\n    _13_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_sum_1, [N_0])\n    _4_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _5_0 = _v.lift(lambda indices: sum_2, [N_0, D_0])\n    _v.vectorized_assign(d_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_6_0, [N_0, D_0], [None, None]) - _v.vectorized_access_simd(_7_0, [N_0, D_0], [None, None])))\n    _v.vectorized_assign(p_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(d_3, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(d_3, [N_0, D_0], [None, None])))\n    for _12_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _12_0 == 0:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(_5_0, [N_0, D_0], [None, _12_0]))\n        else:\n            _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n        _v.vectorized_assign(sum_4, [N_0, D_0], [None, _12_0], (_v.vectorized_access_simd(sum_3, [N_0, D_0], [None, _12_0]) + _v.vectorized_access_simd(p_3, [N_0, D_0], [None, _12_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_3, [N_0, D_0], [None, _12_0], _v.vectorized_access(sum_4, [N_0, D_0], [None, (_12_0 - 1)]))\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.drop_dim(sum_4, [N_0, D_0]))\n    for _random_iter in range(0,len(_8_0)):\n      _8_0_B[_random_iter] = _v.convertion_check(_8_0[_random_iter])\n    _8_0_B = siv32(_8_0_B)\n    for _14_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(_3_0, [N_0], [_14_0]))\n        else:\n            _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_14_0], (_v.vectorized_access_simd(_8_0_B, [N_0], [_14_0]) < _v.vectorized_access_simd(min_sum_2, [N_0], [_14_0])))\n        _v.iterative_mux(min_sum_4,_1_2,_8_0_B,min_sum_2,[N_0],[_14_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_sum_2, [N_0], [_14_0], _v.vectorized_access(min_sum_4, [N_0], [(_14_0 - 1)]))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_4_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n        _v.iterative_mux(min_index_4,_1_2,_13_0,min_index_2,[N_0],[_15_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(min_index_4, [N_0], [(_15_0 - 1)]))\n    _10_0 = _v.drop_dim(min_sum_4, [N_0])\n    _11_0 = _v.drop_dim(min_index_4, [N_0])\n    _2_1 = (_10_0,_11_0,)\n    return _2_1"
            }
        }
    },
    "biometric_fast": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric_fast(\n    encrypto::motion::PartyPointer &party,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger C_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_C_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    encrypto::motion::SecureUnsignedInteger _13_0;\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> a_sqr_plus_b_sqr_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_diff_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> this_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger two_a_b_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_diff_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_3;\n    std::uint32_t _MPC_PLAINTEXT_two_a_b_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_99999 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(99999)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return differences_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_sqr_sum_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_sqr_sum_0;}), {_MPC_PLAINTEXT_N_0}));\n    two_a_b_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_two_a_b_2 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    min_index_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_3 = std::uint32_t(0);\n    min_diff_1 = _MPC_CONSTANT_99999;\n    _MPC_PLAINTEXT_min_diff_1 = std::uint32_t(99999);\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) + vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_a_b_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_diff_1;}), {_MPC_PLAINTEXT_N_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _3_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_3;\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}));\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, (vectorized_access(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}) + vectorized_access(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0})));\n\n    }\n\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(differences_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_diff_2[_MPC_PLAINTEXT__17_0] = _11_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            min_diff_2[_MPC_PLAINTEXT__17_0] = min_diff_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__17_0] = (min_diff_2[_MPC_PLAINTEXT__17_0] > differences_2[_MPC_PLAINTEXT__17_0]);\n        min_diff_4[_MPC_PLAINTEXT__17_0] = _1_2[_MPC_PLAINTEXT__17_0].Mux(differences_2[_MPC_PLAINTEXT__17_0].Get(), min_diff_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_4[_MPC_PLAINTEXT__18_0] = min_index_2[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            min_index_4[_MPC_PLAINTEXT__18_0] = min_index_6[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        min_index_6[_MPC_PLAINTEXT__18_0] = _1_2[_MPC_PLAINTEXT__18_0].Mux(_16_0[_MPC_PLAINTEXT__18_0].Get(), min_index_4[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _12_0 = drop_dim_monoreturn(vectorized_access(min_diff_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _13_0 = drop_dim_monoreturn(vectorized_access(min_index_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_12_0, _13_0);\n    return _2_1;\n\n}",
                "Y": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric_fast(\n    encrypto::motion::PartyPointer &party,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger C_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_C_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    encrypto::motion::SecureUnsignedInteger _13_0;\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> a_sqr_plus_b_sqr_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_diff_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> this_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger two_a_b_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_diff_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_3;\n    std::uint32_t _MPC_PLAINTEXT_two_a_b_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_99999 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(99999)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return differences_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_sqr_sum_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_sqr_sum_0;}), {_MPC_PLAINTEXT_N_0}));\n    two_a_b_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_two_a_b_2 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    min_index_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_3 = std::uint32_t(0);\n    min_diff_1 = _MPC_CONSTANT_99999;\n    _MPC_PLAINTEXT_min_diff_1 = std::uint32_t(99999);\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) + vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_a_b_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_diff_1;}), {_MPC_PLAINTEXT_N_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _3_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_3;\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}));\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, (vectorized_access(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}) + vectorized_access(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0})));\n\n    }\n\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(differences_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_diff_2[_MPC_PLAINTEXT__17_0] = _11_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            min_diff_2[_MPC_PLAINTEXT__17_0] = min_diff_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__17_0] = (min_diff_2[_MPC_PLAINTEXT__17_0] > differences_2[_MPC_PLAINTEXT__17_0]);\n        min_diff_4[_MPC_PLAINTEXT__17_0] = _1_2[_MPC_PLAINTEXT__17_0].Mux(differences_2[_MPC_PLAINTEXT__17_0].Get(), min_diff_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_4[_MPC_PLAINTEXT__18_0] = min_index_2[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            min_index_4[_MPC_PLAINTEXT__18_0] = min_index_6[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        min_index_6[_MPC_PLAINTEXT__18_0] = _1_2[_MPC_PLAINTEXT__18_0].Mux(_16_0[_MPC_PLAINTEXT__18_0].Get(), min_index_4[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _12_0 = drop_dim_monoreturn(vectorized_access(min_diff_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _13_0 = drop_dim_monoreturn(vectorized_access(min_index_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_12_0, _13_0);\n    return _2_1;\n\n}",
                "mixed": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric_fast(\n    encrypto::motion::PartyPointer &party,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger C_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_C_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    encrypto::motion::SecureUnsignedInteger _13_0;\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> a_sqr_plus_b_sqr_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_diff_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> this_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger two_a_b_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_diff_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_3;\n    std::uint32_t _MPC_PLAINTEXT_two_a_b_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_B = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_99999 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(99999)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_index_1 = _MPC_CONSTANT_0_B;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return differences_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_sqr_sum_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_sqr_sum_0;}), {_MPC_PLAINTEXT_N_0}));\n    two_a_b_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_two_a_b_2 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    min_index_3 = _MPC_CONSTANT_0_B;\n    _MPC_PLAINTEXT_min_index_3 = std::uint32_t(0);\n    min_diff_1 = _MPC_CONSTANT_99999;\n    _MPC_PLAINTEXT_min_diff_1 = std::uint32_t(99999);\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) + vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_a_b_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_diff_1;}), {_MPC_PLAINTEXT_N_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _3_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_3;\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}));\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, (vectorized_access(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}) + vectorized_access(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0})));\n\n    }\n\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> this_diff_2_Y((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(this_diff_2_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    vectorized_assign(differences_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(this_diff_2_Y, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_2_B((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(differences_2_B, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(differences_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _1_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_diff_2[_MPC_PLAINTEXT__17_0] = _11_0[_MPC_PLAINTEXT__17_0]; min_diff_2_B[_MPC_PLAINTEXT__17_0] = min_diff_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            min_diff_2[_MPC_PLAINTEXT__17_0] = min_diff_4_Y[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))]; min_diff_2_B[_MPC_PLAINTEXT__17_0] = min_diff_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        _1_2[_MPC_PLAINTEXT__17_0] = (min_diff_2[_MPC_PLAINTEXT__17_0] > differences_2[_MPC_PLAINTEXT__17_0]); _1_2_B[_MPC_PLAINTEXT__17_0] = _1_2[_MPC_PLAINTEXT__17_0].Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        min_diff_4[_MPC_PLAINTEXT__17_0] = _1_2_B[_MPC_PLAINTEXT__17_0].Mux(differences_2_B[_MPC_PLAINTEXT__17_0].Get(), min_diff_2_B[_MPC_PLAINTEXT__17_0].Get()); min_diff_4_Y[_MPC_PLAINTEXT__17_0] = min_diff_4[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_4[_MPC_PLAINTEXT__18_0] = min_index_2[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            min_index_4[_MPC_PLAINTEXT__18_0] = min_index_6[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        min_index_6[_MPC_PLAINTEXT__18_0] = _1_2_B[_MPC_PLAINTEXT__18_0].Mux(_16_0[_MPC_PLAINTEXT__18_0].Get(), min_index_4[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _12_0 = drop_dim_monoreturn(vectorized_access(min_diff_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _12_0_Y; _12_0_Y = drop_dim_monoreturn(vectorized_access(min_diff_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _13_0 = drop_dim_monoreturn(vectorized_access(min_index_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_12_0, _13_0);\n    return _2_1;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric_fast(\n    encrypto::motion::PartyPointer &party,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger C_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_C_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    encrypto::motion::SecureUnsignedInteger _13_0;\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> a_sqr_plus_b_sqr_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_diff_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> this_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger two_a_b_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_diff_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_3;\n    std::uint32_t _MPC_PLAINTEXT_two_a_b_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_99999 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(99999)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return differences_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_sqr_sum_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_sqr_sum_0;}), {_MPC_PLAINTEXT_N_0}));\n    two_a_b_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_two_a_b_2 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    min_index_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_3 = std::uint32_t(0);\n    min_diff_1 = _MPC_CONSTANT_99999;\n    _MPC_PLAINTEXT_min_diff_1 = std::uint32_t(99999);\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) + vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_a_b_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_diff_1;}), {_MPC_PLAINTEXT_N_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _3_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_3;\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}));\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, (vectorized_access(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}) + vectorized_access(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0})));\n\n    }\n\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(differences_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_diff_2[_MPC_PLAINTEXT__17_0] = _11_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            min_diff_2[_MPC_PLAINTEXT__17_0] = min_diff_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__17_0] = (min_diff_2[_MPC_PLAINTEXT__17_0] > differences_2[_MPC_PLAINTEXT__17_0]);\n        min_diff_4[_MPC_PLAINTEXT__17_0] = _1_2[_MPC_PLAINTEXT__17_0].Mux(differences_2[_MPC_PLAINTEXT__17_0].Get(), min_diff_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_4[_MPC_PLAINTEXT__18_0] = min_index_2[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            min_index_4[_MPC_PLAINTEXT__18_0] = min_index_6[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        min_index_6[_MPC_PLAINTEXT__18_0] = _1_2[_MPC_PLAINTEXT__18_0].Mux(_16_0[_MPC_PLAINTEXT__18_0].Get(), min_index_4[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _12_0 = drop_dim_monoreturn(vectorized_access(min_diff_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _13_0 = drop_dim_monoreturn(vectorized_access(min_index_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_12_0, _13_0);\n    return _2_1;\n\n}",
                "Y": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric_fast(\n    encrypto::motion::PartyPointer &party,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger C_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_C_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    encrypto::motion::SecureUnsignedInteger _13_0;\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> a_sqr_plus_b_sqr_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_diff_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> this_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger two_a_b_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_diff_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_3;\n    std::uint32_t _MPC_PLAINTEXT_two_a_b_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_99999 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(99999)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return differences_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_sqr_sum_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_sqr_sum_0;}), {_MPC_PLAINTEXT_N_0}));\n    two_a_b_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_two_a_b_2 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    min_index_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_3 = std::uint32_t(0);\n    min_diff_1 = _MPC_CONSTANT_99999;\n    _MPC_PLAINTEXT_min_diff_1 = std::uint32_t(99999);\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) + vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_a_b_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_diff_1;}), {_MPC_PLAINTEXT_N_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _3_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_3;\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}));\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, (vectorized_access(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}) + vectorized_access(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0})));\n\n    }\n\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(differences_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_diff_2[_MPC_PLAINTEXT__17_0] = _11_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            min_diff_2[_MPC_PLAINTEXT__17_0] = min_diff_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__17_0] = (min_diff_2[_MPC_PLAINTEXT__17_0] > differences_2[_MPC_PLAINTEXT__17_0]);\n        min_diff_4[_MPC_PLAINTEXT__17_0] = _1_2[_MPC_PLAINTEXT__17_0].Mux(differences_2[_MPC_PLAINTEXT__17_0].Get(), min_diff_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_4[_MPC_PLAINTEXT__18_0] = min_index_2[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            min_index_4[_MPC_PLAINTEXT__18_0] = min_index_6[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        min_index_6[_MPC_PLAINTEXT__18_0] = _1_2[_MPC_PLAINTEXT__18_0].Mux(_16_0[_MPC_PLAINTEXT__18_0].Get(), min_index_4[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _12_0 = drop_dim_monoreturn(vectorized_access(min_diff_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _13_0 = drop_dim_monoreturn(vectorized_access(min_index_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_12_0, _13_0);\n    return _2_1;\n\n}",
                "mixed": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric_fast(\n    encrypto::motion::PartyPointer &party,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger C_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_C_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    encrypto::motion::SecureUnsignedInteger _13_0;\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> a_sqr_plus_b_sqr_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_diff_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> this_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger two_a_b_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_diff_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_3;\n    std::uint32_t _MPC_PLAINTEXT_two_a_b_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_B = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_99999 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(99999)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_index_1 = _MPC_CONSTANT_0_B;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return differences_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_sqr_sum_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_sqr_sum_0;}), {_MPC_PLAINTEXT_N_0}));\n    two_a_b_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_two_a_b_2 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    min_index_3 = _MPC_CONSTANT_0_B;\n    _MPC_PLAINTEXT_min_index_3 = std::uint32_t(0);\n    min_diff_1 = _MPC_CONSTANT_99999;\n    _MPC_PLAINTEXT_min_diff_1 = std::uint32_t(99999);\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) + vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_a_b_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_diff_1;}), {_MPC_PLAINTEXT_N_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _3_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_3;\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}));\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, (vectorized_access(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}) + vectorized_access(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0})));\n\n    }\n\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(differences_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_2_B((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(differences_2_B, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(differences_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_diff_2[_MPC_PLAINTEXT__17_0] = _11_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            min_diff_2[_MPC_PLAINTEXT__17_0] = min_diff_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__17_0] = (min_diff_2[_MPC_PLAINTEXT__17_0] > differences_2_B[_MPC_PLAINTEXT__17_0]);\n        min_diff_4[_MPC_PLAINTEXT__17_0] = _1_2[_MPC_PLAINTEXT__17_0].Mux(differences_2_B[_MPC_PLAINTEXT__17_0].Get(), min_diff_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_4[_MPC_PLAINTEXT__18_0] = min_index_2[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            min_index_4[_MPC_PLAINTEXT__18_0] = min_index_6[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        min_index_6[_MPC_PLAINTEXT__18_0] = _1_2[_MPC_PLAINTEXT__18_0].Mux(_16_0[_MPC_PLAINTEXT__18_0].Get(), min_index_4[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _12_0 = drop_dim_monoreturn(vectorized_access(min_diff_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _13_0 = drop_dim_monoreturn(vectorized_access(min_index_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_12_0, _13_0);\n    return _2_1;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric_fast(\n    encrypto::motion::PartyPointer &party,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger C_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_C_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    encrypto::motion::SecureUnsignedInteger _13_0;\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> a_sqr_plus_b_sqr_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_diff_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> this_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger two_a_b_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_diff_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_3;\n    std::uint32_t _MPC_PLAINTEXT_two_a_b_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_99999 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(99999)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return differences_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_sqr_sum_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_sqr_sum_0;}), {_MPC_PLAINTEXT_N_0}));\n    two_a_b_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_two_a_b_2 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    min_index_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_3 = std::uint32_t(0);\n    min_diff_1 = _MPC_CONSTANT_99999;\n    _MPC_PLAINTEXT_min_diff_1 = std::uint32_t(99999);\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) + vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_a_b_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_diff_1;}), {_MPC_PLAINTEXT_N_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _3_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_3;\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}));\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, (vectorized_access(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}) + vectorized_access(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0})));\n\n    }\n\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(differences_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_diff_2[_MPC_PLAINTEXT__17_0] = _11_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            min_diff_2[_MPC_PLAINTEXT__17_0] = min_diff_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__17_0] = (min_diff_2[_MPC_PLAINTEXT__17_0] > differences_2[_MPC_PLAINTEXT__17_0]);\n        min_diff_4[_MPC_PLAINTEXT__17_0] = _1_2[_MPC_PLAINTEXT__17_0].Mux(differences_2[_MPC_PLAINTEXT__17_0].Get(), min_diff_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_4[_MPC_PLAINTEXT__18_0] = min_index_2[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            min_index_4[_MPC_PLAINTEXT__18_0] = min_index_6[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        min_index_6[_MPC_PLAINTEXT__18_0] = _1_2[_MPC_PLAINTEXT__18_0].Mux(_16_0[_MPC_PLAINTEXT__18_0].Get(), min_index_4[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _12_0 = drop_dim_monoreturn(vectorized_access(min_diff_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _13_0 = drop_dim_monoreturn(vectorized_access(min_index_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_12_0, _13_0);\n    return _2_1;\n\n}",
                "Y": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric_fast(\n    encrypto::motion::PartyPointer &party,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger C_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_C_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    encrypto::motion::SecureUnsignedInteger _13_0;\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> a_sqr_plus_b_sqr_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_diff_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> this_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger two_a_b_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_diff_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_3;\n    std::uint32_t _MPC_PLAINTEXT_two_a_b_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_99999 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(99999)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_index_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return differences_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_sqr_sum_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_sqr_sum_0;}), {_MPC_PLAINTEXT_N_0}));\n    two_a_b_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_two_a_b_2 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    min_index_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_min_index_3 = std::uint32_t(0);\n    min_diff_1 = _MPC_CONSTANT_99999;\n    _MPC_PLAINTEXT_min_diff_1 = std::uint32_t(99999);\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) + vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_a_b_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_diff_1;}), {_MPC_PLAINTEXT_N_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _3_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_3;\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}));\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, (vectorized_access(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}) + vectorized_access(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0})));\n\n    }\n\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(differences_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_diff_2[_MPC_PLAINTEXT__17_0] = _11_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            min_diff_2[_MPC_PLAINTEXT__17_0] = min_diff_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__17_0] = (min_diff_2[_MPC_PLAINTEXT__17_0] > differences_2[_MPC_PLAINTEXT__17_0]);\n        min_diff_4[_MPC_PLAINTEXT__17_0] = _1_2[_MPC_PLAINTEXT__17_0].Mux(differences_2[_MPC_PLAINTEXT__17_0].Get(), min_diff_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_4[_MPC_PLAINTEXT__18_0] = min_index_2[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            min_index_4[_MPC_PLAINTEXT__18_0] = min_index_6[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        min_index_6[_MPC_PLAINTEXT__18_0] = _1_2[_MPC_PLAINTEXT__18_0].Mux(_16_0[_MPC_PLAINTEXT__18_0].Get(), min_index_4[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _12_0 = drop_dim_monoreturn(vectorized_access(min_diff_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _13_0 = drop_dim_monoreturn(vectorized_access(min_index_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_12_0, _13_0);\n    return _2_1;\n\n}",
                "mixed": "std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> biometric_fast(\n    encrypto::motion::PartyPointer &party,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger C_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_C_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> S_sqr_sum_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _12_0;\n    encrypto::motion::SecureUnsignedInteger _13_0;\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::tuple<encrypto::motion::SecureUnsignedInteger, encrypto::motion::SecureUnsignedInteger> _2_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> a_sqr_plus_b_sqr_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_diff_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_diff_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger min_index_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> min_index_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> this_diff_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger two_a_b_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> two_a_b_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__14_0;\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::uint32_t, std::uint32_t> _MPC_PLAINTEXT__2_1;\n    std::uint32_t _MPC_PLAINTEXT_min_diff_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_1;\n    std::uint32_t _MPC_PLAINTEXT_min_index_3;\n    std::uint32_t _MPC_PLAINTEXT_two_a_b_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_99999 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(99999)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    min_index_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_min_index_1 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return differences_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_sqr_sum_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return C_sqr_sum_0;}), {_MPC_PLAINTEXT_N_0}));\n    two_a_b_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_two_a_b_2 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return S_0[((indices[0] * _MPC_PLAINTEXT_D_0) + indices[1])];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_C_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    min_index_3 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_min_index_3 = std::uint32_t(0);\n    min_diff_1 = _MPC_CONSTANT_99999;\n    _MPC_PLAINTEXT_min_diff_1 = std::uint32_t(99999);\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_index_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) + vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return two_a_b_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}, (vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}) * vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {})));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return min_diff_1;}), {_MPC_PLAINTEXT_N_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_2[_MPC_PLAINTEXT__15_0] = _3_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            min_index_2[_MPC_PLAINTEXT__15_0] = min_index_3;\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__14_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}));\n    for (; _MPC_PLAINTEXT__14_0 < _MPC_PLAINTEXT_D_0; _MPC_PLAINTEXT__14_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__14_0 != std::uint32_t(0)) {\n            vectorized_assign(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {(_MPC_PLAINTEXT__14_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}, (vectorized_access(two_a_b_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0}) + vectorized_access(tmp_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, false}, {_MPC_PLAINTEXT__14_0})));\n\n    }\n\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(two_a_b_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_D_0}));\n    vectorized_assign(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(a_sqr_plus_b_sqr_2, {_MPC_PLAINTEXT_N_0}, {true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(differences_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(this_diff_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> differences_2_Y((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(differences_2_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(differences_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_diff_2[_MPC_PLAINTEXT__17_0] = _11_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            min_diff_2[_MPC_PLAINTEXT__17_0] = min_diff_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _1_2[_MPC_PLAINTEXT__17_0] = (min_diff_2[_MPC_PLAINTEXT__17_0] > differences_2_Y[_MPC_PLAINTEXT__17_0]);\n        min_diff_4[_MPC_PLAINTEXT__17_0] = _1_2[_MPC_PLAINTEXT__17_0].Mux(differences_2_Y[_MPC_PLAINTEXT__17_0].Get(), min_diff_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    min_index_4[_MPC_PLAINTEXT__18_0] = min_index_2[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            min_index_4[_MPC_PLAINTEXT__18_0] = min_index_6[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        min_index_6[_MPC_PLAINTEXT__18_0] = _1_2[_MPC_PLAINTEXT__18_0].Mux(_16_0[_MPC_PLAINTEXT__18_0].Get(), min_index_4[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _12_0 = drop_dim_monoreturn(vectorized_access(min_diff_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _13_0 = drop_dim_monoreturn(vectorized_access(min_index_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    _2_1 = std::make_tuple(_12_0, _13_0);\n    return _2_1;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = sint(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = sint(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = sint(0)\n    min_diff_1 = sint(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1",
                "B": "program.options.binary = 32\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = siv32(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = siv32(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = siv32(0)\n    min_diff_1 = siv32(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = sint(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = sint(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = sint(0)\n    min_diff_1 = sint(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = sint(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = sint(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = sint(0)\n    min_diff_1 = sint(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1",
                "mixed": "program.options.binary = 32\nprogram.use_edabit(True)\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = sint(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = sint(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = sint(0)\n    min_diff_1 = sint(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = sint(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = sint(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = sint(0)\n    min_diff_1 = sint(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1",
                "B": "program.options.binary = 32\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = siv32(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = siv32(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = siv32(0)\n    min_diff_1 = siv32(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = sint(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = sint(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = sint(0)\n    min_diff_1 = sint(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = sint(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = sint(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = sint(0)\n    min_diff_1 = sint(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1",
                "mixed": "program.options.binary = 32\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    differences_2_B = [None] * (N_0)\n    # Function body\n    min_index_1 = siv32(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = sint(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = siv32(0)\n    min_diff_1 = siv32(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _random_iter in range(0,len(differences_2)):\n      differences_2_B[_random_iter] = _v.convertion_check(differences_2[_random_iter])\n    differences_2_B = siv32(differences_2_B);\n    differences_2_B = [None] * (N_0)\n    for _random_iter in range(0,len(differences_2)):\n      differences_2_B[_random_iter] = _v.convertion_check(differences_2[_random_iter])\n    differences_2_B = siv32(differences_2_B)\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2_B, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2_B,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1"
            },
            "time": {
                "A": "program.options.binary = 32\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = sint(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = sint(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = sint(0)\n    min_diff_1 = sint(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1",
                "B": "program.options.binary = 32\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = siv32(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = siv32(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = siv32(0)\n    min_diff_1 = siv32(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = sint(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = sint(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = sint(0)\n    min_diff_1 = sint(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    min_index_1 = sint(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = sint(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = sint(0)\n    min_diff_1 = sint(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef biometric_fast(D_0, N_0, C_sqr_sum_0, two_C_0, S_0, S_sqr_sum_0, differences_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0 * D_0)\n    _8_0 = [None] * (N_0 * D_0)\n    _9_0 = [None] * (N_0 * D_0)\n    a_sqr_plus_b_sqr_2 = [None] * (N_0)\n    differences_2 = [None] * (N_0)\n    min_diff_2 = [None] * (N_0)\n    min_diff_4 = [None] * (N_0)\n    min_index_2 = [None] * (N_0)\n    min_index_4 = [None] * (N_0)\n    min_index_6 = [None] * (N_0)\n    this_diff_2 = [None] * (N_0)\n    tmp_3 = [None] * (N_0 * D_0)\n    two_a_b_3 = [None] * (N_0 * D_0)\n    two_a_b_4 = [None] * (N_0 * D_0)\n    # Shared array convertion declarations\n    differences_2_B = [None] * (N_0)\n    # Function body\n    min_index_1 = siv32(0)\n    _4_0 = _v.lift(lambda indices: differences_0, [N_0])\n    _5_0 = _v.lift(lambda indices: (S_sqr_sum_0[indices[0]]), [N_0])\n    _6_0 = _v.lift(lambda indices: C_sqr_sum_0, [N_0])\n    two_a_b_2 = sint(0)\n    _8_0 = _v.lift(lambda indices: (S_0[((indices[0] * D_0) + indices[1])]), [N_0, D_0])\n    _9_0 = _v.lift(lambda indices: (two_C_0[indices[1]]), [N_0, D_0])\n    min_index_3 = siv32(0)\n    min_diff_1 = siv32(99999)\n    _16_0 = _v.lift(lambda indices: indices[0], [N_0])\n    _3_0 = _v.lift(lambda indices: min_index_1, [N_0])\n    _v.vectorized_assign(a_sqr_plus_b_sqr_2, [N_0], [None], (_v.vectorized_access_simd(_5_0, [N_0], [None]) + _v.vectorized_access_simd(_6_0, [N_0], [None])))\n    _7_0 = _v.lift(lambda indices: two_a_b_2, [N_0, D_0])\n    _v.vectorized_assign(tmp_3, [N_0, D_0], [None, None], (_v.vectorized_access_simd(_8_0, [N_0, D_0], [None, None]) * _v.vectorized_access_simd(_9_0, [N_0, D_0], [None, None])))\n    _11_0 = _v.lift(lambda indices: min_diff_1, [N_0])\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], _v.vectorized_access(_3_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_2, [N_0], [_15_0], min_index_3)\n    for _14_0 in range(0, D_0):\n        # Set \u03d5 value\n        if _14_0 == 0:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(_7_0, [N_0, D_0], [None, _14_0]))\n        else:\n            _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n        _v.vectorized_assign(two_a_b_4, [N_0, D_0], [None, _14_0], (_v.vectorized_access_simd(two_a_b_3, [N_0, D_0], [None, _14_0]) + _v.vectorized_access_simd(tmp_3, [N_0, D_0], [None, _14_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(two_a_b_3, [N_0, D_0], [None, _14_0], _v.vectorized_access(two_a_b_4, [N_0, D_0], [None, (_14_0 - 1)]))\n    _v.vectorized_assign(_10_0, [N_0], [None], _v.drop_dim(two_a_b_4, [N_0, D_0]))\n    _v.vectorized_assign(this_diff_2, [N_0], [None], (_v.vectorized_access_simd(a_sqr_plus_b_sqr_2, [N_0], [None]) - _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_0, [N_0], [None], _v.vectorized_access(this_diff_2, [N_0], [None])); _v.vectorized_assign(differences_2, [N_0], [None], _v.vectorized_access(_4_0, [N_0], [None]))\n    for _random_iter in range(0,len(differences_2)):\n      differences_2_B[_random_iter] = _v.convertion_check(differences_2[_random_iter])\n    differences_2_B = siv32(differences_2_B);\n    differences_2_B = [None] * (N_0)\n    for _random_iter in range(0,len(differences_2)):\n      differences_2_B[_random_iter] = _v.convertion_check(differences_2[_random_iter])\n    differences_2_B = siv32(differences_2_B)\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(_11_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_1_2, [N_0], [_17_0], (_v.vectorized_access_simd(differences_2_B, [N_0], [_17_0]) < _v.vectorized_access_simd(min_diff_2, [N_0], [_17_0])))\n        _v.iterative_mux(min_diff_4,_1_2,differences_2_B,min_diff_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_diff_2, [N_0], [_17_0], _v.vectorized_access(min_diff_4, [N_0], [(_17_0 - 1)]))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_2, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n        _v.iterative_mux(min_index_6,_1_2,_16_0,min_index_4,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(min_index_4, [N_0], [_18_0], _v.vectorized_access(min_index_6, [N_0], [(_18_0 - 1)]))\n    _12_0 = _v.drop_dim(min_diff_4, [N_0])\n    _13_0 = _v.drop_dim(min_index_6, [N_0])\n    _2_1 = (_12_0,_13_0,)\n    return _2_1"
            }
        }
    },
    "chapterfour_figure_12": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger chapterfour_figure_12(\n    encrypto::motion::PartyPointer &party,\n    encrypto::motion::SecureUnsignedInteger x_0,\n    encrypto::motion::SecureUnsignedInteger y_0\n) {\n    // Shared variable declarations\n    encrypto::motion::ShareWrapper _1_1;\n    encrypto::motion::ShareWrapper _2_1;\n    encrypto::motion::SecureUnsignedInteger z_1;\n    encrypto::motion::SecureUnsignedInteger z_2;\n    encrypto::motion::SecureUnsignedInteger z_3;\n    encrypto::motion::SecureUnsignedInteger z_4;\n    encrypto::motion::SecureUnsignedInteger z_5;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_z_1;\n    std::uint32_t _MPC_PLAINTEXT_z_2;\n    std::uint32_t _MPC_PLAINTEXT_z_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    z_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_1 = std::uint32_t(0);\n    _1_1 = (x_0 > _MPC_CONSTANT_0);\n    _2_1 = (y_0 > _MPC_CONSTANT_0);\n    z_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_3 = std::uint32_t(0);\n    z_2 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_z_2 = std::uint32_t(1);\n    z_4 = _2_1.Mux(z_2.Get(), z_3.Get());\n    z_5 = _1_1.Mux(z_4.Get(), z_1.Get());\n    return z_5;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger chapterfour_figure_12(\n    encrypto::motion::PartyPointer &party,\n    encrypto::motion::SecureUnsignedInteger x_0,\n    encrypto::motion::SecureUnsignedInteger y_0\n) {\n    // Shared variable declarations\n    encrypto::motion::ShareWrapper _1_1;\n    encrypto::motion::ShareWrapper _2_1;\n    encrypto::motion::SecureUnsignedInteger z_1;\n    encrypto::motion::SecureUnsignedInteger z_2;\n    encrypto::motion::SecureUnsignedInteger z_3;\n    encrypto::motion::SecureUnsignedInteger z_4;\n    encrypto::motion::SecureUnsignedInteger z_5;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_z_1;\n    std::uint32_t _MPC_PLAINTEXT_z_2;\n    std::uint32_t _MPC_PLAINTEXT_z_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    z_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_1 = std::uint32_t(0);\n    _1_1 = (x_0 > _MPC_CONSTANT_0);\n    _2_1 = (y_0 > _MPC_CONSTANT_0);\n    z_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_3 = std::uint32_t(0);\n    z_2 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_z_2 = std::uint32_t(1);\n    z_4 = _2_1.Mux(z_2.Get(), z_3.Get());\n    z_5 = _1_1.Mux(z_4.Get(), z_1.Get());\n    return z_5;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger chapterfour_figure_12(\n    encrypto::motion::PartyPointer &party,\n    encrypto::motion::SecureUnsignedInteger x_0,\n    encrypto::motion::SecureUnsignedInteger y_0\n) {\n    // Shared variable declarations\n    encrypto::motion::ShareWrapper _1_1;\n    encrypto::motion::ShareWrapper _2_1;\n    encrypto::motion::SecureUnsignedInteger z_1;\n    encrypto::motion::SecureUnsignedInteger z_2;\n    encrypto::motion::SecureUnsignedInteger z_3;\n    encrypto::motion::SecureUnsignedInteger z_4;\n    encrypto::motion::SecureUnsignedInteger z_5;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_z_1;\n    std::uint32_t _MPC_PLAINTEXT_z_2;\n    std::uint32_t _MPC_PLAINTEXT_z_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    z_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_1 = std::uint32_t(0);\n    _1_1 = (x_0 > _MPC_CONSTANT_0_Y);\n    encrypto::motion::ShareWrapper _1_1_B;\n    _1_1_B = _1_1.Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    _2_1 = (y_0 > _MPC_CONSTANT_0_Y);\n    encrypto::motion::ShareWrapper _2_1_B;\n    _2_1_B = _2_1.Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    z_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_3 = std::uint32_t(0);\n    z_2 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_z_2 = std::uint32_t(1);\n    z_4 = _2_1_B.Mux(z_2.Get(), z_3.Get());\n    z_5 = _1_1_B.Mux(z_4.Get(), z_1.Get());\n    return z_5;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger chapterfour_figure_12(\n    encrypto::motion::PartyPointer &party,\n    encrypto::motion::SecureUnsignedInteger x_0,\n    encrypto::motion::SecureUnsignedInteger y_0\n) {\n    // Shared variable declarations\n    encrypto::motion::ShareWrapper _1_1;\n    encrypto::motion::ShareWrapper _2_1;\n    encrypto::motion::SecureUnsignedInteger z_1;\n    encrypto::motion::SecureUnsignedInteger z_2;\n    encrypto::motion::SecureUnsignedInteger z_3;\n    encrypto::motion::SecureUnsignedInteger z_4;\n    encrypto::motion::SecureUnsignedInteger z_5;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_z_1;\n    std::uint32_t _MPC_PLAINTEXT_z_2;\n    std::uint32_t _MPC_PLAINTEXT_z_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    z_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_1 = std::uint32_t(0);\n    _1_1 = (x_0 > _MPC_CONSTANT_0);\n    _2_1 = (y_0 > _MPC_CONSTANT_0);\n    z_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_3 = std::uint32_t(0);\n    z_2 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_z_2 = std::uint32_t(1);\n    z_4 = _2_1.Mux(z_2.Get(), z_3.Get());\n    z_5 = _1_1.Mux(z_4.Get(), z_1.Get());\n    return z_5;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger chapterfour_figure_12(\n    encrypto::motion::PartyPointer &party,\n    encrypto::motion::SecureUnsignedInteger x_0,\n    encrypto::motion::SecureUnsignedInteger y_0\n) {\n    // Shared variable declarations\n    encrypto::motion::ShareWrapper _1_1;\n    encrypto::motion::ShareWrapper _2_1;\n    encrypto::motion::SecureUnsignedInteger z_1;\n    encrypto::motion::SecureUnsignedInteger z_2;\n    encrypto::motion::SecureUnsignedInteger z_3;\n    encrypto::motion::SecureUnsignedInteger z_4;\n    encrypto::motion::SecureUnsignedInteger z_5;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_z_1;\n    std::uint32_t _MPC_PLAINTEXT_z_2;\n    std::uint32_t _MPC_PLAINTEXT_z_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    z_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_1 = std::uint32_t(0);\n    _1_1 = (x_0 > _MPC_CONSTANT_0);\n    _2_1 = (y_0 > _MPC_CONSTANT_0);\n    z_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_3 = std::uint32_t(0);\n    z_2 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_z_2 = std::uint32_t(1);\n    z_4 = _2_1.Mux(z_2.Get(), z_3.Get());\n    z_5 = _1_1.Mux(z_4.Get(), z_1.Get());\n    return z_5;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger chapterfour_figure_12(\n    encrypto::motion::PartyPointer &party,\n    encrypto::motion::SecureUnsignedInteger x_0,\n    encrypto::motion::SecureUnsignedInteger y_0\n) {\n    // Shared variable declarations\n    encrypto::motion::ShareWrapper _1_1;\n    encrypto::motion::ShareWrapper _2_1;\n    encrypto::motion::SecureUnsignedInteger z_1;\n    encrypto::motion::SecureUnsignedInteger z_2;\n    encrypto::motion::SecureUnsignedInteger z_3;\n    encrypto::motion::SecureUnsignedInteger z_4;\n    encrypto::motion::SecureUnsignedInteger z_5;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_z_1;\n    std::uint32_t _MPC_PLAINTEXT_z_2;\n    std::uint32_t _MPC_PLAINTEXT_z_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    z_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_1 = std::uint32_t(0);\n    _1_1 = (x_0 > _MPC_CONSTANT_0);\n    _2_1 = (y_0 > _MPC_CONSTANT_0);\n    z_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_3 = std::uint32_t(0);\n    z_2 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_z_2 = std::uint32_t(1);\n    z_4 = _2_1.Mux(z_2.Get(), z_3.Get());\n    z_5 = _1_1.Mux(z_4.Get(), z_1.Get());\n    return z_5;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger chapterfour_figure_12(\n    encrypto::motion::PartyPointer &party,\n    encrypto::motion::SecureUnsignedInteger x_0,\n    encrypto::motion::SecureUnsignedInteger y_0\n) {\n    // Shared variable declarations\n    encrypto::motion::ShareWrapper _1_1;\n    encrypto::motion::ShareWrapper _2_1;\n    encrypto::motion::SecureUnsignedInteger z_1;\n    encrypto::motion::SecureUnsignedInteger z_2;\n    encrypto::motion::SecureUnsignedInteger z_3;\n    encrypto::motion::SecureUnsignedInteger z_4;\n    encrypto::motion::SecureUnsignedInteger z_5;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_z_1;\n    std::uint32_t _MPC_PLAINTEXT_z_2;\n    std::uint32_t _MPC_PLAINTEXT_z_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    z_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_1 = std::uint32_t(0);\n    _1_1 = (x_0 > _MPC_CONSTANT_0);\n    _2_1 = (y_0 > _MPC_CONSTANT_0);\n    z_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_3 = std::uint32_t(0);\n    z_2 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_z_2 = std::uint32_t(1);\n    z_4 = _2_1.Mux(z_2.Get(), z_3.Get());\n    z_5 = _1_1.Mux(z_4.Get(), z_1.Get());\n    return z_5;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger chapterfour_figure_12(\n    encrypto::motion::PartyPointer &party,\n    encrypto::motion::SecureUnsignedInteger x_0,\n    encrypto::motion::SecureUnsignedInteger y_0\n) {\n    // Shared variable declarations\n    encrypto::motion::ShareWrapper _1_1;\n    encrypto::motion::ShareWrapper _2_1;\n    encrypto::motion::SecureUnsignedInteger z_1;\n    encrypto::motion::SecureUnsignedInteger z_2;\n    encrypto::motion::SecureUnsignedInteger z_3;\n    encrypto::motion::SecureUnsignedInteger z_4;\n    encrypto::motion::SecureUnsignedInteger z_5;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_z_1;\n    std::uint32_t _MPC_PLAINTEXT_z_2;\n    std::uint32_t _MPC_PLAINTEXT_z_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    z_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_1 = std::uint32_t(0);\n    _1_1 = (x_0 > _MPC_CONSTANT_0);\n    _2_1 = (y_0 > _MPC_CONSTANT_0);\n    z_3 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_z_3 = std::uint32_t(0);\n    z_2 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_z_2 = std::uint32_t(1);\n    z_4 = _2_1.Mux(z_2.Get(), z_3.Get());\n    z_5 = _1_1.Mux(z_4.Get(), z_1.Get());\n    return z_5;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger chapterfour_figure_12(\n    encrypto::motion::PartyPointer &party,\n    encrypto::motion::SecureUnsignedInteger x_0,\n    encrypto::motion::SecureUnsignedInteger y_0\n) {\n    // Shared variable declarations\n    encrypto::motion::ShareWrapper _1_1;\n    encrypto::motion::ShareWrapper _2_1;\n    encrypto::motion::SecureUnsignedInteger z_1;\n    encrypto::motion::SecureUnsignedInteger z_2;\n    encrypto::motion::SecureUnsignedInteger z_3;\n    encrypto::motion::SecureUnsignedInteger z_4;\n    encrypto::motion::SecureUnsignedInteger z_5;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_z_1;\n    std::uint32_t _MPC_PLAINTEXT_z_2;\n    std::uint32_t _MPC_PLAINTEXT_z_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    z_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_z_1 = std::uint32_t(0);\n    _1_1 = (x_0 > _MPC_CONSTANT_0);\n    encrypto::motion::ShareWrapper _1_1_Y;\n    _1_1_Y = _1_1.Convert<encrypto::motion::MpcProtocol::kBmr>();\n    _2_1 = (y_0 > _MPC_CONSTANT_0);\n    encrypto::motion::ShareWrapper _2_1_Y;\n    _2_1_Y = _2_1.Convert<encrypto::motion::MpcProtocol::kBmr>();\n    z_3 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_z_3 = std::uint32_t(0);\n    z_2 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_z_2 = std::uint32_t(1);\n    z_4 = _2_1_Y.Mux(z_2.Get(), z_3.Get());\n    z_5 = _1_1_Y.Mux(z_4.Get(), z_1.Get());\n    return z_5;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = sint(0)\n    _1_1 = (x_0 > sint(0))\n    _2_1 = (y_0 > sint(0))\n    z_3 = sint(0)\n    z_2 = sint(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5",
                "B": "program.options.binary = 32\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = siv32(0)\n    _1_1 = (x_0 > siv32(0))\n    _2_1 = (y_0 > siv32(0))\n    z_3 = siv32(0)\n    z_2 = siv32(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = sint(0)\n    _1_1 = (x_0 > sint(0))\n    _2_1 = (y_0 > sint(0))\n    z_3 = sint(0)\n    z_2 = sint(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = sint(0)\n    _1_1 = (x_0 > sint(0))\n    _2_1 = (y_0 > sint(0))\n    z_3 = sint(0)\n    z_2 = sint(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = siv32(0)\n    _1_1 = (x_0 > siv32(0))\n    _2_1 = (y_0 > siv32(0))\n    z_3 = siv32(0)\n    z_2 = siv32(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = sint(0)\n    _1_1 = (x_0 > sint(0))\n    _2_1 = (y_0 > sint(0))\n    z_3 = sint(0)\n    z_2 = sint(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5",
                "B": "program.options.binary = 32\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = siv32(0)\n    _1_1 = (x_0 > siv32(0))\n    _2_1 = (y_0 > siv32(0))\n    z_3 = siv32(0)\n    z_2 = siv32(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = sint(0)\n    _1_1 = (x_0 > sint(0))\n    _2_1 = (y_0 > sint(0))\n    z_3 = sint(0)\n    z_2 = sint(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = sint(0)\n    _1_1 = (x_0 > sint(0))\n    _2_1 = (y_0 > sint(0))\n    z_3 = sint(0)\n    z_2 = sint(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = siv32(0)\n    _1_1 = (x_0 > siv32(0))\n    _2_1 = (y_0 > siv32(0))\n    z_3 = siv32(0)\n    z_2 = siv32(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5"
            },
            "time": {
                "A": "program.options.binary = 32\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = sint(0)\n    _1_1 = (x_0 > sint(0))\n    _2_1 = (y_0 > sint(0))\n    z_3 = sint(0)\n    z_2 = sint(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5",
                "B": "program.options.binary = 32\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = siv32(0)\n    _1_1 = (x_0 > siv32(0))\n    _2_1 = (y_0 > siv32(0))\n    z_3 = siv32(0)\n    z_2 = siv32(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = sint(0)\n    _1_1 = (x_0 > sint(0))\n    _2_1 = (y_0 > sint(0))\n    z_3 = sint(0)\n    z_2 = sint(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = sint(0)\n    _1_1 = (x_0 > sint(0))\n    _2_1 = (y_0 > sint(0))\n    z_3 = sint(0)\n    z_2 = sint(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef chapterfour_figure_12(x_0, y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n\n    # Shared array convertion declarations\n    \n    # Function body\n    z_1 = siv32(0)\n    _1_1 = (x_0 > siv32(0))\n    _2_1 = (y_0 > siv32(0))\n    z_3 = siv32(0)\n    z_2 = siv32(1)\n    z_4 = _2_1.if_else(z_2, z_3)\n    z_5 = _1_1.if_else(z_4, z_1)\n    return z_5"
            }
        }
    },
    "convex_hull": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> convex_hull(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_X_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _10_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _20_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper is_hull_2;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper is_hull_4;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_5((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> is_hull_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__10_1;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    bool _MPC_PLAINTEXT_is_hull_2;\n    bool _MPC_PLAINTEXT_is_hull_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_X_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_X_0.begin(), _MPC_PLAINTEXT_result_X_0.end(), std::back_inserter(result_X_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n    result_Y_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_Y_0.begin(), _MPC_PLAINTEXT_result_Y_0.end(), std::back_inserter(result_Y_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    is_hull_2 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_is_hull_2 = true;\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    is_hull_4 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_is_hull_4 = false;\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0})) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) | (to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))) | (to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | to_share_wrapper(vectorized_access(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n    vectorized_assign(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (~vectorized_access(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}));\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Mux(decltype(is_hull_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_4;}), {_MPC_PLAINTEXT_N_0})).Get(), vectorized_access(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Get()));\n\n    }\n\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), decltype(is_hull_2)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0})).Get()));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _10_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _10_1;\n\n}",
                "Y": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> convex_hull(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_X_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _10_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _20_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper is_hull_2;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper is_hull_4;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_5((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> is_hull_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__10_1;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    bool _MPC_PLAINTEXT_is_hull_2;\n    bool _MPC_PLAINTEXT_is_hull_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_X_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_X_0.begin(), _MPC_PLAINTEXT_result_X_0.end(), std::back_inserter(result_X_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n    result_Y_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_Y_0.begin(), _MPC_PLAINTEXT_result_Y_0.end(), std::back_inserter(result_Y_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    is_hull_2 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_is_hull_2 = true;\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    is_hull_4 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_is_hull_4 = false;\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0})) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) | (to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))) | (to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | to_share_wrapper(vectorized_access(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n    vectorized_assign(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (~vectorized_access(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}));\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Mux(decltype(is_hull_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_4;}), {_MPC_PLAINTEXT_N_0})).Get(), vectorized_access(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Get()));\n\n    }\n\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), decltype(is_hull_2)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0})).Get()));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _10_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _10_1;\n\n}",
                "mixed": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> convex_hull(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_X_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _10_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _20_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper is_hull_2;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper is_hull_4;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_5((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> is_hull_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__10_1;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    bool _MPC_PLAINTEXT_is_hull_2;\n    bool _MPC_PLAINTEXT_is_hull_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_X_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_X_0.begin(), _MPC_PLAINTEXT_result_X_0.end(), std::back_inserter(result_X_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n    result_Y_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_Y_0.begin(), _MPC_PLAINTEXT_result_Y_0.end(), std::back_inserter(result_Y_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    is_hull_2 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_is_hull_2 = true;\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    is_hull_4 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_is_hull_4 = false;\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0})) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) | (to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))) | (to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | to_share_wrapper(vectorized_access(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n    vectorized_assign(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (~vectorized_access(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}));\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Mux(decltype(is_hull_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_4;}), {_MPC_PLAINTEXT_N_0})).Get(), vectorized_access(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Get()));\n\n    }\n\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), decltype(is_hull_2)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0})).Get()));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _10_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _10_1;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> convex_hull(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_X_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _10_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _20_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper is_hull_2;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper is_hull_4;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_5((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> is_hull_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__10_1;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    bool _MPC_PLAINTEXT_is_hull_2;\n    bool _MPC_PLAINTEXT_is_hull_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_X_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_X_0.begin(), _MPC_PLAINTEXT_result_X_0.end(), std::back_inserter(result_X_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n    result_Y_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_Y_0.begin(), _MPC_PLAINTEXT_result_Y_0.end(), std::back_inserter(result_Y_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    is_hull_2 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_is_hull_2 = true;\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    is_hull_4 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_is_hull_4 = false;\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0})) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) | (to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))) | (to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | to_share_wrapper(vectorized_access(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n    vectorized_assign(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (~vectorized_access(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}));\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Mux(decltype(is_hull_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_4;}), {_MPC_PLAINTEXT_N_0})).Get(), vectorized_access(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Get()));\n\n    }\n\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), decltype(is_hull_2)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0})).Get()));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _10_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _10_1;\n\n}",
                "Y": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> convex_hull(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_X_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _10_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _20_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper is_hull_2;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper is_hull_4;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_5((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> is_hull_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__10_1;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    bool _MPC_PLAINTEXT_is_hull_2;\n    bool _MPC_PLAINTEXT_is_hull_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_X_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_X_0.begin(), _MPC_PLAINTEXT_result_X_0.end(), std::back_inserter(result_X_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n    result_Y_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_Y_0.begin(), _MPC_PLAINTEXT_result_Y_0.end(), std::back_inserter(result_Y_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    is_hull_2 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_is_hull_2 = true;\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    is_hull_4 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_is_hull_4 = false;\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0})) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) | (to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))) | (to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | to_share_wrapper(vectorized_access(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n    vectorized_assign(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (~vectorized_access(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}));\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Mux(decltype(is_hull_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_4;}), {_MPC_PLAINTEXT_N_0})).Get(), vectorized_access(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Get()));\n\n    }\n\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), decltype(is_hull_2)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0})).Get()));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _10_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _10_1;\n\n}",
                "mixed": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> convex_hull(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_X_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _10_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _20_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper is_hull_2;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper is_hull_4;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_5((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> is_hull_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__10_1;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    bool _MPC_PLAINTEXT_is_hull_2;\n    bool _MPC_PLAINTEXT_is_hull_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_X_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_X_0.begin(), _MPC_PLAINTEXT_result_X_0.end(), std::back_inserter(result_X_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n    result_Y_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_Y_0.begin(), _MPC_PLAINTEXT_result_Y_0.end(), std::back_inserter(result_Y_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    is_hull_2 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_is_hull_2 = true;\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    is_hull_4 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_is_hull_4 = false;\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0})) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) | (to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))) | (to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | to_share_wrapper(vectorized_access(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n    vectorized_assign(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (~vectorized_access(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}));\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Mux(decltype(is_hull_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_4;}), {_MPC_PLAINTEXT_N_0})).Get(), vectorized_access(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Get()));\n\n    }\n\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), decltype(is_hull_2)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0})).Get()));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _10_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _10_1;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> convex_hull(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_X_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _10_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _20_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper is_hull_2;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper is_hull_4;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_5((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> is_hull_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__10_1;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    bool _MPC_PLAINTEXT_is_hull_2;\n    bool _MPC_PLAINTEXT_is_hull_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_X_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_X_0.begin(), _MPC_PLAINTEXT_result_X_0.end(), std::back_inserter(result_X_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n    result_Y_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_Y_0.begin(), _MPC_PLAINTEXT_result_Y_0.end(), std::back_inserter(result_Y_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    is_hull_2 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_is_hull_2 = true;\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    is_hull_4 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_is_hull_4 = false;\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0})) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) | (to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))) | (to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | to_share_wrapper(vectorized_access(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n    vectorized_assign(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (~vectorized_access(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}));\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Mux(decltype(is_hull_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_4;}), {_MPC_PLAINTEXT_N_0})).Get(), vectorized_access(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Get()));\n\n    }\n\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), decltype(is_hull_2)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0})).Get()));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _10_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _10_1;\n\n}",
                "Y": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> convex_hull(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_X_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _10_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _20_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper is_hull_2;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper is_hull_4;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_5((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> is_hull_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__10_1;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    bool _MPC_PLAINTEXT_is_hull_2;\n    bool _MPC_PLAINTEXT_is_hull_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_X_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_X_0.begin(), _MPC_PLAINTEXT_result_X_0.end(), std::back_inserter(result_X_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n    result_Y_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_Y_0.begin(), _MPC_PLAINTEXT_result_Y_0.end(), std::back_inserter(result_Y_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    is_hull_2 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_is_hull_2 = true;\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    is_hull_4 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_is_hull_4 = false;\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0})) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) | (to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))) | (to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | to_share_wrapper(vectorized_access(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n    vectorized_assign(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (~vectorized_access(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}));\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Mux(decltype(is_hull_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_4;}), {_MPC_PLAINTEXT_N_0})).Get(), vectorized_access(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Get()));\n\n    }\n\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), decltype(is_hull_2)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0})).Get()));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _10_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _10_1;\n\n}",
                "mixed": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> convex_hull(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_X_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _10_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _20_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper is_hull_2;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper is_hull_4;\n    std::vector<encrypto::motion::ShareWrapper> is_hull_5((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> is_hull_6((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__10_1;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    bool _MPC_PLAINTEXT_is_hull_2;\n    bool _MPC_PLAINTEXT_is_hull_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_X_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_X_0.begin(), _MPC_PLAINTEXT_result_X_0.end(), std::back_inserter(result_X_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n    result_Y_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_Y_0.begin(), _MPC_PLAINTEXT_result_Y_0.end(), std::back_inserter(result_Y_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    is_hull_2 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_is_hull_2 = true;\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    is_hull_4 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_is_hull_4 = false;\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0})) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) | (to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, ((vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))) | (to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_N_0}))))));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, ((vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | (to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})))));\n    vectorized_assign(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_6_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) | to_share_wrapper(vectorized_access(_7_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n    vectorized_assign(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (~vectorized_access(_8_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}));\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            vectorized_assign(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}, vectorized_access(_9_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Mux(decltype(is_hull_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_4;}), {_MPC_PLAINTEXT_N_0})).Get(), vectorized_access(is_hull_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__21_0}).Get()));\n\n    }\n\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(is_hull_5, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_20_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), decltype(is_hull_2)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return is_hull_2;}), {_MPC_PLAINTEXT_N_0})).Get()));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(is_hull_6, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _10_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _10_1;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sint(_v.sbool(True))\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sint(_v.sbool(False))\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= sint(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= sint(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1",
                "B": "program.options.binary = 32\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    result_X_0 = [elem for elem in sint(result_X_0)]\n\n    result_Y_0 = [elem for elem in sint(result_Y_0)]\n\n\n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sbit(1)\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sbit(0)\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= siv32(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= siv32(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sint(_v.sbool(True))\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sint(_v.sbool(False))\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= sint(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= sint(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sint(_v.sbool(True))\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sint(_v.sbool(False))\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= sint(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= sint(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    result_X_0 = [elem for elem in sint(result_X_0)]\n\n    result_Y_0 = [elem for elem in sint(result_Y_0)]\n\n\n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sbit(1)\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sbit(0)\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= siv32(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= siv32(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sint(_v.sbool(True))\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sint(_v.sbool(False))\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= sint(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= sint(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1",
                "B": "program.options.binary = 32\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    result_X_0 = [elem for elem in sint(result_X_0)]\n\n    result_Y_0 = [elem for elem in sint(result_Y_0)]\n\n\n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sbit(1)\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sbit(0)\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= siv32(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= siv32(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sint(_v.sbool(True))\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sint(_v.sbool(False))\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= sint(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= sint(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sint(_v.sbool(True))\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sint(_v.sbool(False))\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= sint(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= sint(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    result_X_0 = [elem for elem in sint(result_X_0)]\n\n    result_Y_0 = [elem for elem in sint(result_Y_0)]\n\n\n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sbit(1)\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sbit(0)\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= siv32(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= siv32(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1"
            },
            "time": {
                "A": "program.options.binary = 32\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sint(_v.sbool(True))\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sint(_v.sbool(False))\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= sint(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= sint(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1",
                "B": "program.options.binary = 32\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    result_X_0 = [elem for elem in sint(result_X_0)]\n\n    result_Y_0 = [elem for elem in sint(result_Y_0)]\n\n\n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sbit(1)\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sbit(0)\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= siv32(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= siv32(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sint(_v.sbool(True))\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sint(_v.sbool(False))\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= sint(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= sint(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sint(_v.sbool(True))\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sint(_v.sbool(False))\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= sint(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= sint(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef convex_hull(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    result_X_0 = [elem for elem in sint(result_X_0)]\n\n    result_Y_0 = [elem for elem in sint(result_Y_0)]\n\n\n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0 * N_0)\n    _16_0 = [None] * (N_0 * N_0)\n    _17_0 = [None] * (N_0 * N_0)\n    _18_0 = [None] * (N_0 * N_0)\n    _19_0 = [None] * (N_0 * N_0)\n    _2_2 = [None] * (N_0)\n    _20_0 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _6_3 = [None] * (N_0 * N_0)\n    _7_3 = [None] * (N_0 * N_0)\n    _8_3 = [None] * (N_0 * N_0)\n    _9_3 = [None] * (N_0 * N_0)\n    is_hull_3 = [None] * (N_0 * N_0)\n    is_hull_5 = [None] * (N_0 * N_0)\n    is_hull_6 = [None] * (N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _11_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _12_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _13_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    is_hull_2 = sbit(1)\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    is_hull_4 = sbit(0)\n    _15_0 = _v.lift(lambda indices: is_hull_2, [N_0, N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_13_0, [N_0], [None]) <= siv32(0)))\n    _18_0 = _v.lift(lambda indices: _v.vectorized_access(_13_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_14_0, [N_0], [None]) >= siv32(0)))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_14_0, [N_0], [None]), [N_0, N_0])\n    _v.vectorized_assign(_6_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_18_0, [N_0, N_0], [None, None]) <= _v.vectorized_access_simd(_16_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    _v.vectorized_assign(_7_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_19_0, [N_0, N_0], [None, None]) >= _v.vectorized_access_simd(_17_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_8_3, [N_0, N_0], [None, None], OR(_v.vectorized_access_simd(_6_3, [N_0, N_0], [None, None]), _v.vectorized_access_simd(_7_3, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_9_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_8_3, [N_0, N_0], [None, None]).bit_not()))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(_15_0, [N_0, N_0], [None, _21_0]))\n        else:\n            _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n        _v.iterative_mux(is_hull_5,_9_3,is_hull_4,is_hull_3,[N_0, N_0],[None, _21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(is_hull_3, [N_0, N_0], [None, _21_0], _v.vectorized_access(is_hull_5, [N_0, N_0], [None, (_21_0 - 1)]))\n    _v.vectorized_assign(_20_0, [N_0], [None], _v.drop_dim(is_hull_5, [N_0, N_0]))\n    _v.iterative_mux(is_hull_6,_3_2,_20_0,is_hull_2,[N_0],[None])\n    _v.iterative_mux(val_X_4,is_hull_6,_13_0,_11_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,is_hull_6,_14_0,_12_0,[N_0],[None])\n    _v.vectorized_assign(_11_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_11_0, [N_0], [None]))\n    _v.vectorized_assign(_12_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_12_0, [N_0], [None]))\n    _10_1 = (result_X_2,result_Y_2,)\n    return _10_1"
            }
        }
    },
    "count_102": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger count_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__16_0] = _7_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__16_0] = s0_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__16_0]));\n        s0_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(_6_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__17_0] = c_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__17_0] = (c_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(c_3[_MPC_PLAINTEXT__17_0].Get(), c_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger count_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__16_0] = _7_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__16_0] = s0_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__16_0]));\n        s0_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(_6_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__17_0] = c_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__17_0] = (c_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(c_3[_MPC_PLAINTEXT__17_0].Get(), c_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger count_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__16_0] = _7_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__16_0] = s0_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__16_0]));\n        s0_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(_6_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0]; c_2_B[_MPC_PLAINTEXT__17_0] = c_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__17_0] = c_4_Y[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))]; c_2_B[_MPC_PLAINTEXT__17_0] = c_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        c_3[_MPC_PLAINTEXT__17_0] = (c_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1_Y); c_3_B[_MPC_PLAINTEXT__17_0] = c_3[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        c_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(c_3_B[_MPC_PLAINTEXT__17_0].Get(), c_2_B[_MPC_PLAINTEXT__17_0].Get()); c_4_Y[_MPC_PLAINTEXT__17_0] = c_4[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _15_0_Y; _15_0_Y = drop_dim_monoreturn(vectorized_access(c_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger count_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__16_0] = _7_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__16_0] = s0_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__16_0]));\n        s0_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(_6_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__17_0] = c_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__17_0] = (c_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(c_3[_MPC_PLAINTEXT__17_0].Get(), c_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger count_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__16_0] = _7_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__16_0] = s0_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__16_0]));\n        s0_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(_6_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__17_0] = c_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__17_0] = (c_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(c_3[_MPC_PLAINTEXT__17_0].Get(), c_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger count_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__16_0] = _7_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__16_0] = s0_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__16_0]));\n        s0_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(_6_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0]; c_2_B[_MPC_PLAINTEXT__17_0] = c_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__17_0] = c_4_Y[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))]; c_2_B[_MPC_PLAINTEXT__17_0] = c_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        c_3[_MPC_PLAINTEXT__17_0] = (c_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1_Y); c_3_B[_MPC_PLAINTEXT__17_0] = c_3[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        c_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(c_3_B[_MPC_PLAINTEXT__17_0].Get(), c_2_B[_MPC_PLAINTEXT__17_0].Get()); c_4_Y[_MPC_PLAINTEXT__17_0] = c_4[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _15_0_Y; _15_0_Y = drop_dim_monoreturn(vectorized_access(c_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger count_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__16_0] = _7_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__16_0] = s0_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__16_0]));\n        s0_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(_6_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__17_0] = c_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__17_0] = (c_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(c_3[_MPC_PLAINTEXT__17_0].Get(), c_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger count_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__16_0] = _7_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__16_0] = s0_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__16_0]));\n        s0_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(_6_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__17_0] = c_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__17_0] = (c_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(c_3[_MPC_PLAINTEXT__17_0].Get(), c_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger count_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__16_0] = _7_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__16_0] = s0_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__16_0]));\n        s0_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(_6_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__17_0] = c_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__17_0] = (c_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(c_3[_MPC_PLAINTEXT__17_0].Get(), c_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "B": "program.options.binary = 32\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    c_1 = siv32(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    c_1 = siv32(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "B": "program.options.binary = 32\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    c_1 = siv32(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    c_1 = siv32(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0"
            },
            "time": {
                "A": "program.options.binary = 32\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "B": "program.options.binary = 32\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    c_1 = siv32(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    c_1 = siv32(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _7_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(_7_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_16_0], _v.vectorized_access_simd(s0_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_16_0], OR(_v.vectorized_access_simd(_3_2, [N_0], [_16_0]), _v.vectorized_access_simd(_6_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_16_0], _v.vectorized_access(s0_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_17_0], (_v.vectorized_access_simd(c_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(c_4,_2_2,c_3,c_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_17_0], _v.vectorized_access(c_4, [N_0], [(_17_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0"
            }
        }
    },
    "count_10s": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger count_10s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger scount_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    bool _MPC_PLAINTEXT_s0_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    std::uint32_t _MPC_PLAINTEXT_scount_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    scount_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_scount_1 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return scount_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~(to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__15_0] = _5_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__15_0] = s0_3[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _4_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(s1_2[_MPC_PLAINTEXT__16_0]));\n        s1_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    scount_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            scount_2[_MPC_PLAINTEXT__17_0] = scount_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        scount_3[_MPC_PLAINTEXT__17_0] = (scount_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        scount_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(scount_3[_MPC_PLAINTEXT__17_0].Get(), scount_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _14_0 = drop_dim_monoreturn(vectorized_access(scount_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _14_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger count_10s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger scount_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    bool _MPC_PLAINTEXT_s0_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    std::uint32_t _MPC_PLAINTEXT_scount_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    scount_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_scount_1 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return scount_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~(to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__15_0] = _5_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__15_0] = s0_3[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _4_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(s1_2[_MPC_PLAINTEXT__16_0]));\n        s1_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    scount_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            scount_2[_MPC_PLAINTEXT__17_0] = scount_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        scount_3[_MPC_PLAINTEXT__17_0] = (scount_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        scount_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(scount_3[_MPC_PLAINTEXT__17_0].Get(), scount_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _14_0 = drop_dim_monoreturn(vectorized_access(scount_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _14_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger count_10s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger scount_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    bool _MPC_PLAINTEXT_s0_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    std::uint32_t _MPC_PLAINTEXT_scount_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    scount_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_scount_1 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return scount_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~(to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__15_0] = _5_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__15_0] = s0_3[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _4_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(s1_2[_MPC_PLAINTEXT__16_0]));\n        s1_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    scount_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0]; scount_2_B[_MPC_PLAINTEXT__17_0] = scount_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            scount_2[_MPC_PLAINTEXT__17_0] = scount_4_Y[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))]; scount_2_B[_MPC_PLAINTEXT__17_0] = scount_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        scount_3[_MPC_PLAINTEXT__17_0] = (scount_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1_Y); scount_3_B[_MPC_PLAINTEXT__17_0] = scount_3[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        scount_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(scount_3_B[_MPC_PLAINTEXT__17_0].Get(), scount_2_B[_MPC_PLAINTEXT__17_0].Get()); scount_4_Y[_MPC_PLAINTEXT__17_0] = scount_4[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    _14_0 = drop_dim_monoreturn(vectorized_access(scount_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _14_0_Y; _14_0_Y = drop_dim_monoreturn(vectorized_access(scount_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _14_0;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger count_10s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger scount_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    bool _MPC_PLAINTEXT_s0_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    std::uint32_t _MPC_PLAINTEXT_scount_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    scount_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_scount_1 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return scount_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~(to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__15_0] = _5_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__15_0] = s0_3[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _4_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(s1_2[_MPC_PLAINTEXT__16_0]));\n        s1_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    scount_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            scount_2[_MPC_PLAINTEXT__17_0] = scount_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        scount_3[_MPC_PLAINTEXT__17_0] = (scount_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        scount_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(scount_3[_MPC_PLAINTEXT__17_0].Get(), scount_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _14_0 = drop_dim_monoreturn(vectorized_access(scount_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _14_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger count_10s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger scount_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    bool _MPC_PLAINTEXT_s0_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    std::uint32_t _MPC_PLAINTEXT_scount_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    scount_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_scount_1 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return scount_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~(to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__15_0] = _5_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__15_0] = s0_3[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _4_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(s1_2[_MPC_PLAINTEXT__16_0]));\n        s1_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    scount_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            scount_2[_MPC_PLAINTEXT__17_0] = scount_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        scount_3[_MPC_PLAINTEXT__17_0] = (scount_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        scount_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(scount_3[_MPC_PLAINTEXT__17_0].Get(), scount_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _14_0 = drop_dim_monoreturn(vectorized_access(scount_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _14_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger count_10s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger scount_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    bool _MPC_PLAINTEXT_s0_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    std::uint32_t _MPC_PLAINTEXT_scount_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    scount_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_scount_1 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return scount_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~(to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__15_0] = _5_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__15_0] = s0_3[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _4_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(s1_2[_MPC_PLAINTEXT__16_0]));\n        s1_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    scount_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0]; scount_2_B[_MPC_PLAINTEXT__17_0] = scount_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            scount_2[_MPC_PLAINTEXT__17_0] = scount_4_Y[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))]; scount_2_B[_MPC_PLAINTEXT__17_0] = scount_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        scount_3[_MPC_PLAINTEXT__17_0] = (scount_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1_Y); scount_3_B[_MPC_PLAINTEXT__17_0] = scount_3[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        scount_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(scount_3_B[_MPC_PLAINTEXT__17_0].Get(), scount_2_B[_MPC_PLAINTEXT__17_0].Get()); scount_4_Y[_MPC_PLAINTEXT__17_0] = scount_4[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    _14_0 = drop_dim_monoreturn(vectorized_access(scount_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _14_0_Y; _14_0_Y = drop_dim_monoreturn(vectorized_access(scount_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _14_0;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger count_10s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger scount_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    bool _MPC_PLAINTEXT_s0_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    std::uint32_t _MPC_PLAINTEXT_scount_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    scount_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_scount_1 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return scount_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~(to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__15_0] = _5_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__15_0] = s0_3[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _4_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(s1_2[_MPC_PLAINTEXT__16_0]));\n        s1_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    scount_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            scount_2[_MPC_PLAINTEXT__17_0] = scount_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        scount_3[_MPC_PLAINTEXT__17_0] = (scount_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        scount_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(scount_3[_MPC_PLAINTEXT__17_0].Get(), scount_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _14_0 = drop_dim_monoreturn(vectorized_access(scount_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _14_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger count_10s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger scount_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    bool _MPC_PLAINTEXT_s0_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    std::uint32_t _MPC_PLAINTEXT_scount_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    scount_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_scount_1 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return scount_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~(to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__15_0] = _5_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__15_0] = s0_3[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _4_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(s1_2[_MPC_PLAINTEXT__16_0]));\n        s1_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    scount_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            scount_2[_MPC_PLAINTEXT__17_0] = scount_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        scount_3[_MPC_PLAINTEXT__17_0] = (scount_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        scount_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(scount_3[_MPC_PLAINTEXT__17_0].Get(), scount_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _14_0 = drop_dim_monoreturn(vectorized_access(scount_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _14_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger count_10s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _14_0;\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger scount_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> scount_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__15_0;\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    bool _MPC_PLAINTEXT_s0_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    std::uint32_t _MPC_PLAINTEXT_scount_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    scount_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_scount_1 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return scount_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~(to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__15_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__15_0] = _5_0[_MPC_PLAINTEXT__15_0];\n    for (; _MPC_PLAINTEXT__15_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__15_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__15_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__15_0] = s0_3[(_MPC_PLAINTEXT__15_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n        _4_2[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__16_0]) | to_share_wrapper(s1_2[_MPC_PLAINTEXT__16_0]));\n        s1_3[_MPC_PLAINTEXT__16_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__16_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__16_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    scount_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            scount_2[_MPC_PLAINTEXT__17_0] = scount_4[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        scount_3[_MPC_PLAINTEXT__17_0] = (scount_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        scount_4[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(scount_3[_MPC_PLAINTEXT__17_0].Get(), scount_2[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    _14_0 = drop_dim_monoreturn(vectorized_access(scount_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _14_0;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    s1_1 = sint(_v.sbool(False))\n    scount_1 = sint(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0",
                "B": "program.options.binary = 32\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    s1_1 = sbit(0)\n    scount_1 = siv32(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    s1_1 = sint(_v.sbool(False))\n    scount_1 = sint(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    s1_1 = sint(_v.sbool(False))\n    scount_1 = sint(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    s1_1 = sbit(0)\n    scount_1 = siv32(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    s1_1 = sint(_v.sbool(False))\n    scount_1 = sint(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0",
                "B": "program.options.binary = 32\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    s1_1 = sbit(0)\n    scount_1 = siv32(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    s1_1 = sint(_v.sbool(False))\n    scount_1 = sint(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    s1_1 = sint(_v.sbool(False))\n    scount_1 = sint(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    s1_1 = sbit(0)\n    scount_1 = siv32(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0"
            },
            "time": {
                "A": "program.options.binary = 32\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    s1_1 = sint(_v.sbool(False))\n    scount_1 = sint(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0",
                "B": "program.options.binary = 32\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    s1_1 = sbit(0)\n    scount_1 = siv32(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    s1_1 = sint(_v.sbool(False))\n    scount_1 = sint(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    s1_1 = sint(_v.sbool(False))\n    scount_1 = sint(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + sint(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_10s(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    scount_2 = [None] * (N_0)\n    scount_3 = [None] * (N_0)\n    scount_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    s1_1 = sbit(0)\n    scount_1 = siv32(0)\n    _8_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _9_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _5_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: scount_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) != _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_9_0, [N_0], [None])))\n    _v.vectorized_assign(s0_3, [N_0], [None], (_v.vectorized_access_simd(_8_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    for _15_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _15_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(_5_0, [N_0], [_15_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_15_0], _v.vectorized_access(s0_3, [N_0], [(_15_0 - 1)]))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n        _v.vectorized_assign(_4_2, [N_0], [_16_0], OR(_v.vectorized_access_simd(s0_2, [N_0], [_16_0]), _v.vectorized_access_simd(s1_2, [N_0], [_16_0])))\n        _v.vectorized_assign(s1_3, [N_0], [_16_0], _v.vectorized_access_simd(_3_2, [N_0], [_16_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_16_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], _v.vectorized_access_simd(s1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(scount_3, [N_0], [_17_0], (_v.vectorized_access_simd(scount_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(scount_4,_2_2,scount_3,scount_2,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(scount_2, [N_0], [_17_0], _v.vectorized_access(scount_4, [N_0], [(_17_0 - 1)]))\n    _14_0 = _v.drop_dim(scount_4, [N_0])\n    return _14_0"
            }
        }
    },
    "count_123": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger count_123(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s1_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__17_0] = s2_3[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__17_0]) | to_share_wrapper(s2_2[_MPC_PLAINTEXT__17_0]));\n        s2_3[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(_4_2[_MPC_PLAINTEXT__17_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__17_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__18_0] = _8_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__18_0] = c_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__18_0] = (c_2[_MPC_PLAINTEXT__18_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__18_0] = _3_2[_MPC_PLAINTEXT__18_0].Mux(c_3[_MPC_PLAINTEXT__18_0].Get(), c_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger count_123(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s1_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__17_0] = s2_3[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__17_0]) | to_share_wrapper(s2_2[_MPC_PLAINTEXT__17_0]));\n        s2_3[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(_4_2[_MPC_PLAINTEXT__17_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__17_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__18_0] = _8_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__18_0] = c_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__18_0] = (c_2[_MPC_PLAINTEXT__18_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__18_0] = _3_2[_MPC_PLAINTEXT__18_0].Mux(c_3[_MPC_PLAINTEXT__18_0].Get(), c_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger count_123(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s1_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__17_0] = s2_3[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__17_0]) | to_share_wrapper(s2_2[_MPC_PLAINTEXT__17_0]));\n        s2_3[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(_4_2[_MPC_PLAINTEXT__17_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__17_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__18_0] = _8_0[_MPC_PLAINTEXT__18_0]; c_2_B[_MPC_PLAINTEXT__18_0] = c_2[_MPC_PLAINTEXT__18_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__18_0] = c_4_Y[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))]; c_2_B[_MPC_PLAINTEXT__18_0] = c_2[_MPC_PLAINTEXT__18_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        c_3[_MPC_PLAINTEXT__18_0] = (c_2[_MPC_PLAINTEXT__18_0] + _MPC_CONSTANT_1_Y); c_3_B[_MPC_PLAINTEXT__18_0] = c_3[_MPC_PLAINTEXT__18_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        c_4[_MPC_PLAINTEXT__18_0] = _3_2[_MPC_PLAINTEXT__18_0].Mux(c_3_B[_MPC_PLAINTEXT__18_0].Get(), c_2_B[_MPC_PLAINTEXT__18_0].Get()); c_4_Y[_MPC_PLAINTEXT__18_0] = c_4[_MPC_PLAINTEXT__18_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _15_0_Y; _15_0_Y = drop_dim_monoreturn(vectorized_access(c_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger count_123(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s1_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__17_0] = s2_3[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__17_0]) | to_share_wrapper(s2_2[_MPC_PLAINTEXT__17_0]));\n        s2_3[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(_4_2[_MPC_PLAINTEXT__17_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__17_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__18_0] = _8_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__18_0] = c_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__18_0] = (c_2[_MPC_PLAINTEXT__18_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__18_0] = _3_2[_MPC_PLAINTEXT__18_0].Mux(c_3[_MPC_PLAINTEXT__18_0].Get(), c_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger count_123(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s1_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__17_0] = s2_3[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__17_0]) | to_share_wrapper(s2_2[_MPC_PLAINTEXT__17_0]));\n        s2_3[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(_4_2[_MPC_PLAINTEXT__17_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__17_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__18_0] = _8_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__18_0] = c_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__18_0] = (c_2[_MPC_PLAINTEXT__18_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__18_0] = _3_2[_MPC_PLAINTEXT__18_0].Mux(c_3[_MPC_PLAINTEXT__18_0].Get(), c_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger count_123(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s1_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__17_0] = s2_3[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__17_0]) | to_share_wrapper(s2_2[_MPC_PLAINTEXT__17_0]));\n        s2_3[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(_4_2[_MPC_PLAINTEXT__17_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__17_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__18_0] = _8_0[_MPC_PLAINTEXT__18_0]; c_2_B[_MPC_PLAINTEXT__18_0] = c_2[_MPC_PLAINTEXT__18_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__18_0] = c_4_Y[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))]; c_2_B[_MPC_PLAINTEXT__18_0] = c_2[_MPC_PLAINTEXT__18_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        c_3[_MPC_PLAINTEXT__18_0] = (c_2[_MPC_PLAINTEXT__18_0] + _MPC_CONSTANT_1_Y); c_3_B[_MPC_PLAINTEXT__18_0] = c_3[_MPC_PLAINTEXT__18_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        c_4[_MPC_PLAINTEXT__18_0] = _3_2[_MPC_PLAINTEXT__18_0].Mux(c_3_B[_MPC_PLAINTEXT__18_0].Get(), c_2_B[_MPC_PLAINTEXT__18_0].Get()); c_4_Y[_MPC_PLAINTEXT__18_0] = c_4[_MPC_PLAINTEXT__18_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _15_0_Y; _15_0_Y = drop_dim_monoreturn(vectorized_access(c_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger count_123(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s1_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__17_0] = s2_3[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__17_0]) | to_share_wrapper(s2_2[_MPC_PLAINTEXT__17_0]));\n        s2_3[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(_4_2[_MPC_PLAINTEXT__17_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__17_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__18_0] = _8_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__18_0] = c_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__18_0] = (c_2[_MPC_PLAINTEXT__18_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__18_0] = _3_2[_MPC_PLAINTEXT__18_0].Mux(c_3[_MPC_PLAINTEXT__18_0].Get(), c_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger count_123(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s1_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__17_0] = s2_3[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__17_0]) | to_share_wrapper(s2_2[_MPC_PLAINTEXT__17_0]));\n        s2_3[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(_4_2[_MPC_PLAINTEXT__17_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__17_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__18_0] = _8_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__18_0] = c_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__18_0] = (c_2[_MPC_PLAINTEXT__18_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__18_0] = _3_2[_MPC_PLAINTEXT__18_0].Mux(c_3[_MPC_PLAINTEXT__18_0].Get(), c_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger count_123(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger c_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> c_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s1_1;\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_c_1;\n    bool _MPC_PLAINTEXT_s1_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s1_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s1_1 = false;\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    c_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_c_1 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s1_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return c_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s1_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s1_2[_MPC_PLAINTEXT__16_0] = _6_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s1_2[_MPC_PLAINTEXT__16_0] = s1_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__17_0] = _7_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__17_0] = s2_3[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__17_0]) | to_share_wrapper(s2_2[_MPC_PLAINTEXT__17_0]));\n        s2_3[_MPC_PLAINTEXT__17_0] = (to_share_wrapper(_4_2[_MPC_PLAINTEXT__17_0]) & to_share_wrapper(_5_2[_MPC_PLAINTEXT__17_0]));\n\n    }\n\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    c_2[_MPC_PLAINTEXT__18_0] = _8_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            c_2[_MPC_PLAINTEXT__18_0] = c_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        c_3[_MPC_PLAINTEXT__18_0] = (c_2[_MPC_PLAINTEXT__18_0] + _MPC_CONSTANT_1);\n        c_4[_MPC_PLAINTEXT__18_0] = _3_2[_MPC_PLAINTEXT__18_0].Mux(c_3[_MPC_PLAINTEXT__18_0].Get(), c_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(c_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sint(_v.sbool(False))\n    s2_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + sint(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "B": "program.options.binary = 32\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sbit(0)\n    s2_1 = sbit(0)\n    c_1 = siv32(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + siv32(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sint(_v.sbool(False))\n    s2_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + sint(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sint(_v.sbool(False))\n    s2_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + sint(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sbit(0)\n    s2_1 = sbit(0)\n    c_1 = siv32(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + siv32(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sint(_v.sbool(False))\n    s2_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + sint(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "B": "program.options.binary = 32\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sbit(0)\n    s2_1 = sbit(0)\n    c_1 = siv32(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + siv32(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sint(_v.sbool(False))\n    s2_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + sint(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sint(_v.sbool(False))\n    s2_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + sint(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sbit(0)\n    s2_1 = sbit(0)\n    c_1 = siv32(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + siv32(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0"
            },
            "time": {
                "A": "program.options.binary = 32\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sint(_v.sbool(False))\n    s2_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + sint(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "B": "program.options.binary = 32\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sbit(0)\n    s2_1 = sbit(0)\n    c_1 = siv32(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + siv32(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sint(_v.sbool(False))\n    s2_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + sint(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sint(_v.sbool(False))\n    s2_1 = sint(_v.sbool(False))\n    c_1 = sint(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + sint(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef count_123(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    c_2 = [None] * (N_0)\n    c_3 = [None] * (N_0)\n    c_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s1_3 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s1_1 = sbit(0)\n    s2_1 = sbit(0)\n    c_1 = siv32(0)\n    _9_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _10_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    _6_0 = _v.lift(lambda indices: s1_1, [N_0])\n    _7_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _8_0 = _v.lift(lambda indices: c_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_10_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s1_3, [N_0], [None], (_v.vectorized_access_simd(_9_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(_6_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s1_2, [N_0], [_16_0], _v.vectorized_access(s1_3, [N_0], [(_16_0 - 1)]))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(_7_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_17_0], OR(_v.vectorized_access_simd(s1_2, [N_0], [_17_0]), _v.vectorized_access_simd(s2_2, [N_0], [_17_0])))\n        _v.vectorized_assign(s2_3, [N_0], [_17_0], _v.vectorized_access_simd(_4_2, [N_0], [_17_0]).bit_and(_v.vectorized_access_simd(_5_2, [N_0], [_17_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_17_0], _v.vectorized_access(s2_3, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_2_2, [N_0], [None], OR(_v.vectorized_access_simd(s2_2, [N_0], [None]), _v.vectorized_access_simd(s1_2, [N_0], [None])))\n    _v.vectorized_assign(_3_2, [N_0], [None], _v.vectorized_access_simd(_1_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_2_2, [N_0], [None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(_8_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(c_3, [N_0], [_18_0], (_v.vectorized_access_simd(c_2, [N_0], [_18_0]) + siv32(1)))\n        _v.iterative_mux(c_4,_3_2,c_3,c_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(c_2, [N_0], [_18_0], _v.vectorized_access(c_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(c_4, [N_0])\n    return _15_0"
            }
        }
    },
    "cryptonets_max_pooling": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> cryptonets_max_pooling(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> vals_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_res_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_res_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger cols_0;\n    encrypto::motion::SecureUnsignedInteger cols_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_5((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_7((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_9((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger rows_0;\n    encrypto::motion::SecureUnsignedInteger rows_res_0;\n\n    // Plaintext variable declarations\n\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> cryptonets_max_pooling(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> vals_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_res_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_res_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger cols_0;\n    encrypto::motion::SecureUnsignedInteger cols_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_5((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_7((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_9((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger rows_0;\n    encrypto::motion::SecureUnsignedInteger rows_res_0;\n\n    // Plaintext variable declarations\n\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> cryptonets_max_pooling(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> vals_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_res_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_res_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger cols_0;\n    encrypto::motion::SecureUnsignedInteger cols_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_5((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_7((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_9((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger rows_0;\n    encrypto::motion::SecureUnsignedInteger rows_res_0;\n\n    // Plaintext variable declarations\n\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n    std::vector<encrypto::motion::SecureUnsignedInteger> vals_0_Y(vals_0.size());\n    vectorized_assign(vals_0_Y, {vals_0.size()}, {true}, {}, (vectorized_access(vals_0, {vals_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _6_0_Y((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    vectorized_assign(_6_0_Y, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0_Y[(((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _7_0_Y((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    vectorized_assign(_7_0_Y, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0_Y[((((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _9_0_Y((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    vectorized_assign(_9_0_Y, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0_Y[((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _11_0_Y((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    vectorized_assign(_11_0_Y, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0_Y[(((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_7_0_Y, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(_6_0_Y, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    std::vector<encrypto::motion::ShareWrapper> _1_3_B((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    vectorized_assign(_1_3_B, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    vectorized_assign(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_1_3_B, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_5_Y((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    vectorized_assign(max_5_Y, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_9_0_Y, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_5_Y, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    std::vector<encrypto::motion::ShareWrapper> _2_3_B((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    vectorized_assign(_2_3_B, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    vectorized_assign(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_2_3_B, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_7_Y((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    vectorized_assign(max_7_Y, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_11_0_Y, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_7_Y, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    std::vector<encrypto::motion::ShareWrapper> _3_3_B((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    vectorized_assign(_3_3_B, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    vectorized_assign(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_3_3_B, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> cryptonets_max_pooling(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> vals_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_res_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_res_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger cols_0;\n    encrypto::motion::SecureUnsignedInteger cols_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_5((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_7((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_9((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger rows_0;\n    encrypto::motion::SecureUnsignedInteger rows_res_0;\n\n    // Plaintext variable declarations\n\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> cryptonets_max_pooling(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> vals_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_res_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_res_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger cols_0;\n    encrypto::motion::SecureUnsignedInteger cols_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_5((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_7((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_9((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger rows_0;\n    encrypto::motion::SecureUnsignedInteger rows_res_0;\n\n    // Plaintext variable declarations\n\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> cryptonets_max_pooling(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> vals_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_res_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_res_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger cols_0;\n    encrypto::motion::SecureUnsignedInteger cols_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_5((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_7((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_9((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger rows_0;\n    encrypto::motion::SecureUnsignedInteger rows_res_0;\n\n    // Plaintext variable declarations\n\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> cryptonets_max_pooling(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> vals_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_res_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_res_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger cols_0;\n    encrypto::motion::SecureUnsignedInteger cols_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_5((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_7((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_9((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger rows_0;\n    encrypto::motion::SecureUnsignedInteger rows_res_0;\n\n    // Plaintext variable declarations\n\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> cryptonets_max_pooling(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> vals_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_res_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_res_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger cols_0;\n    encrypto::motion::SecureUnsignedInteger cols_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_5((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_7((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_9((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger rows_0;\n    encrypto::motion::SecureUnsignedInteger rows_res_0;\n\n    // Plaintext variable declarations\n\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> cryptonets_max_pooling(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> vals_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_0,\n    std::uint32_t _MPC_PLAINTEXT_cols_res_0,\n    std::uint32_t _MPC_PLAINTEXT_rows_res_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger cols_0;\n    encrypto::motion::SecureUnsignedInteger cols_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_5((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_7((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_9((_MPC_PLAINTEXT_rows_res_0) * (_MPC_PLAINTEXT_cols_res_0));\n    encrypto::motion::SecureUnsignedInteger rows_0;\n    encrypto::motion::SecureUnsignedInteger rows_res_0;\n\n    // Plaintext variable declarations\n\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2)))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vals_0[(((((indices[0] * std::uint32_t(2)) + std::uint32_t(1)) * _MPC_PLAINTEXT_cols_0) + (indices[1] * std::uint32_t(2))) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_4_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_7_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(_6_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_2_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_9_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_5, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}) > vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    vectorized_assign(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(_3_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get(), vectorized_access(max_7, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {}, vectorized_access(max_9, {_MPC_PLAINTEXT_rows_res_0, _MPC_PLAINTEXT_cols_res_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3",
                "B": "program.options.binary = 32\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    OUTPUT_res_0 = [elem for elem in sint(OUTPUT_res_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    OUTPUT_res_0 = [elem for elem in sint(OUTPUT_res_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3",
                "B": "program.options.binary = 32\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    OUTPUT_res_0 = [elem for elem in sint(OUTPUT_res_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    OUTPUT_res_0 = [elem for elem in sint(OUTPUT_res_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3"
            },
            "time": {
                "A": "program.options.binary = 32\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3",
                "B": "program.options.binary = 32\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    OUTPUT_res_0 = [elem for elem in sint(OUTPUT_res_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    OUTPUT_res_0 = [elem for elem in sint(OUTPUT_res_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (rows_res_0 * cols_res_0)\n    _11_0 = [None] * (rows_res_0 * cols_res_0)\n    _2_3 = [None] * (rows_res_0 * cols_res_0)\n    _3_3 = [None] * (rows_res_0 * cols_res_0)\n    _4_0 = [None] * (rows_res_0 * cols_res_0)\n    _5_0 = [None] * (rows_res_0 * cols_res_0)\n    _6_0 = [None] * (rows_res_0 * cols_res_0)\n    _7_0 = [None] * (rows_res_0 * cols_res_0)\n    _9_0 = [None] * (rows_res_0 * cols_res_0)\n    OUTPUT_res_3 = [None] * (rows_res_0 * cols_res_0)\n    max_5 = [None] * (rows_res_0 * cols_res_0)\n    max_7 = [None] * (rows_res_0 * cols_res_0)\n    max_9 = [None] * (rows_res_0 * cols_res_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])\n    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])\n    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])\n    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [rows_res_0, cols_res_0], [None, None]), [rows_res_0, cols_res_0])\n    _v.vectorized_assign(_1_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_7_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(_6_0, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_5,_1_3,_7_0,_6_0,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_2_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_9_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_5, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_7,_2_3,_9_0,max_5,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_3_3, [rows_res_0, cols_res_0], [None, None], (_v.vectorized_access_simd(_11_0, [rows_res_0, cols_res_0], [None, None]) > _v.vectorized_access_simd(max_7, [rows_res_0, cols_res_0], [None, None])))\n    _v.iterative_mux(max_9,_3_3,_11_0,max_7,[rows_res_0, cols_res_0],[None, None])\n    _v.vectorized_assign(_5_0, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(max_9, [rows_res_0, cols_res_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [rows_res_0, cols_res_0], [None, None], _v.vectorized_access(_5_0, [rows_res_0, cols_res_0], [None, None]))\n    return OUTPUT_res_3"
            }
        }
    },
    "db_cross_join_trivial": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> db_cross_join_trivial(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_B_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _13_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _14_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger Len_A_0;\n    encrypto::motion::SecureUnsignedInteger Len_B_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_10((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_11((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger v_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_6((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_8((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_v_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_2 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(2)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_0;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[(indices[0] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[(indices[1] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[((indices[0] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[((indices[1] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    v_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_v_4 = std::uint32_t(0);\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_0));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_1));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_2));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}))));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(res_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_update(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})));\n    return res_4;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> db_cross_join_trivial(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_B_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _13_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _14_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger Len_A_0;\n    encrypto::motion::SecureUnsignedInteger Len_B_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_10((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_11((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger v_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_6((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_8((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_v_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_2 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(2)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_0;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[(indices[0] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[(indices[1] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[((indices[0] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[((indices[1] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    v_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_v_4 = std::uint32_t(0);\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_0));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_1));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_2));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}))));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(res_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_update(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})));\n    return res_4;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> db_cross_join_trivial(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_B_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _13_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _14_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger Len_A_0;\n    encrypto::motion::SecureUnsignedInteger Len_B_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_10((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_11((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger v_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_6((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_8((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_v_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_2 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(2)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_0;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[(indices[0] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[(indices[1] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[((indices[0] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[((indices[1] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    v_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_v_4 = std::uint32_t(0);\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_0));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_1));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_2));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}))));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(res_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_update(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})));\n    return res_4;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> db_cross_join_trivial(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_B_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _13_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _14_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger Len_A_0;\n    encrypto::motion::SecureUnsignedInteger Len_B_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_10((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_11((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger v_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_6((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_8((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_v_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_2 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(2)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_0;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[(indices[0] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[(indices[1] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[((indices[0] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[((indices[1] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    v_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_v_4 = std::uint32_t(0);\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_0));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_1));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_2));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}))));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(res_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_update(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})));\n    return res_4;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> db_cross_join_trivial(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_B_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _13_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _14_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger Len_A_0;\n    encrypto::motion::SecureUnsignedInteger Len_B_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_10((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_11((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger v_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_6((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_8((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_v_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_2 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(2)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_0;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[(indices[0] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[(indices[1] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[((indices[0] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[((indices[1] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    v_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_v_4 = std::uint32_t(0);\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_0));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_1));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_2));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}))));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(res_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_update(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})));\n    return res_4;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> db_cross_join_trivial(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_B_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _13_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _14_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger Len_A_0;\n    encrypto::motion::SecureUnsignedInteger Len_B_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_10((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_11((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger v_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_6((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_8((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_v_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_2 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(2)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_0;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[(indices[0] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[(indices[1] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[((indices[0] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[((indices[1] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    v_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_v_4 = std::uint32_t(0);\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_0));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_1));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_2));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}))));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(res_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_update(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})));\n    return res_4;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> db_cross_join_trivial(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_B_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _13_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _14_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger Len_A_0;\n    encrypto::motion::SecureUnsignedInteger Len_B_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_10((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_11((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger v_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_6((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_8((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_v_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_2 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(2)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_0;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[(indices[0] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[(indices[1] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[((indices[0] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[((indices[1] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    v_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_v_4 = std::uint32_t(0);\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_0));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_1));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_2));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}))));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(res_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_update(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})));\n    return res_4;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> db_cross_join_trivial(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_B_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _13_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _14_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger Len_A_0;\n    encrypto::motion::SecureUnsignedInteger Len_B_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_10((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_11((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger v_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_6((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_8((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_v_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_2 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(2)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_0;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[(indices[0] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[(indices[1] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[((indices[0] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[((indices[1] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    v_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_v_4 = std::uint32_t(0);\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_0));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_1));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_2));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}))));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(res_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_update(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})));\n    return res_4;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> db_cross_join_trivial(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_Len_B_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _13_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _14_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger Len_A_0;\n    encrypto::motion::SecureUnsignedInteger Len_B_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_4((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_10((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_11((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    encrypto::motion::SecureUnsignedInteger v_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_6((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n    std::vector<encrypto::motion::SecureUnsignedInteger> v_8((_MPC_PLAINTEXT_Len_A_0) * (_MPC_PLAINTEXT_Len_B_0) * (std::uint32_t(3)));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_v_4;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_2 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(2)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_0;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[(indices[0] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[(indices[1] * std::uint32_t(2))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[((indices[0] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[((indices[1] * std::uint32_t(2)) + std::uint32_t(1))];}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    v_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_v_4 = std::uint32_t(0);\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_0));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_1));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return (to_share_wrapper(encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[2]), 0))) == to_share_wrapper(_MPC_CONSTANT_2));}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, (to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})) == to_share_wrapper(vectorized_access(_9_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}))));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_6_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}));\n    vectorized_assign(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_13_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_8_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_14_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_11_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_6, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_15_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(_12_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), vectorized_access(v_8, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get()));\n    vectorized_assign(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(_1_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Mux(vectorized_access(v_10, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}).Get(), decltype(v_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return v_4;}), {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)})).Get()));\n    vectorized_assign(res_4, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_update(_7_0, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {}, vectorized_access(v_11, {_MPC_PLAINTEXT_Len_A_0, _MPC_PLAINTEXT_Len_B_0, std::uint32_t(3)}, {true, true, true}, {})));\n    return res_4;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = sint(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == sint(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == sint(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == sint(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4",
                "B": "program.options.binary = 32\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = siv32(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == siv32(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == siv32(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == siv32(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = sint(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == sint(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == sint(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == sint(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = sint(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == sint(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == sint(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == sint(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = siv32(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == siv32(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == siv32(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == siv32(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = sint(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == sint(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == sint(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == sint(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4",
                "B": "program.options.binary = 32\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = siv32(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == siv32(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == siv32(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == siv32(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = sint(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == sint(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == sint(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == sint(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = sint(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == sint(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == sint(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == sint(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = siv32(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == siv32(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == siv32(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == siv32(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4"
            },
            "time": {
                "A": "program.options.binary = 32\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = sint(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == sint(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == sint(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == sint(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4",
                "B": "program.options.binary = 32\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = siv32(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == siv32(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == siv32(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == siv32(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = sint(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == sint(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == sint(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == sint(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = sint(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == sint(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == sint(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == sint(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef db_cross_join_trivial(A_0, Len_A_0, B_0, Len_B_0, res_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _11_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _12_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _13_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _14_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _15_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _5_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _6_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _7_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _8_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    _9_0 = [None] * (Len_A_0 * Len_B_0 * 3)\n    res_4 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_10 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_11 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_6 = [None] * (Len_A_0 * Len_B_0 * 3)\n    v_8 = [None] * (Len_A_0 * Len_B_0 * 3)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: res_0, [Len_A_0, Len_B_0, 3])\n    _8_0 = _v.lift(lambda indices: (A_0[(indices[0] * 2)]), [Len_A_0, Len_B_0, 3])\n    _9_0 = _v.lift(lambda indices: (B_0[(indices[1] * 2)]), [Len_A_0, Len_B_0, 3])\n    _11_0 = _v.lift(lambda indices: (A_0[((indices[0] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    _12_0 = _v.lift(lambda indices: (B_0[((indices[1] * 2) + 1)]), [Len_A_0, Len_B_0, 3])\n    v_4 = siv32(0)\n    _13_0 = _v.lift(lambda indices: (indices[2] == siv32(0)), [Len_A_0, Len_B_0, 3])\n    _14_0 = _v.lift(lambda indices: (indices[2] == siv32(1)), [Len_A_0, Len_B_0, 3])\n    _15_0 = _v.lift(lambda indices: (indices[2] == siv32(2)), [Len_A_0, Len_B_0, 3])\n    _6_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_A_0, Len_B_0, 3])\n    _v.vectorized_assign(_1_4, [Len_A_0, Len_B_0, 3], [None, None, None], (_v.vectorized_access_simd(_8_0, [Len_A_0, Len_B_0, 3], [None, None, None]) == _v.vectorized_access_simd(_9_0, [Len_A_0, Len_B_0, 3], [None, None, None])))\n    _7_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [Len_A_0, Len_B_0, 3], [None, None, None]), [Len_A_0, Len_B_0, 3])\n    _v.iterative_mux(v_6,_13_0,_8_0,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_8,_14_0,_11_0,v_6,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_10,_15_0,_12_0,v_8,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.iterative_mux(v_11,_1_4,v_10,v_4,[Len_A_0, Len_B_0, 3],[None, None, None])\n    _v.vectorized_assign(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(v_11, [Len_A_0, Len_B_0, 3], [None, None, None])); _v.vectorized_assign(res_4, [Len_A_0, Len_B_0, 3], [None, None, None], _v.vectorized_access(_7_0, [Len_A_0, Len_B_0, 3], [None, None, None]))\n    return res_4"
            }
        }
    },
    "db_variance": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger db_variance(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger exp_1;\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger res_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger variance_1;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_res_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    len_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(_MPC_PLAINTEXT_len_0), 0);\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return V_0;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    res_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_res_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_1;}), {_MPC_PLAINTEXT_len_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__10_0] = _2_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__10_0] = sum_3[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__10_0] = (sum_2[_MPC_PLAINTEXT__10_0] + _3_0[_MPC_PLAINTEXT__10_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    exp_1 = (_4_0 / len_0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return exp_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}) * vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(V_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    res_2[_MPC_PLAINTEXT__11_0] = _8_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            res_2[_MPC_PLAINTEXT__11_0] = res_3[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        res_3[_MPC_PLAINTEXT__11_0] = (res_2[_MPC_PLAINTEXT__11_0] + V_2[_MPC_PLAINTEXT__11_0]);\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(res_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    variance_1 = (_9_0 / len_0);\n    return variance_1;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger db_variance(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger exp_1;\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger res_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger variance_1;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_res_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    len_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(_MPC_PLAINTEXT_len_0), 0);\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return V_0;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    res_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_res_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_1;}), {_MPC_PLAINTEXT_len_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__10_0] = _2_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__10_0] = sum_3[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__10_0] = (sum_2[_MPC_PLAINTEXT__10_0] + _3_0[_MPC_PLAINTEXT__10_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    exp_1 = (_4_0 / len_0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return exp_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}) * vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(V_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    res_2[_MPC_PLAINTEXT__11_0] = _8_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            res_2[_MPC_PLAINTEXT__11_0] = res_3[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        res_3[_MPC_PLAINTEXT__11_0] = (res_2[_MPC_PLAINTEXT__11_0] + V_2[_MPC_PLAINTEXT__11_0]);\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(res_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    variance_1 = (_9_0 / len_0);\n    return variance_1;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger db_variance(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger exp_1;\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger res_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger variance_1;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_res_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    len_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(_MPC_PLAINTEXT_len_0), 0);\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return V_0;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    res_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_res_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_1;}), {_MPC_PLAINTEXT_len_0}));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2_A((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3_B((_MPC_PLAINTEXT_len_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__10_0] = _2_0[_MPC_PLAINTEXT__10_0]; sum_2_A[_MPC_PLAINTEXT__10_0] = sum_2[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kArithmeticGmw>();\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__10_0] = sum_3_B[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))]; sum_2_A[_MPC_PLAINTEXT__10_0] = sum_2[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kArithmeticGmw>();\n        }\n\n        sum_3[_MPC_PLAINTEXT__10_0] = (sum_2_A[_MPC_PLAINTEXT__10_0] + _3_0[_MPC_PLAINTEXT__10_0]); sum_3_B[_MPC_PLAINTEXT__10_0] = sum_3[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0}); \n    encrypto::motion::SecureUnsignedInteger _4_0_B; _4_0_B = drop_dim_monoreturn(vectorized_access(sum_3_B, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    exp_1 = (_4_0_B / len_0);\n    encrypto::motion::SecureUnsignedInteger exp_1_A;\n    exp_1_A = exp_1.Get().Convert<encrypto::motion::MpcProtocol::kArithmeticGmw>();\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return exp_1_A;}), {_MPC_PLAINTEXT_len_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _7_0_B((_MPC_PLAINTEXT_len_0));\n    vectorized_assign(_7_0_B, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return exp_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}) * vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(V_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_2_A((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_3_B((_MPC_PLAINTEXT_len_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    res_2[_MPC_PLAINTEXT__11_0] = _8_0[_MPC_PLAINTEXT__11_0]; res_2_A[_MPC_PLAINTEXT__11_0] = res_2[_MPC_PLAINTEXT__11_0].Get().Convert<encrypto::motion::MpcProtocol::kArithmeticGmw>();\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            res_2[_MPC_PLAINTEXT__11_0] = res_3_B[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))]; res_2_A[_MPC_PLAINTEXT__11_0] = res_2[_MPC_PLAINTEXT__11_0].Get().Convert<encrypto::motion::MpcProtocol::kArithmeticGmw>();\n        }\n\n        res_3[_MPC_PLAINTEXT__11_0] = (res_2_A[_MPC_PLAINTEXT__11_0] + V_2[_MPC_PLAINTEXT__11_0]); res_3_B[_MPC_PLAINTEXT__11_0] = res_3[_MPC_PLAINTEXT__11_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(res_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0}); \n    encrypto::motion::SecureUnsignedInteger _9_0_B; _9_0_B = drop_dim_monoreturn(vectorized_access(res_3_B, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    variance_1 = (_9_0_B / len_0);\n    return variance_1;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger db_variance(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger exp_1;\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger res_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger variance_1;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_res_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    len_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(_MPC_PLAINTEXT_len_0), 0);\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return V_0;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    res_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_res_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_1;}), {_MPC_PLAINTEXT_len_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__10_0] = _2_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__10_0] = sum_3[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__10_0] = (sum_2[_MPC_PLAINTEXT__10_0] + _3_0[_MPC_PLAINTEXT__10_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    exp_1 = (_4_0 / len_0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return exp_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}) * vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(V_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    res_2[_MPC_PLAINTEXT__11_0] = _8_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            res_2[_MPC_PLAINTEXT__11_0] = res_3[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        res_3[_MPC_PLAINTEXT__11_0] = (res_2[_MPC_PLAINTEXT__11_0] + V_2[_MPC_PLAINTEXT__11_0]);\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(res_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    variance_1 = (_9_0 / len_0);\n    return variance_1;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger db_variance(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger exp_1;\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger res_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger variance_1;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_res_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    len_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(_MPC_PLAINTEXT_len_0), 0);\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return V_0;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    res_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_res_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_1;}), {_MPC_PLAINTEXT_len_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__10_0] = _2_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__10_0] = sum_3[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__10_0] = (sum_2[_MPC_PLAINTEXT__10_0] + _3_0[_MPC_PLAINTEXT__10_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    exp_1 = (_4_0 / len_0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return exp_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}) * vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(V_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    res_2[_MPC_PLAINTEXT__11_0] = _8_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            res_2[_MPC_PLAINTEXT__11_0] = res_3[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        res_3[_MPC_PLAINTEXT__11_0] = (res_2[_MPC_PLAINTEXT__11_0] + V_2[_MPC_PLAINTEXT__11_0]);\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(res_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    variance_1 = (_9_0 / len_0);\n    return variance_1;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger db_variance(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger exp_1;\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger res_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger variance_1;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_res_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    len_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(_MPC_PLAINTEXT_len_0), 0);\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return V_0;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    res_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_res_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_1;}), {_MPC_PLAINTEXT_len_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__10_0] = _2_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__10_0] = sum_3[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__10_0] = (sum_2[_MPC_PLAINTEXT__10_0] + _3_0[_MPC_PLAINTEXT__10_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    encrypto::motion::SecureUnsignedInteger _4_0_B;\n    _4_0_B = _4_0.Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n\n    exp_1 = (_4_0_B / len_0);\n    encrypto::motion::SecureUnsignedInteger exp_1_A;\n    exp_1_A = exp_1.Get().Convert<encrypto::motion::MpcProtocol::kArithmeticGmw>();\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return exp_1_A;}), {_MPC_PLAINTEXT_len_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _7_0_B((_MPC_PLAINTEXT_len_0));\n    vectorized_assign(_7_0_B, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return exp_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}) * vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(V_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    res_2[_MPC_PLAINTEXT__11_0] = _8_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            res_2[_MPC_PLAINTEXT__11_0] = res_3[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        res_3[_MPC_PLAINTEXT__11_0] = (res_2[_MPC_PLAINTEXT__11_0] + V_2[_MPC_PLAINTEXT__11_0]);\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(res_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    encrypto::motion::SecureUnsignedInteger _9_0_B;\n    _9_0_B = _9_0.Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n\n    variance_1 = (_9_0_B / len_0);\n    return variance_1;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger db_variance(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger exp_1;\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger res_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger variance_1;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_res_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    len_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(_MPC_PLAINTEXT_len_0), 0);\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return V_0;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    res_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_res_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_1;}), {_MPC_PLAINTEXT_len_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__10_0] = _2_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__10_0] = sum_3[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__10_0] = (sum_2[_MPC_PLAINTEXT__10_0] + _3_0[_MPC_PLAINTEXT__10_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    exp_1 = (_4_0 / len_0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return exp_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}) * vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(V_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    res_2[_MPC_PLAINTEXT__11_0] = _8_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            res_2[_MPC_PLAINTEXT__11_0] = res_3[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        res_3[_MPC_PLAINTEXT__11_0] = (res_2[_MPC_PLAINTEXT__11_0] + V_2[_MPC_PLAINTEXT__11_0]);\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(res_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    variance_1 = (_9_0 / len_0);\n    return variance_1;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger db_variance(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger exp_1;\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger res_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger variance_1;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_res_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    len_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(_MPC_PLAINTEXT_len_0), 0);\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return V_0;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    res_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_res_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_1;}), {_MPC_PLAINTEXT_len_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__10_0] = _2_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__10_0] = sum_3[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__10_0] = (sum_2[_MPC_PLAINTEXT__10_0] + _3_0[_MPC_PLAINTEXT__10_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    exp_1 = (_4_0 / len_0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return exp_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}) * vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(V_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    res_2[_MPC_PLAINTEXT__11_0] = _8_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            res_2[_MPC_PLAINTEXT__11_0] = res_3[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        res_3[_MPC_PLAINTEXT__11_0] = (res_2[_MPC_PLAINTEXT__11_0] + V_2[_MPC_PLAINTEXT__11_0]);\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(res_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    variance_1 = (_9_0 / len_0);\n    return variance_1;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger db_variance(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> V_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_2((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger exp_1;\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger res_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> res_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_len_0));\n    encrypto::motion::SecureUnsignedInteger variance_1;\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_res_1;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    len_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(_MPC_PLAINTEXT_len_0), 0);\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return V_0;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_len_0}));\n    res_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_res_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return res_1;}), {_MPC_PLAINTEXT_len_0}));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__10_0] = _2_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__10_0] = sum_3[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__10_0] = (sum_2[_MPC_PLAINTEXT__10_0] + _3_0[_MPC_PLAINTEXT__10_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    encrypto::motion::SecureUnsignedInteger _4_0_Y;\n    _4_0_Y = _4_0.Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    exp_1 = (_4_0_Y / len_0);\n    encrypto::motion::SecureUnsignedInteger exp_1_A;\n    exp_1_A = exp_1.Get().Convert<encrypto::motion::MpcProtocol::kArithmeticGmw>();\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return exp_1_A;}), {_MPC_PLAINTEXT_len_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _7_0_Y((_MPC_PLAINTEXT_len_0));\n    vectorized_assign(_7_0_Y, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return exp_1;}), {_MPC_PLAINTEXT_len_0}));\n    vectorized_assign(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}) - vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, (vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {}) * vectorized_access(dist_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n    vectorized_assign(V_2, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_update(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(_1_2, {_MPC_PLAINTEXT_len_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    res_2[_MPC_PLAINTEXT__11_0] = _8_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            res_2[_MPC_PLAINTEXT__11_0] = res_3[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        res_3[_MPC_PLAINTEXT__11_0] = (res_2[_MPC_PLAINTEXT__11_0] + V_2[_MPC_PLAINTEXT__11_0]);\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(res_3, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0});\n    encrypto::motion::SecureUnsignedInteger _9_0_Y;\n    _9_0_Y = _9_0.Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    variance_1 = (_9_0_Y / len_0);\n    return variance_1;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef db_variance(A_0, V_0, len_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (len_0)\n    _2_0 = [None] * (len_0)\n    _3_0 = [None] * (len_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0)\n    _8_0 = [None] * (len_0)\n    V_2 = [None] * (len_0)\n    dist_2 = [None] * (len_0)\n    res_2 = [None] * (len_0)\n    res_3 = [None] * (len_0)\n    sum_2 = [None] * (len_0)\n    sum_3 = [None] * (len_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _3_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    _5_0 = _v.lift(lambda indices: V_0, [len_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    res_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: sum_1, [len_0])\n    _8_0 = _v.lift(lambda indices: res_1, [len_0])\n    for _10_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(_2_0, [len_0], [_10_0]))\n        else:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(sum_3, [len_0], [_10_0], (_v.vectorized_access_simd(sum_2, [len_0], [_10_0]) + _v.vectorized_access_simd(_3_0, [len_0], [_10_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [len_0])\n    exp_1 = _v.div(_4_0, len_0)\n    _7_0 = _v.lift(lambda indices: exp_1, [len_0])\n    _v.vectorized_assign(dist_2, [len_0], [None], (_v.vectorized_access_simd(_6_0, [len_0], [None]) - _v.vectorized_access_simd(_7_0, [len_0], [None])))\n    _v.vectorized_assign(_1_2, [len_0], [None], (_v.vectorized_access_simd(dist_2, [len_0], [None]) * _v.vectorized_access_simd(dist_2, [len_0], [None])))\n    _v.vectorized_assign(_5_0, [len_0], [None], _v.vectorized_access(_1_2, [len_0], [None])); _v.vectorized_assign(V_2, [len_0], [None], _v.vectorized_access(_5_0, [len_0], [None]))\n    for _11_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(_8_0, [len_0], [_11_0]))\n        else:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(res_3, [len_0], [_11_0], (_v.vectorized_access_simd(res_2, [len_0], [_11_0]) + _v.vectorized_access_simd(V_2, [len_0], [_11_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(res_3, [len_0])\n    variance_1 = _v.div(_9_0, len_0)\n    return variance_1",
                "B": "N/A",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef db_variance(A_0, V_0, len_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (len_0)\n    _2_0 = [None] * (len_0)\n    _3_0 = [None] * (len_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0)\n    _8_0 = [None] * (len_0)\n    V_2 = [None] * (len_0)\n    dist_2 = [None] * (len_0)\n    res_2 = [None] * (len_0)\n    res_3 = [None] * (len_0)\n    sum_2 = [None] * (len_0)\n    sum_3 = [None] * (len_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _3_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    _5_0 = _v.lift(lambda indices: V_0, [len_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    res_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: sum_1, [len_0])\n    _8_0 = _v.lift(lambda indices: res_1, [len_0])\n    for _10_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(_2_0, [len_0], [_10_0]))\n        else:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(sum_3, [len_0], [_10_0], (_v.vectorized_access_simd(sum_2, [len_0], [_10_0]) + _v.vectorized_access_simd(_3_0, [len_0], [_10_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [len_0])\n    exp_1 = _v.div(_4_0, len_0)\n    _7_0 = _v.lift(lambda indices: exp_1, [len_0])\n    _v.vectorized_assign(dist_2, [len_0], [None], (_v.vectorized_access_simd(_6_0, [len_0], [None]) - _v.vectorized_access_simd(_7_0, [len_0], [None])))\n    _v.vectorized_assign(_1_2, [len_0], [None], (_v.vectorized_access_simd(dist_2, [len_0], [None]) * _v.vectorized_access_simd(dist_2, [len_0], [None])))\n    _v.vectorized_assign(_5_0, [len_0], [None], _v.vectorized_access(_1_2, [len_0], [None])); _v.vectorized_assign(V_2, [len_0], [None], _v.vectorized_access(_5_0, [len_0], [None]))\n    for _11_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(_8_0, [len_0], [_11_0]))\n        else:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(res_3, [len_0], [_11_0], (_v.vectorized_access_simd(res_2, [len_0], [_11_0]) + _v.vectorized_access_simd(V_2, [len_0], [_11_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(res_3, [len_0])\n    variance_1 = _v.div(_9_0, len_0)\n    return variance_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef db_variance(A_0, V_0, len_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (len_0)\n    _2_0 = [None] * (len_0)\n    _3_0 = [None] * (len_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0)\n    _8_0 = [None] * (len_0)\n    V_2 = [None] * (len_0)\n    dist_2 = [None] * (len_0)\n    res_2 = [None] * (len_0)\n    res_3 = [None] * (len_0)\n    sum_2 = [None] * (len_0)\n    sum_3 = [None] * (len_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _3_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    _5_0 = _v.lift(lambda indices: V_0, [len_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    res_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: sum_1, [len_0])\n    _8_0 = _v.lift(lambda indices: res_1, [len_0])\n    for _10_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(_2_0, [len_0], [_10_0]))\n        else:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(sum_3, [len_0], [_10_0], (_v.vectorized_access_simd(sum_2, [len_0], [_10_0]) + _v.vectorized_access_simd(_3_0, [len_0], [_10_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [len_0])\n    exp_1 = _v.div(_4_0, len_0)\n    _7_0 = _v.lift(lambda indices: exp_1, [len_0])\n    _v.vectorized_assign(dist_2, [len_0], [None], (_v.vectorized_access_simd(_6_0, [len_0], [None]) - _v.vectorized_access_simd(_7_0, [len_0], [None])))\n    _v.vectorized_assign(_1_2, [len_0], [None], (_v.vectorized_access_simd(dist_2, [len_0], [None]) * _v.vectorized_access_simd(dist_2, [len_0], [None])))\n    _v.vectorized_assign(_5_0, [len_0], [None], _v.vectorized_access(_1_2, [len_0], [None])); _v.vectorized_assign(V_2, [len_0], [None], _v.vectorized_access(_5_0, [len_0], [None]))\n    for _11_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(_8_0, [len_0], [_11_0]))\n        else:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(res_3, [len_0], [_11_0], (_v.vectorized_access_simd(res_2, [len_0], [_11_0]) + _v.vectorized_access_simd(V_2, [len_0], [_11_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(res_3, [len_0])\n    variance_1 = _v.div(_9_0, len_0)\n    return variance_1",
                "mixed": "program.options.binary = 32\nprogram.use_edabit(True)\ndef db_variance(A_0, V_0, len_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (len_0)\n    _2_0 = [None] * (len_0)\n    _3_0 = [None] * (len_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0)\n    _8_0 = [None] * (len_0)\n    V_2 = [None] * (len_0)\n    dist_2 = [None] * (len_0)\n    res_2 = [None] * (len_0)\n    res_3 = [None] * (len_0)\n    sum_2 = [None] * (len_0)\n    sum_3 = [None] * (len_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _3_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    _5_0 = _v.lift(lambda indices: V_0, [len_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    res_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: sum_1, [len_0])\n    _8_0 = _v.lift(lambda indices: res_1, [len_0])\n    for _10_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(_2_0, [len_0], [_10_0]))\n        else:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(sum_3, [len_0], [_10_0], (_v.vectorized_access_simd(sum_2, [len_0], [_10_0]) + _v.vectorized_access_simd(_3_0, [len_0], [_10_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [len_0])\n    exp_1 = _v.div(_4_0, len_0)\n    _7_0 = _v.lift(lambda indices: exp_1, [len_0])\n    _v.vectorized_assign(dist_2, [len_0], [None], (_v.vectorized_access_simd(_6_0, [len_0], [None]) - _v.vectorized_access_simd(_7_0, [len_0], [None])))\n    _v.vectorized_assign(_1_2, [len_0], [None], (_v.vectorized_access_simd(dist_2, [len_0], [None]) * _v.vectorized_access_simd(dist_2, [len_0], [None])))\n    _v.vectorized_assign(_5_0, [len_0], [None], _v.vectorized_access(_1_2, [len_0], [None])); _v.vectorized_assign(V_2, [len_0], [None], _v.vectorized_access(_5_0, [len_0], [None]))\n    for _11_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(_8_0, [len_0], [_11_0]))\n        else:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(res_3, [len_0], [_11_0], (_v.vectorized_access_simd(res_2, [len_0], [_11_0]) + _v.vectorized_access_simd(V_2, [len_0], [_11_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(res_3, [len_0])\n    variance_1 = _v.div(_9_0, len_0)\n    return variance_1"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef db_variance(A_0, V_0, len_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (len_0)\n    _2_0 = [None] * (len_0)\n    _3_0 = [None] * (len_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0)\n    _8_0 = [None] * (len_0)\n    V_2 = [None] * (len_0)\n    dist_2 = [None] * (len_0)\n    res_2 = [None] * (len_0)\n    res_3 = [None] * (len_0)\n    sum_2 = [None] * (len_0)\n    sum_3 = [None] * (len_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _3_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    _5_0 = _v.lift(lambda indices: V_0, [len_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    res_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: sum_1, [len_0])\n    _8_0 = _v.lift(lambda indices: res_1, [len_0])\n    for _10_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(_2_0, [len_0], [_10_0]))\n        else:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(sum_3, [len_0], [_10_0], (_v.vectorized_access_simd(sum_2, [len_0], [_10_0]) + _v.vectorized_access_simd(_3_0, [len_0], [_10_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [len_0])\n    exp_1 = _v.div(_4_0, len_0)\n    _7_0 = _v.lift(lambda indices: exp_1, [len_0])\n    _v.vectorized_assign(dist_2, [len_0], [None], (_v.vectorized_access_simd(_6_0, [len_0], [None]) - _v.vectorized_access_simd(_7_0, [len_0], [None])))\n    _v.vectorized_assign(_1_2, [len_0], [None], (_v.vectorized_access_simd(dist_2, [len_0], [None]) * _v.vectorized_access_simd(dist_2, [len_0], [None])))\n    _v.vectorized_assign(_5_0, [len_0], [None], _v.vectorized_access(_1_2, [len_0], [None])); _v.vectorized_assign(V_2, [len_0], [None], _v.vectorized_access(_5_0, [len_0], [None]))\n    for _11_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(_8_0, [len_0], [_11_0]))\n        else:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(res_3, [len_0], [_11_0], (_v.vectorized_access_simd(res_2, [len_0], [_11_0]) + _v.vectorized_access_simd(V_2, [len_0], [_11_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(res_3, [len_0])\n    variance_1 = _v.div(_9_0, len_0)\n    return variance_1",
                "B": "N/A",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef db_variance(A_0, V_0, len_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (len_0)\n    _2_0 = [None] * (len_0)\n    _3_0 = [None] * (len_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0)\n    _8_0 = [None] * (len_0)\n    V_2 = [None] * (len_0)\n    dist_2 = [None] * (len_0)\n    res_2 = [None] * (len_0)\n    res_3 = [None] * (len_0)\n    sum_2 = [None] * (len_0)\n    sum_3 = [None] * (len_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _3_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    _5_0 = _v.lift(lambda indices: V_0, [len_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    res_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: sum_1, [len_0])\n    _8_0 = _v.lift(lambda indices: res_1, [len_0])\n    for _10_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(_2_0, [len_0], [_10_0]))\n        else:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(sum_3, [len_0], [_10_0], (_v.vectorized_access_simd(sum_2, [len_0], [_10_0]) + _v.vectorized_access_simd(_3_0, [len_0], [_10_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [len_0])\n    exp_1 = _v.div(_4_0, len_0)\n    _7_0 = _v.lift(lambda indices: exp_1, [len_0])\n    _v.vectorized_assign(dist_2, [len_0], [None], (_v.vectorized_access_simd(_6_0, [len_0], [None]) - _v.vectorized_access_simd(_7_0, [len_0], [None])))\n    _v.vectorized_assign(_1_2, [len_0], [None], (_v.vectorized_access_simd(dist_2, [len_0], [None]) * _v.vectorized_access_simd(dist_2, [len_0], [None])))\n    _v.vectorized_assign(_5_0, [len_0], [None], _v.vectorized_access(_1_2, [len_0], [None])); _v.vectorized_assign(V_2, [len_0], [None], _v.vectorized_access(_5_0, [len_0], [None]))\n    for _11_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(_8_0, [len_0], [_11_0]))\n        else:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(res_3, [len_0], [_11_0], (_v.vectorized_access_simd(res_2, [len_0], [_11_0]) + _v.vectorized_access_simd(V_2, [len_0], [_11_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(res_3, [len_0])\n    variance_1 = _v.div(_9_0, len_0)\n    return variance_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef db_variance(A_0, V_0, len_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (len_0)\n    _2_0 = [None] * (len_0)\n    _3_0 = [None] * (len_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0)\n    _8_0 = [None] * (len_0)\n    V_2 = [None] * (len_0)\n    dist_2 = [None] * (len_0)\n    res_2 = [None] * (len_0)\n    res_3 = [None] * (len_0)\n    sum_2 = [None] * (len_0)\n    sum_3 = [None] * (len_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _3_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    _5_0 = _v.lift(lambda indices: V_0, [len_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    res_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: sum_1, [len_0])\n    _8_0 = _v.lift(lambda indices: res_1, [len_0])\n    for _10_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(_2_0, [len_0], [_10_0]))\n        else:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(sum_3, [len_0], [_10_0], (_v.vectorized_access_simd(sum_2, [len_0], [_10_0]) + _v.vectorized_access_simd(_3_0, [len_0], [_10_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [len_0])\n    exp_1 = _v.div(_4_0, len_0)\n    _7_0 = _v.lift(lambda indices: exp_1, [len_0])\n    _v.vectorized_assign(dist_2, [len_0], [None], (_v.vectorized_access_simd(_6_0, [len_0], [None]) - _v.vectorized_access_simd(_7_0, [len_0], [None])))\n    _v.vectorized_assign(_1_2, [len_0], [None], (_v.vectorized_access_simd(dist_2, [len_0], [None]) * _v.vectorized_access_simd(dist_2, [len_0], [None])))\n    _v.vectorized_assign(_5_0, [len_0], [None], _v.vectorized_access(_1_2, [len_0], [None])); _v.vectorized_assign(V_2, [len_0], [None], _v.vectorized_access(_5_0, [len_0], [None]))\n    for _11_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(_8_0, [len_0], [_11_0]))\n        else:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(res_3, [len_0], [_11_0], (_v.vectorized_access_simd(res_2, [len_0], [_11_0]) + _v.vectorized_access_simd(V_2, [len_0], [_11_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(res_3, [len_0])\n    variance_1 = _v.div(_9_0, len_0)\n    return variance_1",
                "mixed": "program.options.binary = 32\nprogram.use_edabit(True)\ndef db_variance(A_0, V_0, len_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (len_0)\n    _2_0 = [None] * (len_0)\n    _3_0 = [None] * (len_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0)\n    _8_0 = [None] * (len_0)\n    V_2 = [None] * (len_0)\n    dist_2 = [None] * (len_0)\n    res_2 = [None] * (len_0)\n    res_3 = [None] * (len_0)\n    sum_2 = [None] * (len_0)\n    sum_3 = [None] * (len_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _3_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    _5_0 = _v.lift(lambda indices: V_0, [len_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    res_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: sum_1, [len_0])\n    _8_0 = _v.lift(lambda indices: res_1, [len_0])\n    for _10_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(_2_0, [len_0], [_10_0]))\n        else:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(sum_3, [len_0], [_10_0], (_v.vectorized_access_simd(sum_2, [len_0], [_10_0]) + _v.vectorized_access_simd(_3_0, [len_0], [_10_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [len_0])\n    exp_1 = _v.div(_4_0, len_0)\n    _7_0 = _v.lift(lambda indices: exp_1, [len_0])\n    _v.vectorized_assign(dist_2, [len_0], [None], (_v.vectorized_access_simd(_6_0, [len_0], [None]) - _v.vectorized_access_simd(_7_0, [len_0], [None])))\n    _v.vectorized_assign(_1_2, [len_0], [None], (_v.vectorized_access_simd(dist_2, [len_0], [None]) * _v.vectorized_access_simd(dist_2, [len_0], [None])))\n    _v.vectorized_assign(_5_0, [len_0], [None], _v.vectorized_access(_1_2, [len_0], [None])); _v.vectorized_assign(V_2, [len_0], [None], _v.vectorized_access(_5_0, [len_0], [None]))\n    for _11_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(_8_0, [len_0], [_11_0]))\n        else:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(res_3, [len_0], [_11_0], (_v.vectorized_access_simd(res_2, [len_0], [_11_0]) + _v.vectorized_access_simd(V_2, [len_0], [_11_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(res_3, [len_0])\n    variance_1 = _v.div(_9_0, len_0)\n    return variance_1"
            },
            "time": {
                "A": "program.options.binary = 32\ndef db_variance(A_0, V_0, len_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (len_0)\n    _2_0 = [None] * (len_0)\n    _3_0 = [None] * (len_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0)\n    _8_0 = [None] * (len_0)\n    V_2 = [None] * (len_0)\n    dist_2 = [None] * (len_0)\n    res_2 = [None] * (len_0)\n    res_3 = [None] * (len_0)\n    sum_2 = [None] * (len_0)\n    sum_3 = [None] * (len_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _3_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    _5_0 = _v.lift(lambda indices: V_0, [len_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    res_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: sum_1, [len_0])\n    _8_0 = _v.lift(lambda indices: res_1, [len_0])\n    for _10_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(_2_0, [len_0], [_10_0]))\n        else:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(sum_3, [len_0], [_10_0], (_v.vectorized_access_simd(sum_2, [len_0], [_10_0]) + _v.vectorized_access_simd(_3_0, [len_0], [_10_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [len_0])\n    exp_1 = _v.div(_4_0, len_0)\n    _7_0 = _v.lift(lambda indices: exp_1, [len_0])\n    _v.vectorized_assign(dist_2, [len_0], [None], (_v.vectorized_access_simd(_6_0, [len_0], [None]) - _v.vectorized_access_simd(_7_0, [len_0], [None])))\n    _v.vectorized_assign(_1_2, [len_0], [None], (_v.vectorized_access_simd(dist_2, [len_0], [None]) * _v.vectorized_access_simd(dist_2, [len_0], [None])))\n    _v.vectorized_assign(_5_0, [len_0], [None], _v.vectorized_access(_1_2, [len_0], [None])); _v.vectorized_assign(V_2, [len_0], [None], _v.vectorized_access(_5_0, [len_0], [None]))\n    for _11_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(_8_0, [len_0], [_11_0]))\n        else:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(res_3, [len_0], [_11_0], (_v.vectorized_access_simd(res_2, [len_0], [_11_0]) + _v.vectorized_access_simd(V_2, [len_0], [_11_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(res_3, [len_0])\n    variance_1 = _v.div(_9_0, len_0)\n    return variance_1",
                "B": "N/A",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef db_variance(A_0, V_0, len_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (len_0)\n    _2_0 = [None] * (len_0)\n    _3_0 = [None] * (len_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0)\n    _8_0 = [None] * (len_0)\n    V_2 = [None] * (len_0)\n    dist_2 = [None] * (len_0)\n    res_2 = [None] * (len_0)\n    res_3 = [None] * (len_0)\n    sum_2 = [None] * (len_0)\n    sum_3 = [None] * (len_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _3_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    _5_0 = _v.lift(lambda indices: V_0, [len_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    res_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: sum_1, [len_0])\n    _8_0 = _v.lift(lambda indices: res_1, [len_0])\n    for _10_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(_2_0, [len_0], [_10_0]))\n        else:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(sum_3, [len_0], [_10_0], (_v.vectorized_access_simd(sum_2, [len_0], [_10_0]) + _v.vectorized_access_simd(_3_0, [len_0], [_10_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [len_0])\n    exp_1 = _v.div(_4_0, len_0)\n    _7_0 = _v.lift(lambda indices: exp_1, [len_0])\n    _v.vectorized_assign(dist_2, [len_0], [None], (_v.vectorized_access_simd(_6_0, [len_0], [None]) - _v.vectorized_access_simd(_7_0, [len_0], [None])))\n    _v.vectorized_assign(_1_2, [len_0], [None], (_v.vectorized_access_simd(dist_2, [len_0], [None]) * _v.vectorized_access_simd(dist_2, [len_0], [None])))\n    _v.vectorized_assign(_5_0, [len_0], [None], _v.vectorized_access(_1_2, [len_0], [None])); _v.vectorized_assign(V_2, [len_0], [None], _v.vectorized_access(_5_0, [len_0], [None]))\n    for _11_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(_8_0, [len_0], [_11_0]))\n        else:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(res_3, [len_0], [_11_0], (_v.vectorized_access_simd(res_2, [len_0], [_11_0]) + _v.vectorized_access_simd(V_2, [len_0], [_11_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(res_3, [len_0])\n    variance_1 = _v.div(_9_0, len_0)\n    return variance_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef db_variance(A_0, V_0, len_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (len_0)\n    _2_0 = [None] * (len_0)\n    _3_0 = [None] * (len_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0)\n    _8_0 = [None] * (len_0)\n    V_2 = [None] * (len_0)\n    dist_2 = [None] * (len_0)\n    res_2 = [None] * (len_0)\n    res_3 = [None] * (len_0)\n    sum_2 = [None] * (len_0)\n    sum_3 = [None] * (len_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _3_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    _5_0 = _v.lift(lambda indices: V_0, [len_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    res_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: sum_1, [len_0])\n    _8_0 = _v.lift(lambda indices: res_1, [len_0])\n    for _10_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(_2_0, [len_0], [_10_0]))\n        else:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(sum_3, [len_0], [_10_0], (_v.vectorized_access_simd(sum_2, [len_0], [_10_0]) + _v.vectorized_access_simd(_3_0, [len_0], [_10_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [len_0])\n    exp_1 = _v.div(_4_0, len_0)\n    _7_0 = _v.lift(lambda indices: exp_1, [len_0])\n    _v.vectorized_assign(dist_2, [len_0], [None], (_v.vectorized_access_simd(_6_0, [len_0], [None]) - _v.vectorized_access_simd(_7_0, [len_0], [None])))\n    _v.vectorized_assign(_1_2, [len_0], [None], (_v.vectorized_access_simd(dist_2, [len_0], [None]) * _v.vectorized_access_simd(dist_2, [len_0], [None])))\n    _v.vectorized_assign(_5_0, [len_0], [None], _v.vectorized_access(_1_2, [len_0], [None])); _v.vectorized_assign(V_2, [len_0], [None], _v.vectorized_access(_5_0, [len_0], [None]))\n    for _11_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(_8_0, [len_0], [_11_0]))\n        else:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(res_3, [len_0], [_11_0], (_v.vectorized_access_simd(res_2, [len_0], [_11_0]) + _v.vectorized_access_simd(V_2, [len_0], [_11_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(res_3, [len_0])\n    variance_1 = _v.div(_9_0, len_0)\n    return variance_1",
                "mixed": "program.options.binary = 32\nprogram.use_edabit(True)\ndef db_variance(A_0, V_0, len_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (len_0)\n    _2_0 = [None] * (len_0)\n    _3_0 = [None] * (len_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0)\n    _8_0 = [None] * (len_0)\n    V_2 = [None] * (len_0)\n    dist_2 = [None] * (len_0)\n    res_2 = [None] * (len_0)\n    res_3 = [None] * (len_0)\n    sum_2 = [None] * (len_0)\n    sum_3 = [None] * (len_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _3_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    _5_0 = _v.lift(lambda indices: V_0, [len_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [len_0])\n    res_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: sum_1, [len_0])\n    _8_0 = _v.lift(lambda indices: res_1, [len_0])\n    for _10_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(_2_0, [len_0], [_10_0]))\n        else:\n            _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(sum_3, [len_0], [_10_0], (_v.vectorized_access_simd(sum_2, [len_0], [_10_0]) + _v.vectorized_access_simd(_3_0, [len_0], [_10_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [len_0], [_10_0], _v.vectorized_access(sum_3, [len_0], [(_10_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [len_0])\n    exp_1 = _v.div(_4_0, len_0)\n    _7_0 = _v.lift(lambda indices: exp_1, [len_0])\n    _v.vectorized_assign(dist_2, [len_0], [None], (_v.vectorized_access_simd(_6_0, [len_0], [None]) - _v.vectorized_access_simd(_7_0, [len_0], [None])))\n    _v.vectorized_assign(_1_2, [len_0], [None], (_v.vectorized_access_simd(dist_2, [len_0], [None]) * _v.vectorized_access_simd(dist_2, [len_0], [None])))\n    _v.vectorized_assign(_5_0, [len_0], [None], _v.vectorized_access(_1_2, [len_0], [None])); _v.vectorized_assign(V_2, [len_0], [None], _v.vectorized_access(_5_0, [len_0], [None]))\n    for _11_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(_8_0, [len_0], [_11_0]))\n        else:\n            _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(res_3, [len_0], [_11_0], (_v.vectorized_access_simd(res_2, [len_0], [_11_0]) + _v.vectorized_access_simd(V_2, [len_0], [_11_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(res_2, [len_0], [_11_0], _v.vectorized_access(res_3, [len_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(res_3, [len_0])\n    variance_1 = _v.div(_9_0, len_0)\n    return variance_1"
            }
        }
    },
    "histogram": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> histogram(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::uint32_t _MPC_PLAINTEXT_num_bins_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger num_bins_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_0.begin(), _MPC_PLAINTEXT_result_0.end(), std::back_inserter(result_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_num_bins_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}) + vectorized_access(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(vectorized_access(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get(), vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n        vectorized_assign(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_update(vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}), {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n\n    }\n\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, drop_dim(vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    return _3_0;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> histogram(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::uint32_t _MPC_PLAINTEXT_num_bins_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger num_bins_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_0.begin(), _MPC_PLAINTEXT_result_0.end(), std::back_inserter(result_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_num_bins_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}) + vectorized_access(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(vectorized_access(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get(), vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n        vectorized_assign(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_update(vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}), {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n\n    }\n\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, drop_dim(vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    return _3_0;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> histogram(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::uint32_t _MPC_PLAINTEXT_num_bins_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger num_bins_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_0.begin(), _MPC_PLAINTEXT_result_0.end(), std::back_inserter(result_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_num_bins_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2_B((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_3_B((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_3_Y((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    vectorized_assign(result_2_B, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(result_3_Y, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n                    vectorized_assign(result_2_B, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n        }\n\n        vectorized_assign(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}) + vectorized_access(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n            vectorized_assign(val_3_B, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(vectorized_access(val_3_B, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get(), vectorized_access(result_2_B, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n        vectorized_assign(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_update(vectorized_access(result_2_B, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}), {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n            vectorized_assign(result_3_Y, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n\n    }\n\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, drop_dim(vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    return _3_0;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> histogram(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::uint32_t _MPC_PLAINTEXT_num_bins_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger num_bins_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_0.begin(), _MPC_PLAINTEXT_result_0.end(), std::back_inserter(result_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_num_bins_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}) + vectorized_access(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(vectorized_access(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get(), vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n        vectorized_assign(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_update(vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}), {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n\n    }\n\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, drop_dim(vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    return _3_0;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> histogram(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::uint32_t _MPC_PLAINTEXT_num_bins_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger num_bins_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_0.begin(), _MPC_PLAINTEXT_result_0.end(), std::back_inserter(result_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_num_bins_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}) + vectorized_access(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(vectorized_access(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get(), vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n        vectorized_assign(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_update(vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}), {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n\n    }\n\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, drop_dim(vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    return _3_0;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> histogram(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::uint32_t _MPC_PLAINTEXT_num_bins_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger num_bins_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_0.begin(), _MPC_PLAINTEXT_result_0.end(), std::back_inserter(result_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_num_bins_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}) + vectorized_access(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(vectorized_access(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get(), vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n        vectorized_assign(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_update(vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}), {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n\n    }\n\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, drop_dim(vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    return _3_0;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> histogram(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::uint32_t _MPC_PLAINTEXT_num_bins_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger num_bins_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_0.begin(), _MPC_PLAINTEXT_result_0.end(), std::back_inserter(result_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_num_bins_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}) + vectorized_access(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(vectorized_access(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get(), vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n        vectorized_assign(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_update(vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}), {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n\n    }\n\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, drop_dim(vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    return _3_0;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> histogram(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::uint32_t _MPC_PLAINTEXT_num_bins_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger num_bins_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_0.begin(), _MPC_PLAINTEXT_result_0.end(), std::back_inserter(result_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_num_bins_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}) + vectorized_access(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(vectorized_access(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get(), vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n        vectorized_assign(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_update(vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}), {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n\n    }\n\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, drop_dim(vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    return _3_0;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> histogram(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::uint32_t _MPC_PLAINTEXT_num_bins_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_num_bins_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger num_bins_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_3((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_num_bins_0) * (_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n\n    // Constant initializations\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    result_0.clear();\n    std::transform(_MPC_PLAINTEXT_result_0.begin(), _MPC_PLAINTEXT_result_0.end(), std::back_inserter(result_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_num_bins_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_4_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, (vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}) + vectorized_access(_7_0, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(vectorized_access(val_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get(), vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n        vectorized_assign(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_update(vectorized_access(result_2, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0}), {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__8_0})));\n\n    }\n\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_num_bins_0}, {true}, {}, drop_dim(vectorized_access(result_3, {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_bins_0, _MPC_PLAINTEXT_N_0}));\n    return _3_0;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0",
                "B": "program.options.binary = 32\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    result_0 = [elem for elem in sint(result_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    result_0 = [elem for elem in sint(result_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0",
                "B": "program.options.binary = 32\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    result_0 = [elem for elem in sint(result_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    result_0 = [elem for elem in sint(result_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0"
            },
            "time": {
                "A": "program.options.binary = 32\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0",
                "B": "program.options.binary = 32\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    result_0 = [elem for elem in sint(result_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef histogram(A_0, B_0, N_0, num_bins_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    result_0 = [elem for elem in sint(result_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (num_bins_0 * N_0)\n    _2_0 = [None] * (num_bins_0)\n    _3_0 = [None] * (num_bins_0)\n    _4_0 = [None] * (num_bins_0 * N_0)\n    _5_0 = [None] * (num_bins_0 * N_0)\n    _6_0 = [None] * (num_bins_0 * N_0)\n    _7_0 = [None] * (num_bins_0 * N_0)\n    result_2 = [None] * (num_bins_0 * N_0)\n    result_3 = [None] * (num_bins_0 * N_0)\n    val_3 = [None] * (num_bins_0 * N_0)\n    val_5 = [None] * (num_bins_0 * N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [num_bins_0])\n    _5_0 = _v.lift(lambda indices: (A_0[indices[1]]), [num_bins_0, N_0])\n    _6_0 = _v.lift(lambda indices: indices[0], [num_bins_0, N_0])\n    _7_0 = _v.lift(lambda indices: (B_0[indices[1]]), [num_bins_0, N_0])\n    _4_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [num_bins_0], [None]), [num_bins_0, N_0])\n    _v.vectorized_assign(_1_3, [num_bins_0, N_0], [None, None], (_v.vectorized_access_simd(_5_0, [num_bins_0, N_0], [None, None]) == _v.vectorized_access_simd(_6_0, [num_bins_0, N_0], [None, None])))\n    for _8_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(_4_0, [num_bins_0, N_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n        _v.vectorized_assign(val_3, [num_bins_0, N_0], [None, _8_0], (_v.vectorized_access_simd(result_2, [num_bins_0, N_0], [None, _8_0]) + _v.vectorized_access_simd(_7_0, [num_bins_0, N_0], [None, _8_0])))\n        _v.iterative_mux(val_5,_1_3,val_3,result_2,[num_bins_0, N_0],[None, _8_0])\n        _v.vectorized_assign((TODO: fix this case), [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(val_5, [num_bins_0, N_0], [None, _8_0])); _v.vectorized_assign(result_3, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access((TODO: fix this case), [num_bins_0, N_0], [None, _8_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(result_2, [num_bins_0, N_0], [None, _8_0], _v.vectorized_access(result_3, [num_bins_0, N_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_3_0, [num_bins_0], [None], _v.drop_dim(result_3, [num_bins_0, N_0]))\n    return _3_0"
            }
        }
    },
    "inner_product": {
        "MOTION": {
            "commRounds": {
                "A": "encrypto::motion::SecureUnsignedInteger inner_product(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    encrypto::motion::SecureUnsignedInteger _5_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> temp_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__5_0;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(temp_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) * vectorized_access(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__5_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__5_0] = _1_0[_MPC_PLAINTEXT__5_0];\n    for (; _MPC_PLAINTEXT__5_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__5_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__5_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__5_0] = sum_3[(_MPC_PLAINTEXT__5_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__5_0] = (sum_2[_MPC_PLAINTEXT__5_0] + temp_2[_MPC_PLAINTEXT__5_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _4_0;\n\n}",
                "B": "encrypto::motion::SecureUnsignedInteger inner_product(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    encrypto::motion::SecureUnsignedInteger _5_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> temp_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__5_0;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(temp_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) * vectorized_access(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__5_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__5_0] = _1_0[_MPC_PLAINTEXT__5_0];\n    for (; _MPC_PLAINTEXT__5_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__5_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__5_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__5_0] = sum_3[(_MPC_PLAINTEXT__5_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__5_0] = (sum_2[_MPC_PLAINTEXT__5_0] + temp_2[_MPC_PLAINTEXT__5_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _4_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger inner_product(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    encrypto::motion::SecureUnsignedInteger _5_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> temp_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__5_0;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(temp_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) * vectorized_access(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__5_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__5_0] = _1_0[_MPC_PLAINTEXT__5_0];\n    for (; _MPC_PLAINTEXT__5_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__5_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__5_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__5_0] = sum_3[(_MPC_PLAINTEXT__5_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__5_0] = (sum_2[_MPC_PLAINTEXT__5_0] + temp_2[_MPC_PLAINTEXT__5_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _4_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger inner_product(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    encrypto::motion::SecureUnsignedInteger _5_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> temp_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__5_0;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(temp_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) * vectorized_access(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__5_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__5_0] = _1_0[_MPC_PLAINTEXT__5_0];\n    for (; _MPC_PLAINTEXT__5_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__5_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__5_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__5_0] = sum_3[(_MPC_PLAINTEXT__5_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__5_0] = (sum_2[_MPC_PLAINTEXT__5_0] + temp_2[_MPC_PLAINTEXT__5_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _4_0;\n\n}"
            },
            "dataSent": {
                "A": "encrypto::motion::SecureUnsignedInteger inner_product(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    encrypto::motion::SecureUnsignedInteger _5_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> temp_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__5_0;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(temp_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) * vectorized_access(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__5_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__5_0] = _1_0[_MPC_PLAINTEXT__5_0];\n    for (; _MPC_PLAINTEXT__5_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__5_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__5_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__5_0] = sum_3[(_MPC_PLAINTEXT__5_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__5_0] = (sum_2[_MPC_PLAINTEXT__5_0] + temp_2[_MPC_PLAINTEXT__5_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _4_0;\n\n}",
                "B": "encrypto::motion::SecureUnsignedInteger inner_product(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    encrypto::motion::SecureUnsignedInteger _5_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> temp_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__5_0;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(temp_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) * vectorized_access(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__5_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__5_0] = _1_0[_MPC_PLAINTEXT__5_0];\n    for (; _MPC_PLAINTEXT__5_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__5_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__5_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__5_0] = sum_3[(_MPC_PLAINTEXT__5_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__5_0] = (sum_2[_MPC_PLAINTEXT__5_0] + temp_2[_MPC_PLAINTEXT__5_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _4_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger inner_product(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    encrypto::motion::SecureUnsignedInteger _5_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> temp_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__5_0;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(temp_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) * vectorized_access(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__5_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__5_0] = _1_0[_MPC_PLAINTEXT__5_0];\n    for (; _MPC_PLAINTEXT__5_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__5_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__5_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__5_0] = sum_3[(_MPC_PLAINTEXT__5_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__5_0] = (sum_2[_MPC_PLAINTEXT__5_0] + temp_2[_MPC_PLAINTEXT__5_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _4_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger inner_product(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    encrypto::motion::SecureUnsignedInteger _5_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> temp_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__5_0;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(temp_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) * vectorized_access(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__5_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__5_0] = _1_0[_MPC_PLAINTEXT__5_0];\n    for (; _MPC_PLAINTEXT__5_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__5_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__5_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__5_0] = sum_3[(_MPC_PLAINTEXT__5_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__5_0] = (sum_2[_MPC_PLAINTEXT__5_0] + temp_2[_MPC_PLAINTEXT__5_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _4_0;\n\n}"
            },
            "time": {
                "A": "encrypto::motion::SecureUnsignedInteger inner_product(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    encrypto::motion::SecureUnsignedInteger _5_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> temp_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__5_0;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(temp_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) * vectorized_access(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__5_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__5_0] = _1_0[_MPC_PLAINTEXT__5_0];\n    for (; _MPC_PLAINTEXT__5_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__5_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__5_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__5_0] = sum_3[(_MPC_PLAINTEXT__5_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__5_0] = (sum_2[_MPC_PLAINTEXT__5_0] + temp_2[_MPC_PLAINTEXT__5_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _4_0;\n\n}",
                "B": "encrypto::motion::SecureUnsignedInteger inner_product(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    encrypto::motion::SecureUnsignedInteger _5_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> temp_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__5_0;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(temp_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) * vectorized_access(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__5_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__5_0] = _1_0[_MPC_PLAINTEXT__5_0];\n    for (; _MPC_PLAINTEXT__5_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__5_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__5_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__5_0] = sum_3[(_MPC_PLAINTEXT__5_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__5_0] = (sum_2[_MPC_PLAINTEXT__5_0] + temp_2[_MPC_PLAINTEXT__5_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _4_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger inner_product(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    encrypto::motion::SecureUnsignedInteger _5_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> temp_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__5_0;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(temp_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) * vectorized_access(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__5_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__5_0] = _1_0[_MPC_PLAINTEXT__5_0];\n    for (; _MPC_PLAINTEXT__5_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__5_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__5_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__5_0] = sum_3[(_MPC_PLAINTEXT__5_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__5_0] = (sum_2[_MPC_PLAINTEXT__5_0] + temp_2[_MPC_PLAINTEXT__5_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _4_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger inner_product(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::SecureUnsignedInteger> _1_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _4_0;\n    encrypto::motion::SecureUnsignedInteger _5_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> sum_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> temp_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__5_0;\n    std::uint32_t _MPC_PLAINTEXT_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kArithmeticGmw>(std::uint32_t(0), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_sum_1 = std::uint32_t(0);\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(temp_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (vectorized_access(_2_0, {_MPC_PLAINTEXT_N_0}, {true}, {}) * vectorized_access(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__5_0 = std::uint32_t(0);\n    // Initialize phi values\n    sum_2[_MPC_PLAINTEXT__5_0] = _1_0[_MPC_PLAINTEXT__5_0];\n    for (; _MPC_PLAINTEXT__5_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__5_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__5_0 != std::uint32_t(0)) {\n            sum_2[_MPC_PLAINTEXT__5_0] = sum_3[(_MPC_PLAINTEXT__5_0 - std::uint32_t(1))];\n        }\n\n        sum_3[_MPC_PLAINTEXT__5_0] = (sum_2[_MPC_PLAINTEXT__5_0] + temp_2[_MPC_PLAINTEXT__5_0]);\n\n    }\n\n    _4_0 = drop_dim_monoreturn(vectorized_access(sum_3, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _4_0;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0",
                "B": "program.options.binary = 32\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = siv32(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0",
                "mixed": "program.options.binary = 32\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0",
                "B": "program.options.binary = 32\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = siv32(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0",
                "mixed": "program.options.binary = 32\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0"
            },
            "time": {
                "A": "program.options.binary = 32\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0",
                "B": "program.options.binary = 32\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = siv32(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef inner_product(A_0, B_0, N_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_0 = [None] * (N_0)\n    _2_0 = [None] * (N_0)\n    _3_0 = [None] * (N_0)\n    sum_2 = [None] * (N_0)\n    sum_3 = [None] * (N_0)\n    temp_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    sum_1 = sint(0)\n    _2_0 = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])\n    _3_0 = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])\n    _1_0 = _v.lift(lambda indices: sum_1, [N_0])\n    _v.vectorized_assign(temp_2, [N_0], [None], (_v.vectorized_access_simd(_2_0, [N_0], [None]) * _v.vectorized_access_simd(_3_0, [N_0], [None])))\n    for _5_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _5_0 == 0:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(_1_0, [N_0], [_5_0]))\n        else:\n            _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n        _v.vectorized_assign(sum_3, [N_0], [_5_0], (_v.vectorized_access_simd(sum_2, [N_0], [_5_0]) + _v.vectorized_access_simd(temp_2, [N_0], [_5_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(sum_2, [N_0], [_5_0], _v.vectorized_access(sum_3, [N_0], [(_5_0 - 1)]))\n    _4_0 = _v.drop_dim(sum_3, [N_0])\n    return _4_0"
            }
        }
    },
    "kmeans_iteration": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> kmeans_iteration(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0,\n    std::uint32_t _MPC_PLAINTEXT_num_cluster_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_bestMap_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _20_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _21_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _22_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _23_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _25_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _29_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger _30_0;\n    encrypto::motion::SecureUnsignedInteger _31_0;\n    encrypto::motion::SecureUnsignedInteger _32_0;\n    encrypto::motion::SecureUnsignedInteger _33_0;\n    encrypto::motion::SecureUnsignedInteger _34_0;\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _4_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_2((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger best_dist_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger count_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger num_cluster_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_x_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_7((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_y_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_7((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__30_0;\n    std::uint32_t _MPC_PLAINTEXT__31_0;\n    std::uint32_t _MPC_PLAINTEXT__32_0;\n    std::uint32_t _MPC_PLAINTEXT__33_0;\n    std::uint32_t _MPC_PLAINTEXT__34_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__4_1;\n    std::uint32_t _MPC_PLAINTEXT_best_dist_2;\n    std::uint32_t _MPC_PLAINTEXT_count_2;\n    std::uint32_t _MPC_PLAINTEXT_val_x_2;\n    std::uint32_t _MPC_PLAINTEXT_val_y_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    bestMap_0.clear();\n    std::transform(_MPC_PLAINTEXT_bestMap_0.begin(), _MPC_PLAINTEXT_bestMap_0.end(), std::back_inserter(bestMap_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bestMap_0;}), {_MPC_PLAINTEXT_len_0}));\n    best_dist_2 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_best_dist_2 = std::uint32_t(10000);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_x_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_y_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[1]), 0));}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_x_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_y_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    val_x_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_x_2 = std::uint32_t(0);\n    val_y_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_y_2 = std::uint32_t(0);\n    count_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_count_2 = std::uint32_t(0);\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return best_dist_2;}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_x_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_y_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return count_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) + vectorized_access(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__30_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}));\n    for (; _MPC_PLAINTEXT__30_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__30_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__30_0 != std::uint32_t(0)) {\n            vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__30_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}) > vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0})));\n        vectorized_assign(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Mux(vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get(), vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__31_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}));\n    for (; _MPC_PLAINTEXT__31_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__31_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__31_0 != std::uint32_t(0)) {\n            vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__31_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Mux(vectorized_access(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get(), vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get()));\n        vectorized_assign(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_update(vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}), {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0})));\n\n    }\n\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, drop_dim(vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return _6_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__32_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}));\n    for (; _MPC_PLAINTEXT__32_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__32_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__32_0 != std::uint32_t(0)) {\n            vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__32_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}) + vectorized_access(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0})));\n        vectorized_assign(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Mux(vectorized_access(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get(), vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__33_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}));\n    for (; _MPC_PLAINTEXT__33_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__33_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__33_0 != std::uint32_t(0)) {\n            vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__33_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}) + vectorized_access(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0})));\n        vectorized_assign(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Mux(vectorized_access(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get(), vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__34_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}));\n    for (; _MPC_PLAINTEXT__34_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__34_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__34_0 != std::uint32_t(0)) {\n            vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__34_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}) + decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n        vectorized_assign(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Mux(vectorized_access(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get(), vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get()));\n\n    }\n\n    vectorized_assign(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n    vectorized_assign(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(OUTPUT_cluster_x_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(OUTPUT_cluster_y_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    _4_1 = std::make_tuple(OUTPUT_cluster_x_2, OUTPUT_cluster_y_2);\n    return _4_1;\n\n}",
                "Y": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> kmeans_iteration(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0,\n    std::uint32_t _MPC_PLAINTEXT_num_cluster_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_bestMap_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _20_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _21_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _22_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _23_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _25_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _29_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger _30_0;\n    encrypto::motion::SecureUnsignedInteger _31_0;\n    encrypto::motion::SecureUnsignedInteger _32_0;\n    encrypto::motion::SecureUnsignedInteger _33_0;\n    encrypto::motion::SecureUnsignedInteger _34_0;\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _4_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_2((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger best_dist_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger count_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger num_cluster_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_x_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_7((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_y_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_7((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__30_0;\n    std::uint32_t _MPC_PLAINTEXT__31_0;\n    std::uint32_t _MPC_PLAINTEXT__32_0;\n    std::uint32_t _MPC_PLAINTEXT__33_0;\n    std::uint32_t _MPC_PLAINTEXT__34_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__4_1;\n    std::uint32_t _MPC_PLAINTEXT_best_dist_2;\n    std::uint32_t _MPC_PLAINTEXT_count_2;\n    std::uint32_t _MPC_PLAINTEXT_val_x_2;\n    std::uint32_t _MPC_PLAINTEXT_val_y_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    bestMap_0.clear();\n    std::transform(_MPC_PLAINTEXT_bestMap_0.begin(), _MPC_PLAINTEXT_bestMap_0.end(), std::back_inserter(bestMap_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bestMap_0;}), {_MPC_PLAINTEXT_len_0}));\n    best_dist_2 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_best_dist_2 = std::uint32_t(10000);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_x_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_y_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[1]), 0));}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_x_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_y_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    val_x_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_x_2 = std::uint32_t(0);\n    val_y_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_y_2 = std::uint32_t(0);\n    count_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_count_2 = std::uint32_t(0);\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return best_dist_2;}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_x_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_y_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return count_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) + vectorized_access(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__30_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}));\n    for (; _MPC_PLAINTEXT__30_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__30_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__30_0 != std::uint32_t(0)) {\n            vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__30_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}) > vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0})));\n        vectorized_assign(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Mux(vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get(), vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__31_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}));\n    for (; _MPC_PLAINTEXT__31_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__31_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__31_0 != std::uint32_t(0)) {\n            vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__31_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Mux(vectorized_access(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get(), vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get()));\n        vectorized_assign(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_update(vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}), {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0})));\n\n    }\n\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, drop_dim(vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return _6_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__32_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}));\n    for (; _MPC_PLAINTEXT__32_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__32_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__32_0 != std::uint32_t(0)) {\n            vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__32_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}) + vectorized_access(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0})));\n        vectorized_assign(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Mux(vectorized_access(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get(), vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__33_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}));\n    for (; _MPC_PLAINTEXT__33_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__33_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__33_0 != std::uint32_t(0)) {\n            vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__33_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}) + vectorized_access(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0})));\n        vectorized_assign(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Mux(vectorized_access(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get(), vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__34_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}));\n    for (; _MPC_PLAINTEXT__34_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__34_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__34_0 != std::uint32_t(0)) {\n            vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__34_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}) + decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n        vectorized_assign(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Mux(vectorized_access(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get(), vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get()));\n\n    }\n\n    vectorized_assign(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n    vectorized_assign(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(OUTPUT_cluster_x_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(OUTPUT_cluster_y_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    _4_1 = std::make_tuple(OUTPUT_cluster_x_2, OUTPUT_cluster_y_2);\n    return _4_1;\n\n}",
                "mixed": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> kmeans_iteration(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0,\n    std::uint32_t _MPC_PLAINTEXT_num_cluster_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_bestMap_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _20_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _21_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _22_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _23_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _25_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _29_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger _30_0;\n    encrypto::motion::SecureUnsignedInteger _31_0;\n    encrypto::motion::SecureUnsignedInteger _32_0;\n    encrypto::motion::SecureUnsignedInteger _33_0;\n    encrypto::motion::SecureUnsignedInteger _34_0;\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _4_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_2((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger best_dist_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger count_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger num_cluster_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_x_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_7((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_y_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_7((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__30_0;\n    std::uint32_t _MPC_PLAINTEXT__31_0;\n    std::uint32_t _MPC_PLAINTEXT__32_0;\n    std::uint32_t _MPC_PLAINTEXT__33_0;\n    std::uint32_t _MPC_PLAINTEXT__34_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__4_1;\n    std::uint32_t _MPC_PLAINTEXT_best_dist_2;\n    std::uint32_t _MPC_PLAINTEXT_count_2;\n    std::uint32_t _MPC_PLAINTEXT_val_x_2;\n    std::uint32_t _MPC_PLAINTEXT_val_y_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_y_0_Y(data_y_0.size());\n    vectorized_assign(data_y_0_Y, {data_y_0.size()}, {true}, {}, (vectorized_access(data_y_0, {data_y_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_x_0_Y(data_x_0.size());\n    vectorized_assign(data_x_0_Y, {data_x_0.size()}, {true}, {}, (vectorized_access(data_x_0, {data_x_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    // Plaintext parameter assignments\n    bestMap_0.clear();\n    std::transform(_MPC_PLAINTEXT_bestMap_0.begin(), _MPC_PLAINTEXT_bestMap_0.end(), std::back_inserter(bestMap_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bestMap_0;}), {_MPC_PLAINTEXT_len_0}));\n    best_dist_2 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_best_dist_2 = std::uint32_t(10000);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_x_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_y_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[1]), 0));}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_x_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_y_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    val_x_2 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_val_x_2 = std::uint32_t(0);\n    val_y_2 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_val_y_2 = std::uint32_t(0);\n    count_2 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_count_2 = std::uint32_t(0);\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _20_0_Y((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    vectorized_assign(_20_0_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0_Y[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _21_0_Y((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    vectorized_assign(_21_0_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0_Y[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return best_dist_2;}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_x_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_y_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return count_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) + vectorized_access(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_3_B((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    vectorized_assign(dist_3_B, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_3_B((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::ShareWrapper> _1_3_B((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_5_Y((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__30_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}));\n    vectorized_assign(best_dist_3_B, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    for (; _MPC_PLAINTEXT__30_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__30_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__30_0 != std::uint32_t(0)) {\n            vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(best_dist_5_Y, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__30_0 - std::uint32_t(1))}));\n                    vectorized_assign(best_dist_3_B, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n        }\n\n        vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}) > vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0})));\n            vectorized_assign(_1_3_B, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n        vectorized_assign(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_1_3_B, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Mux(vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get(), vectorized_access(best_dist_3_B, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get()));\n            vectorized_assign(best_dist_5_Y, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__31_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}));\n    for (; _MPC_PLAINTEXT__31_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__31_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__31_0 != std::uint32_t(0)) {\n            vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__31_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_1_3_B, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Mux(vectorized_access(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get(), vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get()));\n        vectorized_assign(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_update(vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}), {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0})));\n\n    }\n\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, drop_dim(vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return _6_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_3_B((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_4_B((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_5_Y((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__32_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}));\n    vectorized_assign(val_x_3_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    for (; _MPC_PLAINTEXT__32_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__32_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__32_0 != std::uint32_t(0)) {\n            vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(val_x_5_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__32_0 - std::uint32_t(1))}));\n                    vectorized_assign(val_x_3_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n        }\n\n        vectorized_assign(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}) + vectorized_access(_20_0_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0})));\n            vectorized_assign(val_x_4_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n        vectorized_assign(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Mux(vectorized_access(val_x_4_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get(), vectorized_access(val_x_3_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get()));\n            vectorized_assign(val_x_5_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n\n    }\n\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_3_B((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_4_B((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_5_Y((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__33_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}));\n    vectorized_assign(val_y_3_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    for (; _MPC_PLAINTEXT__33_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__33_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__33_0 != std::uint32_t(0)) {\n            vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(val_y_5_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__33_0 - std::uint32_t(1))}));\n                    vectorized_assign(val_y_3_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n        }\n\n        vectorized_assign(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}) + vectorized_access(_21_0_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0})));\n            vectorized_assign(val_y_4_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n        vectorized_assign(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Mux(vectorized_access(val_y_4_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get(), vectorized_access(val_y_3_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get()));\n            vectorized_assign(val_y_5_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n\n    }\n\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_3_B((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_4_B((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_5_Y((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__34_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}));\n    vectorized_assign(count_3_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    for (; _MPC_PLAINTEXT__34_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__34_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__34_0 != std::uint32_t(0)) {\n            vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(count_5_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__34_0 - std::uint32_t(1))}));\n                    vectorized_assign(count_3_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n        }\n\n        vectorized_assign(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}) + decltype(_MPC_CONSTANT_1_Y)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1_Y;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n            vectorized_assign(count_4_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n        vectorized_assign(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Mux(vectorized_access(count_4_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get(), vectorized_access(count_3_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get()));\n            vectorized_assign(count_5_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n\n    }\n\n    vectorized_assign(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) > decltype(_MPC_CONSTANT_0_Y)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0_Y;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n    std::vector<encrypto::motion::ShareWrapper> _3_2_B((_MPC_PLAINTEXT_num_cluster_0));\n    vectorized_assign(_3_2_B, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    vectorized_assign(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2_B, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2_B, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(OUTPUT_cluster_x_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(OUTPUT_cluster_y_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    _4_1 = std::make_tuple(OUTPUT_cluster_x_2, OUTPUT_cluster_y_2);\n    return _4_1;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> kmeans_iteration(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0,\n    std::uint32_t _MPC_PLAINTEXT_num_cluster_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_bestMap_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _20_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _21_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _22_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _23_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _25_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _29_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger _30_0;\n    encrypto::motion::SecureUnsignedInteger _31_0;\n    encrypto::motion::SecureUnsignedInteger _32_0;\n    encrypto::motion::SecureUnsignedInteger _33_0;\n    encrypto::motion::SecureUnsignedInteger _34_0;\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _4_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_2((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger best_dist_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger count_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger num_cluster_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_x_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_7((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_y_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_7((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__30_0;\n    std::uint32_t _MPC_PLAINTEXT__31_0;\n    std::uint32_t _MPC_PLAINTEXT__32_0;\n    std::uint32_t _MPC_PLAINTEXT__33_0;\n    std::uint32_t _MPC_PLAINTEXT__34_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__4_1;\n    std::uint32_t _MPC_PLAINTEXT_best_dist_2;\n    std::uint32_t _MPC_PLAINTEXT_count_2;\n    std::uint32_t _MPC_PLAINTEXT_val_x_2;\n    std::uint32_t _MPC_PLAINTEXT_val_y_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    bestMap_0.clear();\n    std::transform(_MPC_PLAINTEXT_bestMap_0.begin(), _MPC_PLAINTEXT_bestMap_0.end(), std::back_inserter(bestMap_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bestMap_0;}), {_MPC_PLAINTEXT_len_0}));\n    best_dist_2 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_best_dist_2 = std::uint32_t(10000);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_x_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_y_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[1]), 0));}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_x_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_y_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    val_x_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_x_2 = std::uint32_t(0);\n    val_y_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_y_2 = std::uint32_t(0);\n    count_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_count_2 = std::uint32_t(0);\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return best_dist_2;}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_x_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_y_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return count_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) + vectorized_access(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__30_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}));\n    for (; _MPC_PLAINTEXT__30_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__30_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__30_0 != std::uint32_t(0)) {\n            vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__30_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}) > vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0})));\n        vectorized_assign(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Mux(vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get(), vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__31_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}));\n    for (; _MPC_PLAINTEXT__31_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__31_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__31_0 != std::uint32_t(0)) {\n            vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__31_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Mux(vectorized_access(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get(), vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get()));\n        vectorized_assign(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_update(vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}), {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0})));\n\n    }\n\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, drop_dim(vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return _6_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__32_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}));\n    for (; _MPC_PLAINTEXT__32_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__32_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__32_0 != std::uint32_t(0)) {\n            vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__32_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}) + vectorized_access(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0})));\n        vectorized_assign(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Mux(vectorized_access(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get(), vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__33_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}));\n    for (; _MPC_PLAINTEXT__33_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__33_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__33_0 != std::uint32_t(0)) {\n            vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__33_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}) + vectorized_access(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0})));\n        vectorized_assign(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Mux(vectorized_access(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get(), vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__34_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}));\n    for (; _MPC_PLAINTEXT__34_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__34_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__34_0 != std::uint32_t(0)) {\n            vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__34_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}) + decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n        vectorized_assign(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Mux(vectorized_access(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get(), vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get()));\n\n    }\n\n    vectorized_assign(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n    vectorized_assign(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(OUTPUT_cluster_x_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(OUTPUT_cluster_y_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    _4_1 = std::make_tuple(OUTPUT_cluster_x_2, OUTPUT_cluster_y_2);\n    return _4_1;\n\n}",
                "Y": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> kmeans_iteration(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0,\n    std::uint32_t _MPC_PLAINTEXT_num_cluster_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_bestMap_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _20_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _21_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _22_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _23_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _25_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _29_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger _30_0;\n    encrypto::motion::SecureUnsignedInteger _31_0;\n    encrypto::motion::SecureUnsignedInteger _32_0;\n    encrypto::motion::SecureUnsignedInteger _33_0;\n    encrypto::motion::SecureUnsignedInteger _34_0;\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _4_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_2((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger best_dist_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger count_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger num_cluster_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_x_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_7((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_y_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_7((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__30_0;\n    std::uint32_t _MPC_PLAINTEXT__31_0;\n    std::uint32_t _MPC_PLAINTEXT__32_0;\n    std::uint32_t _MPC_PLAINTEXT__33_0;\n    std::uint32_t _MPC_PLAINTEXT__34_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__4_1;\n    std::uint32_t _MPC_PLAINTEXT_best_dist_2;\n    std::uint32_t _MPC_PLAINTEXT_count_2;\n    std::uint32_t _MPC_PLAINTEXT_val_x_2;\n    std::uint32_t _MPC_PLAINTEXT_val_y_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    bestMap_0.clear();\n    std::transform(_MPC_PLAINTEXT_bestMap_0.begin(), _MPC_PLAINTEXT_bestMap_0.end(), std::back_inserter(bestMap_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bestMap_0;}), {_MPC_PLAINTEXT_len_0}));\n    best_dist_2 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_best_dist_2 = std::uint32_t(10000);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_x_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_y_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[1]), 0));}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_x_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_y_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    val_x_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_x_2 = std::uint32_t(0);\n    val_y_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_y_2 = std::uint32_t(0);\n    count_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_count_2 = std::uint32_t(0);\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return best_dist_2;}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_x_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_y_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return count_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) + vectorized_access(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__30_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}));\n    for (; _MPC_PLAINTEXT__30_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__30_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__30_0 != std::uint32_t(0)) {\n            vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__30_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}) > vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0})));\n        vectorized_assign(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Mux(vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get(), vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__31_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}));\n    for (; _MPC_PLAINTEXT__31_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__31_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__31_0 != std::uint32_t(0)) {\n            vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__31_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Mux(vectorized_access(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get(), vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get()));\n        vectorized_assign(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_update(vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}), {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0})));\n\n    }\n\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, drop_dim(vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return _6_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__32_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}));\n    for (; _MPC_PLAINTEXT__32_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__32_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__32_0 != std::uint32_t(0)) {\n            vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__32_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}) + vectorized_access(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0})));\n        vectorized_assign(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Mux(vectorized_access(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get(), vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__33_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}));\n    for (; _MPC_PLAINTEXT__33_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__33_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__33_0 != std::uint32_t(0)) {\n            vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__33_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}) + vectorized_access(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0})));\n        vectorized_assign(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Mux(vectorized_access(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get(), vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__34_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}));\n    for (; _MPC_PLAINTEXT__34_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__34_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__34_0 != std::uint32_t(0)) {\n            vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__34_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}) + decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n        vectorized_assign(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Mux(vectorized_access(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get(), vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get()));\n\n    }\n\n    vectorized_assign(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n    vectorized_assign(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(OUTPUT_cluster_x_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(OUTPUT_cluster_y_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    _4_1 = std::make_tuple(OUTPUT_cluster_x_2, OUTPUT_cluster_y_2);\n    return _4_1;\n\n}",
                "mixed": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> kmeans_iteration(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0,\n    std::uint32_t _MPC_PLAINTEXT_num_cluster_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_bestMap_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _20_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _21_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _22_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _23_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _25_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _29_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger _30_0;\n    encrypto::motion::SecureUnsignedInteger _31_0;\n    encrypto::motion::SecureUnsignedInteger _32_0;\n    encrypto::motion::SecureUnsignedInteger _33_0;\n    encrypto::motion::SecureUnsignedInteger _34_0;\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _4_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_2((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger best_dist_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger count_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger num_cluster_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_x_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_7((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_y_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_7((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__30_0;\n    std::uint32_t _MPC_PLAINTEXT__31_0;\n    std::uint32_t _MPC_PLAINTEXT__32_0;\n    std::uint32_t _MPC_PLAINTEXT__33_0;\n    std::uint32_t _MPC_PLAINTEXT__34_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__4_1;\n    std::uint32_t _MPC_PLAINTEXT_best_dist_2;\n    std::uint32_t _MPC_PLAINTEXT_count_2;\n    std::uint32_t _MPC_PLAINTEXT_val_x_2;\n    std::uint32_t _MPC_PLAINTEXT_val_y_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_y_0_B(data_y_0.size());\n    vectorized_assign(data_y_0_B, {data_y_0.size()}, {true}, {}, (vectorized_access(data_y_0, {data_y_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_x_0_B(data_x_0.size());\n    vectorized_assign(data_x_0_B, {data_x_0.size()}, {true}, {}, (vectorized_access(data_x_0, {data_x_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    // Plaintext parameter assignments\n    bestMap_0.clear();\n    std::transform(_MPC_PLAINTEXT_bestMap_0.begin(), _MPC_PLAINTEXT_bestMap_0.end(), std::back_inserter(bestMap_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bestMap_0;}), {_MPC_PLAINTEXT_len_0}));\n    best_dist_2 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_best_dist_2 = std::uint32_t(10000);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_x_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_y_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[1]), 0));}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_x_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_y_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    val_x_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_x_2 = std::uint32_t(0);\n    val_y_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_y_2 = std::uint32_t(0);\n    count_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_count_2 = std::uint32_t(0);\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _20_0_B((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    vectorized_assign(_20_0_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0_B[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _21_0_B((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    vectorized_assign(_21_0_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0_B[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return best_dist_2;}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_x_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_y_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return count_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) + vectorized_access(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_3_B((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    vectorized_assign(dist_3_B, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__30_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}));\n    for (; _MPC_PLAINTEXT__30_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__30_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__30_0 != std::uint32_t(0)) {\n            vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__30_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}) > vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0})));\n        vectorized_assign(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Mux(vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get(), vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__31_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}));\n    for (; _MPC_PLAINTEXT__31_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__31_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__31_0 != std::uint32_t(0)) {\n            vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__31_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Mux(vectorized_access(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get(), vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get()));\n        vectorized_assign(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_update(vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}), {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0})));\n\n    }\n\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, drop_dim(vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return _6_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__32_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}));\n    for (; _MPC_PLAINTEXT__32_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__32_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__32_0 != std::uint32_t(0)) {\n            vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__32_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}) + vectorized_access(_20_0_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0})));\n        vectorized_assign(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Mux(vectorized_access(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get(), vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__33_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}));\n    for (; _MPC_PLAINTEXT__33_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__33_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__33_0 != std::uint32_t(0)) {\n            vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__33_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}) + vectorized_access(_21_0_B, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0})));\n        vectorized_assign(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Mux(vectorized_access(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get(), vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__34_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}));\n    for (; _MPC_PLAINTEXT__34_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__34_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__34_0 != std::uint32_t(0)) {\n            vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__34_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}) + decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n        vectorized_assign(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Mux(vectorized_access(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get(), vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get()));\n\n    }\n\n    vectorized_assign(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n    vectorized_assign(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(OUTPUT_cluster_x_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(OUTPUT_cluster_y_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    _4_1 = std::make_tuple(OUTPUT_cluster_x_2, OUTPUT_cluster_y_2);\n    return _4_1;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> kmeans_iteration(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0,\n    std::uint32_t _MPC_PLAINTEXT_num_cluster_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_bestMap_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _20_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _21_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _22_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _23_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _25_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _29_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger _30_0;\n    encrypto::motion::SecureUnsignedInteger _31_0;\n    encrypto::motion::SecureUnsignedInteger _32_0;\n    encrypto::motion::SecureUnsignedInteger _33_0;\n    encrypto::motion::SecureUnsignedInteger _34_0;\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _4_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_2((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger best_dist_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger count_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger num_cluster_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_x_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_7((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_y_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_7((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__30_0;\n    std::uint32_t _MPC_PLAINTEXT__31_0;\n    std::uint32_t _MPC_PLAINTEXT__32_0;\n    std::uint32_t _MPC_PLAINTEXT__33_0;\n    std::uint32_t _MPC_PLAINTEXT__34_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__4_1;\n    std::uint32_t _MPC_PLAINTEXT_best_dist_2;\n    std::uint32_t _MPC_PLAINTEXT_count_2;\n    std::uint32_t _MPC_PLAINTEXT_val_x_2;\n    std::uint32_t _MPC_PLAINTEXT_val_y_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    bestMap_0.clear();\n    std::transform(_MPC_PLAINTEXT_bestMap_0.begin(), _MPC_PLAINTEXT_bestMap_0.end(), std::back_inserter(bestMap_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bestMap_0;}), {_MPC_PLAINTEXT_len_0}));\n    best_dist_2 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_best_dist_2 = std::uint32_t(10000);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_x_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_y_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[1]), 0));}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_x_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_y_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    val_x_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_x_2 = std::uint32_t(0);\n    val_y_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_y_2 = std::uint32_t(0);\n    count_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_count_2 = std::uint32_t(0);\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return best_dist_2;}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_x_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_y_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return count_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) + vectorized_access(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__30_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}));\n    for (; _MPC_PLAINTEXT__30_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__30_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__30_0 != std::uint32_t(0)) {\n            vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__30_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}) > vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0})));\n        vectorized_assign(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Mux(vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get(), vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__31_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}));\n    for (; _MPC_PLAINTEXT__31_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__31_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__31_0 != std::uint32_t(0)) {\n            vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__31_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Mux(vectorized_access(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get(), vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get()));\n        vectorized_assign(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_update(vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}), {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0})));\n\n    }\n\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, drop_dim(vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return _6_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__32_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}));\n    for (; _MPC_PLAINTEXT__32_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__32_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__32_0 != std::uint32_t(0)) {\n            vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__32_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}) + vectorized_access(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0})));\n        vectorized_assign(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Mux(vectorized_access(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get(), vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__33_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}));\n    for (; _MPC_PLAINTEXT__33_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__33_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__33_0 != std::uint32_t(0)) {\n            vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__33_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}) + vectorized_access(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0})));\n        vectorized_assign(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Mux(vectorized_access(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get(), vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__34_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}));\n    for (; _MPC_PLAINTEXT__34_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__34_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__34_0 != std::uint32_t(0)) {\n            vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__34_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}) + decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n        vectorized_assign(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Mux(vectorized_access(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get(), vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get()));\n\n    }\n\n    vectorized_assign(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n    vectorized_assign(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(OUTPUT_cluster_x_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(OUTPUT_cluster_y_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    _4_1 = std::make_tuple(OUTPUT_cluster_x_2, OUTPUT_cluster_y_2);\n    return _4_1;\n\n}",
                "Y": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> kmeans_iteration(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0,\n    std::uint32_t _MPC_PLAINTEXT_num_cluster_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_bestMap_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _20_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _21_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _22_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _23_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _25_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _29_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger _30_0;\n    encrypto::motion::SecureUnsignedInteger _31_0;\n    encrypto::motion::SecureUnsignedInteger _32_0;\n    encrypto::motion::SecureUnsignedInteger _33_0;\n    encrypto::motion::SecureUnsignedInteger _34_0;\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _4_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_2((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger best_dist_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger count_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger num_cluster_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_x_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_7((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_y_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_7((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__30_0;\n    std::uint32_t _MPC_PLAINTEXT__31_0;\n    std::uint32_t _MPC_PLAINTEXT__32_0;\n    std::uint32_t _MPC_PLAINTEXT__33_0;\n    std::uint32_t _MPC_PLAINTEXT__34_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__4_1;\n    std::uint32_t _MPC_PLAINTEXT_best_dist_2;\n    std::uint32_t _MPC_PLAINTEXT_count_2;\n    std::uint32_t _MPC_PLAINTEXT_val_x_2;\n    std::uint32_t _MPC_PLAINTEXT_val_y_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    bestMap_0.clear();\n    std::transform(_MPC_PLAINTEXT_bestMap_0.begin(), _MPC_PLAINTEXT_bestMap_0.end(), std::back_inserter(bestMap_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bestMap_0;}), {_MPC_PLAINTEXT_len_0}));\n    best_dist_2 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_best_dist_2 = std::uint32_t(10000);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_x_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_y_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[1]), 0));}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_x_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_y_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    val_x_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_x_2 = std::uint32_t(0);\n    val_y_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_y_2 = std::uint32_t(0);\n    count_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_count_2 = std::uint32_t(0);\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return best_dist_2;}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_x_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_y_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return count_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) + vectorized_access(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__30_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}));\n    for (; _MPC_PLAINTEXT__30_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__30_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__30_0 != std::uint32_t(0)) {\n            vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__30_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}) > vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0})));\n        vectorized_assign(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Mux(vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get(), vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__31_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}));\n    for (; _MPC_PLAINTEXT__31_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__31_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__31_0 != std::uint32_t(0)) {\n            vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__31_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Mux(vectorized_access(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get(), vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get()));\n        vectorized_assign(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_update(vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}), {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0})));\n\n    }\n\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, drop_dim(vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return _6_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__32_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}));\n    for (; _MPC_PLAINTEXT__32_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__32_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__32_0 != std::uint32_t(0)) {\n            vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__32_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}) + vectorized_access(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0})));\n        vectorized_assign(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Mux(vectorized_access(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get(), vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__33_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}));\n    for (; _MPC_PLAINTEXT__33_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__33_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__33_0 != std::uint32_t(0)) {\n            vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__33_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}) + vectorized_access(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0})));\n        vectorized_assign(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Mux(vectorized_access(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get(), vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__34_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}));\n    for (; _MPC_PLAINTEXT__34_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__34_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__34_0 != std::uint32_t(0)) {\n            vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__34_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}) + decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n        vectorized_assign(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Mux(vectorized_access(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get(), vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get()));\n\n    }\n\n    vectorized_assign(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n    vectorized_assign(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(OUTPUT_cluster_x_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(OUTPUT_cluster_y_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    _4_1 = std::make_tuple(OUTPUT_cluster_x_2, OUTPUT_cluster_y_2);\n    return _4_1;\n\n}",
                "mixed": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> kmeans_iteration(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> cluster_y_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_0,\n    std::uint32_t _MPC_PLAINTEXT_len_0,\n    std::uint32_t _MPC_PLAINTEXT_num_cluster_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_bestMap_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _18_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _19_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _20_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _21_0((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _22_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _23_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _25_0((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _29_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger _30_0;\n    encrypto::motion::SecureUnsignedInteger _31_0;\n    encrypto::motion::SecureUnsignedInteger _32_0;\n    encrypto::motion::SecureUnsignedInteger _33_0;\n    encrypto::motion::SecureUnsignedInteger _34_0;\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _4_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_x_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_cluster_y_2((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_2((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> bestMap_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger best_dist_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger count_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> count_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger len_0;\n    encrypto::motion::SecureUnsignedInteger num_cluster_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_x_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_x_7((_MPC_PLAINTEXT_num_cluster_0));\n    encrypto::motion::SecureUnsignedInteger val_y_2;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_3((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_4((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_5((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_6((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_y_7((_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> x_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_dist_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> y_sq_3((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__30_0;\n    std::uint32_t _MPC_PLAINTEXT__31_0;\n    std::uint32_t _MPC_PLAINTEXT__32_0;\n    std::uint32_t _MPC_PLAINTEXT__33_0;\n    std::uint32_t _MPC_PLAINTEXT__34_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__4_1;\n    std::uint32_t _MPC_PLAINTEXT_best_dist_2;\n    std::uint32_t _MPC_PLAINTEXT_count_2;\n    std::uint32_t _MPC_PLAINTEXT_val_x_2;\n    std::uint32_t _MPC_PLAINTEXT_val_y_2;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_10000 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(10000)), 0);\n\n    // Input Protocol Convertions\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_y_0_Y(data_y_0.size());\n    vectorized_assign(data_y_0_Y, {data_y_0.size()}, {true}, {}, (vectorized_access(data_y_0, {data_y_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n    std::vector<encrypto::motion::SecureUnsignedInteger> data_x_0_Y(data_x_0.size());\n    vectorized_assign(data_x_0_Y, {data_x_0.size()}, {true}, {}, (vectorized_access(data_x_0, {data_x_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    // Plaintext parameter assignments\n    bestMap_0.clear();\n    std::transform(_MPC_PLAINTEXT_bestMap_0.begin(), _MPC_PLAINTEXT_bestMap_0.end(), std::back_inserter(bestMap_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bestMap_0;}), {_MPC_PLAINTEXT_len_0}));\n    best_dist_2 = _MPC_CONSTANT_10000;\n    _MPC_PLAINTEXT_best_dist_2 = std::uint32_t(10000);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_x_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return cluster_y_0[indices[1]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[0]];}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[1]), 0));}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_x_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_cluster_y_0;}), {_MPC_PLAINTEXT_num_cluster_0}));\n    val_x_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_x_2 = std::uint32_t(0);\n    val_y_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_val_y_2 = std::uint32_t(0);\n    count_2 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_count_2 = std::uint32_t(0);\n    vectorized_assign(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return encrypto::motion::SecureUnsignedInteger(party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(indices[0]), 0));}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_20_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _20_0_Y((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    vectorized_assign(_20_0_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_x_0_Y[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_21_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _21_0_Y((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    vectorized_assign(_21_0_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return data_y_0_Y[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_5_0, {_MPC_PLAINTEXT_len_0}, {true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return best_dist_2;}), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_9_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_10_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(_11_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) - vectorized_access(_12_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_x_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_y_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return count_2;}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(x_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) * vectorized_access(y_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    vectorized_assign(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(x_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}) + vectorized_access(y_sq_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> dist_3_B((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    vectorized_assign(dist_3_B, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}, (vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    std::vector<encrypto::motion::SecureUnsignedInteger> best_dist_3_Y((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n    std::vector<encrypto::motion::ShareWrapper> _1_3_B((_MPC_PLAINTEXT_len_0) * (_MPC_PLAINTEXT_num_cluster_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__30_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_7_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}));\n    vectorized_assign(best_dist_3_Y, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    for (; _MPC_PLAINTEXT__30_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__30_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__30_0 != std::uint32_t(0)) {\n            vectorized_assign(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__30_0 - std::uint32_t(1))}));\n                    vectorized_assign(best_dist_3_Y, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n        }\n\n        vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(best_dist_3_Y, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}) > vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0})));\n            vectorized_assign(_1_3_B, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, (vectorized_access(_1_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n        vectorized_assign(best_dist_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}, vectorized_access(_1_3_B, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Mux(vectorized_access(dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get(), vectorized_access(best_dist_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__30_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__31_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_8_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}));\n    for (; _MPC_PLAINTEXT__31_0 < _MPC_PLAINTEXT_num_cluster_0; _MPC_PLAINTEXT__31_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__31_0 != std::uint32_t(0)) {\n            vectorized_assign(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {(_MPC_PLAINTEXT__31_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_access(_1_3_B, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Mux(vectorized_access(_29_0, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get(), vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}).Get()));\n        vectorized_assign(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}, vectorized_update(vectorized_access(bestMap_2, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0}), {_MPC_PLAINTEXT_len_0}, {true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, false}, {_MPC_PLAINTEXT__31_0})));\n\n    }\n\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_len_0}, {true}, {}, drop_dim(vectorized_access(bestMap_3, {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_len_0, _MPC_PLAINTEXT_num_cluster_0}));\n    vectorized_assign(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return _6_0[indices[1]];}), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_18_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_19_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}))));\n    std::vector<encrypto::motion::ShareWrapper> _2_3_Y((_MPC_PLAINTEXT_num_cluster_0) * (_MPC_PLAINTEXT_len_0));\n    vectorized_assign(_2_3_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}, (vectorized_access(_2_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__32_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_15_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}));\n    for (; _MPC_PLAINTEXT__32_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__32_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__32_0 != std::uint32_t(0)) {\n            vectorized_assign(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__32_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, (vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}) + vectorized_access(_20_0_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0})));\n        vectorized_assign(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}, vectorized_access(_2_3_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Mux(vectorized_access(val_x_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get(), vectorized_access(val_x_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__32_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__33_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_16_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}));\n    for (; _MPC_PLAINTEXT__33_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__33_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__33_0 != std::uint32_t(0)) {\n            vectorized_assign(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__33_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, (vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}) + vectorized_access(_21_0_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0})));\n        vectorized_assign(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}, vectorized_access(_2_3_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Mux(vectorized_access(val_y_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get(), vectorized_access(val_y_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__33_0}).Get()));\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__34_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_17_0, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}));\n    for (; _MPC_PLAINTEXT__34_0 < _MPC_PLAINTEXT_len_0; _MPC_PLAINTEXT__34_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__34_0 != std::uint32_t(0)) {\n            vectorized_assign(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {(_MPC_PLAINTEXT__34_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, (vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}) + decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n        vectorized_assign(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}, vectorized_access(_2_3_Y, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Mux(vectorized_access(count_4, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get(), vectorized_access(count_3, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, false}, {_MPC_PLAINTEXT__34_0}).Get()));\n\n    }\n\n    vectorized_assign(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_x_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(val_y_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, drop_dim(vectorized_access(count_5, {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_num_cluster_0, _MPC_PLAINTEXT_len_0}));\n    vectorized_assign(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) > decltype(_MPC_CONSTANT_0)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_0;}), {_MPC_PLAINTEXT_num_cluster_0}))));\n    vectorized_assign(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, (vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}) / vectorized_access(_22_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_x_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_23_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(_3_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Mux(vectorized_access(val_y_6, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get(), vectorized_access(_25_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}).Get()));\n    vectorized_assign(OUTPUT_cluster_x_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_13_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_x_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    vectorized_assign(OUTPUT_cluster_y_2, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_update(_14_0, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {}, vectorized_access(val_y_7, {_MPC_PLAINTEXT_num_cluster_0}, {true}, {})));\n    _4_1 = std::make_tuple(OUTPUT_cluster_x_2, OUTPUT_cluster_y_2);\n    return _4_1;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef kmeans_iteration(data_x_0, data_y_0, cluster_x_0, cluster_y_0, OUTPUT_cluster_x_0, OUTPUT_cluster_y_0, len_0, num_cluster_0, bestMap_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_0 * num_cluster_0)\n    _10_0 = [None] * (len_0 * num_cluster_0)\n    _11_0 = [None] * (len_0 * num_cluster_0)\n    _12_0 = [None] * (len_0 * num_cluster_0)\n    _13_0 = [None] * (num_cluster_0)\n    _14_0 = [None] * (num_cluster_0)\n    _15_0 = [None] * (num_cluster_0 * len_0)\n    _16_0 = [None] * (num_cluster_0 * len_0)\n    _17_0 = [None] * (num_cluster_0 * len_0)\n    _18_0 = [None] * (num_cluster_0 * len_0)\n    _19_0 = [None] * (num_cluster_0 * len_0)\n    _2_3 = [None] * (num_cluster_0 * len_0)\n    _20_0 = [None] * (num_cluster_0 * len_0)\n    _21_0 = [None] * (num_cluster_0 * len_0)\n    _22_0 = [None] * (num_cluster_0)\n    _23_0 = [None] * (num_cluster_0)\n    _25_0 = [None] * (num_cluster_0)\n    _29_0 = [None] * (len_0 * num_cluster_0)\n    _3_2 = [None] * (num_cluster_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0 * num_cluster_0)\n    _8_0 = [None] * (len_0 * num_cluster_0)\n    _9_0 = [None] * (len_0 * num_cluster_0)\n    OUTPUT_cluster_x_2 = [None] * (num_cluster_0)\n    OUTPUT_cluster_y_2 = [None] * (num_cluster_0)\n    bestMap_2 = [None] * (len_0 * num_cluster_0)\n    bestMap_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_5 = [None] * (len_0 * num_cluster_0)\n    count_3 = [None] * (num_cluster_0 * len_0)\n    count_4 = [None] * (num_cluster_0 * len_0)\n    count_5 = [None] * (num_cluster_0 * len_0)\n    dist_3 = [None] * (len_0 * num_cluster_0)\n    val_5 = [None] * (len_0 * num_cluster_0)\n    val_x_3 = [None] * (num_cluster_0 * len_0)\n    val_x_4 = [None] * (num_cluster_0 * len_0)\n    val_x_5 = [None] * (num_cluster_0 * len_0)\n    val_x_6 = [None] * (num_cluster_0)\n    val_x_7 = [None] * (num_cluster_0)\n    val_y_3 = [None] * (num_cluster_0 * len_0)\n    val_y_4 = [None] * (num_cluster_0 * len_0)\n    val_y_5 = [None] * (num_cluster_0 * len_0)\n    val_y_6 = [None] * (num_cluster_0)\n    val_y_7 = [None] * (num_cluster_0)\n    x_dist_3 = [None] * (len_0 * num_cluster_0)\n    x_sq_3 = [None] * (len_0 * num_cluster_0)\n    y_dist_3 = [None] * (len_0 * num_cluster_0)\n    y_sq_3 = [None] * (len_0 * num_cluster_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: bestMap_0, [len_0])\n    best_dist_2 = sint(10000)\n    _9_0 = _v.lift(lambda indices: (cluster_x_0[indices[1]]), [len_0, num_cluster_0])\n    _10_0 = _v.lift(lambda indices: (data_x_0[indices[0]]), [len_0, num_cluster_0])\n    _11_0 = _v.lift(lambda indices: (cluster_y_0[indices[1]]), [len_0, num_cluster_0])\n    _12_0 = _v.lift(lambda indices: (data_y_0[indices[0]]), [len_0, num_cluster_0])\n    _29_0 = _v.lift(lambda indices: indices[1], [len_0, num_cluster_0])\n    _13_0 = _v.lift(lambda indices: OUTPUT_cluster_x_0, [num_cluster_0])\n    _14_0 = _v.lift(lambda indices: OUTPUT_cluster_y_0, [num_cluster_0])\n    val_x_2 = sint(0)\n    val_y_2 = sint(0)\n    count_2 = sint(0)\n    _18_0 = _v.lift(lambda indices: indices[0], [num_cluster_0, len_0])\n    _20_0 = _v.lift(lambda indices: (data_x_0[indices[1]]), [num_cluster_0, len_0])\n    _21_0 = _v.lift(lambda indices: (data_y_0[indices[1]]), [num_cluster_0, len_0])\n    _8_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [len_0], [None]), [len_0, num_cluster_0])\n    _7_0 = _v.lift(lambda indices: best_dist_2, [len_0, num_cluster_0])\n    _v.vectorized_assign(x_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_9_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_10_0, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_11_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_12_0, [len_0, num_cluster_0], [None, None])))\n    _15_0 = _v.lift(lambda indices: val_x_2, [num_cluster_0, len_0])\n    _16_0 = _v.lift(lambda indices: val_y_2, [num_cluster_0, len_0])\n    _17_0 = _v.lift(lambda indices: count_2, [num_cluster_0, len_0])\n    _v.vectorized_assign(x_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_sq_3, [len_0, num_cluster_0], [None, None]) + _v.vectorized_access_simd(y_sq_3, [len_0, num_cluster_0], [None, None])))\n    for _30_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _30_0 == 0:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(_7_0, [len_0, num_cluster_0], [None, _30_0]))\n        else:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n        _v.vectorized_assign(_1_3, [len_0, num_cluster_0], [None, _30_0], (_v.vectorized_access_simd(dist_3, [len_0, num_cluster_0], [None, _30_0]) < _v.vectorized_access_simd(best_dist_3, [len_0, num_cluster_0], [None, _30_0])))\n        _v.iterative_mux(best_dist_5,_1_3,dist_3,best_dist_3,[len_0, num_cluster_0],[None, _30_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n    for _31_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _31_0 == 0:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(_8_0, [len_0, num_cluster_0], [None, _31_0]))\n        else:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n        _v.iterative_mux(val_5,_1_3,_29_0,bestMap_2,[len_0, num_cluster_0],[None, _31_0])\n        _v.vectorized_assign((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(val_5, [len_0, num_cluster_0], [None, _31_0])); _v.vectorized_assign(bestMap_3, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n    _v.vectorized_assign(_6_0, [len_0], [None], _v.drop_dim(bestMap_3, [len_0, num_cluster_0]))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [len_0], [indices[1]]), [num_cluster_0, len_0])\n    _v.vectorized_assign(_2_3, [num_cluster_0, len_0], [None, None], (_v.vectorized_access_simd(_18_0, [num_cluster_0, len_0], [None, None]) == _v.vectorized_access_simd(_19_0, [num_cluster_0, len_0], [None, None])))\n    for _32_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _32_0 == 0:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(_15_0, [num_cluster_0, len_0], [None, _32_0]))\n        else:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n        _v.vectorized_assign(val_x_4, [num_cluster_0, len_0], [None, _32_0], (_v.vectorized_access_simd(val_x_3, [num_cluster_0, len_0], [None, _32_0]) + _v.vectorized_access_simd(_20_0, [num_cluster_0, len_0], [None, _32_0])))\n        _v.iterative_mux(val_x_5,_2_3,val_x_4,val_x_3,[num_cluster_0, len_0],[None, _32_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n    for _33_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _33_0 == 0:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(_16_0, [num_cluster_0, len_0], [None, _33_0]))\n        else:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n        _v.vectorized_assign(val_y_4, [num_cluster_0, len_0], [None, _33_0], (_v.vectorized_access_simd(val_y_3, [num_cluster_0, len_0], [None, _33_0]) + _v.vectorized_access_simd(_21_0, [num_cluster_0, len_0], [None, _33_0])))\n        _v.iterative_mux(val_y_5,_2_3,val_y_4,val_y_3,[num_cluster_0, len_0],[None, _33_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n    for _34_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _34_0 == 0:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(_17_0, [num_cluster_0, len_0], [None, _34_0]))\n        else:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n        _v.vectorized_assign(count_4, [num_cluster_0, len_0], [None, _34_0], (_v.vectorized_access_simd(count_3, [num_cluster_0, len_0], [None, _34_0]) + sint(1)))\n        _v.iterative_mux(count_5,_2_3,count_4,count_3,[num_cluster_0, len_0],[None, _34_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n    _v.vectorized_assign(_23_0, [num_cluster_0], [None], _v.drop_dim(val_x_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_25_0, [num_cluster_0], [None], _v.drop_dim(val_y_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_22_0, [num_cluster_0], [None], _v.drop_dim(count_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_3_2, [num_cluster_0], [None], (_v.vectorized_access_simd(_22_0, [num_cluster_0], [None]) > sint(0)))\n    _v.vectorized_assign(val_x_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_23_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.vectorized_assign(val_y_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_25_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.iterative_mux(val_x_7,_3_2,val_x_6,_23_0,[num_cluster_0],[None])\n    _v.iterative_mux(val_y_7,_3_2,val_y_6,_25_0,[num_cluster_0],[None])\n    _v.vectorized_assign(_13_0, [num_cluster_0], [None], _v.vectorized_access(val_x_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_x_2, [num_cluster_0], [None], _v.vectorized_access(_13_0, [num_cluster_0], [None]))\n    _v.vectorized_assign(_14_0, [num_cluster_0], [None], _v.vectorized_access(val_y_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_y_2, [num_cluster_0], [None], _v.vectorized_access(_14_0, [num_cluster_0], [None]))\n    _4_1 = (OUTPUT_cluster_x_2,OUTPUT_cluster_y_2,)\n    return _4_1",
                "B": "N/A",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef kmeans_iteration(data_x_0, data_y_0, cluster_x_0, cluster_y_0, OUTPUT_cluster_x_0, OUTPUT_cluster_y_0, len_0, num_cluster_0, bestMap_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_0 * num_cluster_0)\n    _10_0 = [None] * (len_0 * num_cluster_0)\n    _11_0 = [None] * (len_0 * num_cluster_0)\n    _12_0 = [None] * (len_0 * num_cluster_0)\n    _13_0 = [None] * (num_cluster_0)\n    _14_0 = [None] * (num_cluster_0)\n    _15_0 = [None] * (num_cluster_0 * len_0)\n    _16_0 = [None] * (num_cluster_0 * len_0)\n    _17_0 = [None] * (num_cluster_0 * len_0)\n    _18_0 = [None] * (num_cluster_0 * len_0)\n    _19_0 = [None] * (num_cluster_0 * len_0)\n    _2_3 = [None] * (num_cluster_0 * len_0)\n    _20_0 = [None] * (num_cluster_0 * len_0)\n    _21_0 = [None] * (num_cluster_0 * len_0)\n    _22_0 = [None] * (num_cluster_0)\n    _23_0 = [None] * (num_cluster_0)\n    _25_0 = [None] * (num_cluster_0)\n    _29_0 = [None] * (len_0 * num_cluster_0)\n    _3_2 = [None] * (num_cluster_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0 * num_cluster_0)\n    _8_0 = [None] * (len_0 * num_cluster_0)\n    _9_0 = [None] * (len_0 * num_cluster_0)\n    OUTPUT_cluster_x_2 = [None] * (num_cluster_0)\n    OUTPUT_cluster_y_2 = [None] * (num_cluster_0)\n    bestMap_2 = [None] * (len_0 * num_cluster_0)\n    bestMap_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_5 = [None] * (len_0 * num_cluster_0)\n    count_3 = [None] * (num_cluster_0 * len_0)\n    count_4 = [None] * (num_cluster_0 * len_0)\n    count_5 = [None] * (num_cluster_0 * len_0)\n    dist_3 = [None] * (len_0 * num_cluster_0)\n    val_5 = [None] * (len_0 * num_cluster_0)\n    val_x_3 = [None] * (num_cluster_0 * len_0)\n    val_x_4 = [None] * (num_cluster_0 * len_0)\n    val_x_5 = [None] * (num_cluster_0 * len_0)\n    val_x_6 = [None] * (num_cluster_0)\n    val_x_7 = [None] * (num_cluster_0)\n    val_y_3 = [None] * (num_cluster_0 * len_0)\n    val_y_4 = [None] * (num_cluster_0 * len_0)\n    val_y_5 = [None] * (num_cluster_0 * len_0)\n    val_y_6 = [None] * (num_cluster_0)\n    val_y_7 = [None] * (num_cluster_0)\n    x_dist_3 = [None] * (len_0 * num_cluster_0)\n    x_sq_3 = [None] * (len_0 * num_cluster_0)\n    y_dist_3 = [None] * (len_0 * num_cluster_0)\n    y_sq_3 = [None] * (len_0 * num_cluster_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: bestMap_0, [len_0])\n    best_dist_2 = sint(10000)\n    _9_0 = _v.lift(lambda indices: (cluster_x_0[indices[1]]), [len_0, num_cluster_0])\n    _10_0 = _v.lift(lambda indices: (data_x_0[indices[0]]), [len_0, num_cluster_0])\n    _11_0 = _v.lift(lambda indices: (cluster_y_0[indices[1]]), [len_0, num_cluster_0])\n    _12_0 = _v.lift(lambda indices: (data_y_0[indices[0]]), [len_0, num_cluster_0])\n    _29_0 = _v.lift(lambda indices: indices[1], [len_0, num_cluster_0])\n    _13_0 = _v.lift(lambda indices: OUTPUT_cluster_x_0, [num_cluster_0])\n    _14_0 = _v.lift(lambda indices: OUTPUT_cluster_y_0, [num_cluster_0])\n    val_x_2 = sint(0)\n    val_y_2 = sint(0)\n    count_2 = sint(0)\n    _18_0 = _v.lift(lambda indices: indices[0], [num_cluster_0, len_0])\n    _20_0 = _v.lift(lambda indices: (data_x_0[indices[1]]), [num_cluster_0, len_0])\n    _21_0 = _v.lift(lambda indices: (data_y_0[indices[1]]), [num_cluster_0, len_0])\n    _8_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [len_0], [None]), [len_0, num_cluster_0])\n    _7_0 = _v.lift(lambda indices: best_dist_2, [len_0, num_cluster_0])\n    _v.vectorized_assign(x_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_9_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_10_0, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_11_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_12_0, [len_0, num_cluster_0], [None, None])))\n    _15_0 = _v.lift(lambda indices: val_x_2, [num_cluster_0, len_0])\n    _16_0 = _v.lift(lambda indices: val_y_2, [num_cluster_0, len_0])\n    _17_0 = _v.lift(lambda indices: count_2, [num_cluster_0, len_0])\n    _v.vectorized_assign(x_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_sq_3, [len_0, num_cluster_0], [None, None]) + _v.vectorized_access_simd(y_sq_3, [len_0, num_cluster_0], [None, None])))\n    for _30_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _30_0 == 0:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(_7_0, [len_0, num_cluster_0], [None, _30_0]))\n        else:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n        _v.vectorized_assign(_1_3, [len_0, num_cluster_0], [None, _30_0], (_v.vectorized_access_simd(dist_3, [len_0, num_cluster_0], [None, _30_0]) < _v.vectorized_access_simd(best_dist_3, [len_0, num_cluster_0], [None, _30_0])))\n        _v.iterative_mux(best_dist_5,_1_3,dist_3,best_dist_3,[len_0, num_cluster_0],[None, _30_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n    for _31_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _31_0 == 0:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(_8_0, [len_0, num_cluster_0], [None, _31_0]))\n        else:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n        _v.iterative_mux(val_5,_1_3,_29_0,bestMap_2,[len_0, num_cluster_0],[None, _31_0])\n        _v.vectorized_assign((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(val_5, [len_0, num_cluster_0], [None, _31_0])); _v.vectorized_assign(bestMap_3, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n    _v.vectorized_assign(_6_0, [len_0], [None], _v.drop_dim(bestMap_3, [len_0, num_cluster_0]))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [len_0], [indices[1]]), [num_cluster_0, len_0])\n    _v.vectorized_assign(_2_3, [num_cluster_0, len_0], [None, None], (_v.vectorized_access_simd(_18_0, [num_cluster_0, len_0], [None, None]) == _v.vectorized_access_simd(_19_0, [num_cluster_0, len_0], [None, None])))\n    for _32_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _32_0 == 0:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(_15_0, [num_cluster_0, len_0], [None, _32_0]))\n        else:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n        _v.vectorized_assign(val_x_4, [num_cluster_0, len_0], [None, _32_0], (_v.vectorized_access_simd(val_x_3, [num_cluster_0, len_0], [None, _32_0]) + _v.vectorized_access_simd(_20_0, [num_cluster_0, len_0], [None, _32_0])))\n        _v.iterative_mux(val_x_5,_2_3,val_x_4,val_x_3,[num_cluster_0, len_0],[None, _32_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n    for _33_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _33_0 == 0:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(_16_0, [num_cluster_0, len_0], [None, _33_0]))\n        else:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n        _v.vectorized_assign(val_y_4, [num_cluster_0, len_0], [None, _33_0], (_v.vectorized_access_simd(val_y_3, [num_cluster_0, len_0], [None, _33_0]) + _v.vectorized_access_simd(_21_0, [num_cluster_0, len_0], [None, _33_0])))\n        _v.iterative_mux(val_y_5,_2_3,val_y_4,val_y_3,[num_cluster_0, len_0],[None, _33_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n    for _34_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _34_0 == 0:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(_17_0, [num_cluster_0, len_0], [None, _34_0]))\n        else:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n        _v.vectorized_assign(count_4, [num_cluster_0, len_0], [None, _34_0], (_v.vectorized_access_simd(count_3, [num_cluster_0, len_0], [None, _34_0]) + sint(1)))\n        _v.iterative_mux(count_5,_2_3,count_4,count_3,[num_cluster_0, len_0],[None, _34_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n    _v.vectorized_assign(_23_0, [num_cluster_0], [None], _v.drop_dim(val_x_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_25_0, [num_cluster_0], [None], _v.drop_dim(val_y_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_22_0, [num_cluster_0], [None], _v.drop_dim(count_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_3_2, [num_cluster_0], [None], (_v.vectorized_access_simd(_22_0, [num_cluster_0], [None]) > sint(0)))\n    _v.vectorized_assign(val_x_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_23_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.vectorized_assign(val_y_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_25_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.iterative_mux(val_x_7,_3_2,val_x_6,_23_0,[num_cluster_0],[None])\n    _v.iterative_mux(val_y_7,_3_2,val_y_6,_25_0,[num_cluster_0],[None])\n    _v.vectorized_assign(_13_0, [num_cluster_0], [None], _v.vectorized_access(val_x_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_x_2, [num_cluster_0], [None], _v.vectorized_access(_13_0, [num_cluster_0], [None]))\n    _v.vectorized_assign(_14_0, [num_cluster_0], [None], _v.vectorized_access(val_y_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_y_2, [num_cluster_0], [None], _v.vectorized_access(_14_0, [num_cluster_0], [None]))\n    _4_1 = (OUTPUT_cluster_x_2,OUTPUT_cluster_y_2,)\n    return _4_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef kmeans_iteration(data_x_0, data_y_0, cluster_x_0, cluster_y_0, OUTPUT_cluster_x_0, OUTPUT_cluster_y_0, len_0, num_cluster_0, bestMap_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_0 * num_cluster_0)\n    _10_0 = [None] * (len_0 * num_cluster_0)\n    _11_0 = [None] * (len_0 * num_cluster_0)\n    _12_0 = [None] * (len_0 * num_cluster_0)\n    _13_0 = [None] * (num_cluster_0)\n    _14_0 = [None] * (num_cluster_0)\n    _15_0 = [None] * (num_cluster_0 * len_0)\n    _16_0 = [None] * (num_cluster_0 * len_0)\n    _17_0 = [None] * (num_cluster_0 * len_0)\n    _18_0 = [None] * (num_cluster_0 * len_0)\n    _19_0 = [None] * (num_cluster_0 * len_0)\n    _2_3 = [None] * (num_cluster_0 * len_0)\n    _20_0 = [None] * (num_cluster_0 * len_0)\n    _21_0 = [None] * (num_cluster_0 * len_0)\n    _22_0 = [None] * (num_cluster_0)\n    _23_0 = [None] * (num_cluster_0)\n    _25_0 = [None] * (num_cluster_0)\n    _29_0 = [None] * (len_0 * num_cluster_0)\n    _3_2 = [None] * (num_cluster_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0 * num_cluster_0)\n    _8_0 = [None] * (len_0 * num_cluster_0)\n    _9_0 = [None] * (len_0 * num_cluster_0)\n    OUTPUT_cluster_x_2 = [None] * (num_cluster_0)\n    OUTPUT_cluster_y_2 = [None] * (num_cluster_0)\n    bestMap_2 = [None] * (len_0 * num_cluster_0)\n    bestMap_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_5 = [None] * (len_0 * num_cluster_0)\n    count_3 = [None] * (num_cluster_0 * len_0)\n    count_4 = [None] * (num_cluster_0 * len_0)\n    count_5 = [None] * (num_cluster_0 * len_0)\n    dist_3 = [None] * (len_0 * num_cluster_0)\n    val_5 = [None] * (len_0 * num_cluster_0)\n    val_x_3 = [None] * (num_cluster_0 * len_0)\n    val_x_4 = [None] * (num_cluster_0 * len_0)\n    val_x_5 = [None] * (num_cluster_0 * len_0)\n    val_x_6 = [None] * (num_cluster_0)\n    val_x_7 = [None] * (num_cluster_0)\n    val_y_3 = [None] * (num_cluster_0 * len_0)\n    val_y_4 = [None] * (num_cluster_0 * len_0)\n    val_y_5 = [None] * (num_cluster_0 * len_0)\n    val_y_6 = [None] * (num_cluster_0)\n    val_y_7 = [None] * (num_cluster_0)\n    x_dist_3 = [None] * (len_0 * num_cluster_0)\n    x_sq_3 = [None] * (len_0 * num_cluster_0)\n    y_dist_3 = [None] * (len_0 * num_cluster_0)\n    y_sq_3 = [None] * (len_0 * num_cluster_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: bestMap_0, [len_0])\n    best_dist_2 = sint(10000)\n    _9_0 = _v.lift(lambda indices: (cluster_x_0[indices[1]]), [len_0, num_cluster_0])\n    _10_0 = _v.lift(lambda indices: (data_x_0[indices[0]]), [len_0, num_cluster_0])\n    _11_0 = _v.lift(lambda indices: (cluster_y_0[indices[1]]), [len_0, num_cluster_0])\n    _12_0 = _v.lift(lambda indices: (data_y_0[indices[0]]), [len_0, num_cluster_0])\n    _29_0 = _v.lift(lambda indices: indices[1], [len_0, num_cluster_0])\n    _13_0 = _v.lift(lambda indices: OUTPUT_cluster_x_0, [num_cluster_0])\n    _14_0 = _v.lift(lambda indices: OUTPUT_cluster_y_0, [num_cluster_0])\n    val_x_2 = sint(0)\n    val_y_2 = sint(0)\n    count_2 = sint(0)\n    _18_0 = _v.lift(lambda indices: indices[0], [num_cluster_0, len_0])\n    _20_0 = _v.lift(lambda indices: (data_x_0[indices[1]]), [num_cluster_0, len_0])\n    _21_0 = _v.lift(lambda indices: (data_y_0[indices[1]]), [num_cluster_0, len_0])\n    _8_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [len_0], [None]), [len_0, num_cluster_0])\n    _7_0 = _v.lift(lambda indices: best_dist_2, [len_0, num_cluster_0])\n    _v.vectorized_assign(x_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_9_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_10_0, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_11_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_12_0, [len_0, num_cluster_0], [None, None])))\n    _15_0 = _v.lift(lambda indices: val_x_2, [num_cluster_0, len_0])\n    _16_0 = _v.lift(lambda indices: val_y_2, [num_cluster_0, len_0])\n    _17_0 = _v.lift(lambda indices: count_2, [num_cluster_0, len_0])\n    _v.vectorized_assign(x_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_sq_3, [len_0, num_cluster_0], [None, None]) + _v.vectorized_access_simd(y_sq_3, [len_0, num_cluster_0], [None, None])))\n    for _30_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _30_0 == 0:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(_7_0, [len_0, num_cluster_0], [None, _30_0]))\n        else:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n        _v.vectorized_assign(_1_3, [len_0, num_cluster_0], [None, _30_0], (_v.vectorized_access_simd(dist_3, [len_0, num_cluster_0], [None, _30_0]) < _v.vectorized_access_simd(best_dist_3, [len_0, num_cluster_0], [None, _30_0])))\n        _v.iterative_mux(best_dist_5,_1_3,dist_3,best_dist_3,[len_0, num_cluster_0],[None, _30_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n    for _31_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _31_0 == 0:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(_8_0, [len_0, num_cluster_0], [None, _31_0]))\n        else:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n        _v.iterative_mux(val_5,_1_3,_29_0,bestMap_2,[len_0, num_cluster_0],[None, _31_0])\n        _v.vectorized_assign((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(val_5, [len_0, num_cluster_0], [None, _31_0])); _v.vectorized_assign(bestMap_3, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n    _v.vectorized_assign(_6_0, [len_0], [None], _v.drop_dim(bestMap_3, [len_0, num_cluster_0]))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [len_0], [indices[1]]), [num_cluster_0, len_0])\n    _v.vectorized_assign(_2_3, [num_cluster_0, len_0], [None, None], (_v.vectorized_access_simd(_18_0, [num_cluster_0, len_0], [None, None]) == _v.vectorized_access_simd(_19_0, [num_cluster_0, len_0], [None, None])))\n    for _32_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _32_0 == 0:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(_15_0, [num_cluster_0, len_0], [None, _32_0]))\n        else:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n        _v.vectorized_assign(val_x_4, [num_cluster_0, len_0], [None, _32_0], (_v.vectorized_access_simd(val_x_3, [num_cluster_0, len_0], [None, _32_0]) + _v.vectorized_access_simd(_20_0, [num_cluster_0, len_0], [None, _32_0])))\n        _v.iterative_mux(val_x_5,_2_3,val_x_4,val_x_3,[num_cluster_0, len_0],[None, _32_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n    for _33_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _33_0 == 0:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(_16_0, [num_cluster_0, len_0], [None, _33_0]))\n        else:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n        _v.vectorized_assign(val_y_4, [num_cluster_0, len_0], [None, _33_0], (_v.vectorized_access_simd(val_y_3, [num_cluster_0, len_0], [None, _33_0]) + _v.vectorized_access_simd(_21_0, [num_cluster_0, len_0], [None, _33_0])))\n        _v.iterative_mux(val_y_5,_2_3,val_y_4,val_y_3,[num_cluster_0, len_0],[None, _33_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n    for _34_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _34_0 == 0:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(_17_0, [num_cluster_0, len_0], [None, _34_0]))\n        else:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n        _v.vectorized_assign(count_4, [num_cluster_0, len_0], [None, _34_0], (_v.vectorized_access_simd(count_3, [num_cluster_0, len_0], [None, _34_0]) + sint(1)))\n        _v.iterative_mux(count_5,_2_3,count_4,count_3,[num_cluster_0, len_0],[None, _34_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n    _v.vectorized_assign(_23_0, [num_cluster_0], [None], _v.drop_dim(val_x_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_25_0, [num_cluster_0], [None], _v.drop_dim(val_y_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_22_0, [num_cluster_0], [None], _v.drop_dim(count_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_3_2, [num_cluster_0], [None], (_v.vectorized_access_simd(_22_0, [num_cluster_0], [None]) > sint(0)))\n    _v.vectorized_assign(val_x_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_23_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.vectorized_assign(val_y_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_25_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.iterative_mux(val_x_7,_3_2,val_x_6,_23_0,[num_cluster_0],[None])\n    _v.iterative_mux(val_y_7,_3_2,val_y_6,_25_0,[num_cluster_0],[None])\n    _v.vectorized_assign(_13_0, [num_cluster_0], [None], _v.vectorized_access(val_x_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_x_2, [num_cluster_0], [None], _v.vectorized_access(_13_0, [num_cluster_0], [None]))\n    _v.vectorized_assign(_14_0, [num_cluster_0], [None], _v.vectorized_access(val_y_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_y_2, [num_cluster_0], [None], _v.vectorized_access(_14_0, [num_cluster_0], [None]))\n    _4_1 = (OUTPUT_cluster_x_2,OUTPUT_cluster_y_2,)\n    return _4_1",
                "mixed": "program.options.binary = 32\nprogram.use_edabit(True)\ndef kmeans_iteration(data_x_0, data_y_0, cluster_x_0, cluster_y_0, OUTPUT_cluster_x_0, OUTPUT_cluster_y_0, len_0, num_cluster_0, bestMap_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    bestMap_0 = [elem for elem in sint(bestMap_0)]\n\n\n    data_y_0_B = [ siv32(elem) for elem in data_y_0] if isinstance(data_y_0, list) else siv32(data_y_0)\n    data_x_0_B = [ siv32(elem) for elem in data_x_0] if isinstance(data_x_0, list) else siv32(data_x_0)\n    \n    # Shared array declarations\n    _1_3 = [None] * (len_0 * num_cluster_0)\n    _10_0 = [None] * (len_0 * num_cluster_0)\n    _11_0 = [None] * (len_0 * num_cluster_0)\n    _12_0 = [None] * (len_0 * num_cluster_0)\n    _13_0 = [None] * (num_cluster_0)\n    _14_0 = [None] * (num_cluster_0)\n    _15_0 = [None] * (num_cluster_0 * len_0)\n    _16_0 = [None] * (num_cluster_0 * len_0)\n    _17_0 = [None] * (num_cluster_0 * len_0)\n    _18_0 = [None] * (num_cluster_0 * len_0)\n    _19_0 = [None] * (num_cluster_0 * len_0)\n    _2_3 = [None] * (num_cluster_0 * len_0)\n    _20_0 = [None] * (num_cluster_0 * len_0)\n    _21_0 = [None] * (num_cluster_0 * len_0)\n    _22_0 = [None] * (num_cluster_0)\n    _23_0 = [None] * (num_cluster_0)\n    _25_0 = [None] * (num_cluster_0)\n    _29_0 = [None] * (len_0 * num_cluster_0)\n    _3_2 = [None] * (num_cluster_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0 * num_cluster_0)\n    _8_0 = [None] * (len_0 * num_cluster_0)\n    _9_0 = [None] * (len_0 * num_cluster_0)\n    OUTPUT_cluster_x_2 = [None] * (num_cluster_0)\n    OUTPUT_cluster_y_2 = [None] * (num_cluster_0)\n    bestMap_2 = [None] * (len_0 * num_cluster_0)\n    bestMap_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_5 = [None] * (len_0 * num_cluster_0)\n    count_3 = [None] * (num_cluster_0 * len_0)\n    count_4 = [None] * (num_cluster_0 * len_0)\n    count_5 = [None] * (num_cluster_0 * len_0)\n    dist_3 = [None] * (len_0 * num_cluster_0)\n    val_5 = [None] * (len_0 * num_cluster_0)\n    val_x_3 = [None] * (num_cluster_0 * len_0)\n    val_x_4 = [None] * (num_cluster_0 * len_0)\n    val_x_5 = [None] * (num_cluster_0 * len_0)\n    val_x_6 = [None] * (num_cluster_0)\n    val_x_7 = [None] * (num_cluster_0)\n    val_y_3 = [None] * (num_cluster_0 * len_0)\n    val_y_4 = [None] * (num_cluster_0 * len_0)\n    val_y_5 = [None] * (num_cluster_0 * len_0)\n    val_y_6 = [None] * (num_cluster_0)\n    val_y_7 = [None] * (num_cluster_0)\n    x_dist_3 = [None] * (len_0 * num_cluster_0)\n    x_sq_3 = [None] * (len_0 * num_cluster_0)\n    y_dist_3 = [None] * (len_0 * num_cluster_0)\n    y_sq_3 = [None] * (len_0 * num_cluster_0)\n    # Shared array convertion declarations\n    dist_3_B = [None] * (len_0 * num_cluster_0)\n    _23_0_A = [None] * (num_cluster_0)\n    _25_0_A = [None] * (num_cluster_0)\n    _22_0_A = [None] * (num_cluster_0)\n    # Function body\n    _5_0 = _v.lift(lambda indices: bestMap_0, [len_0])\n    best_dist_2 = siv32(10000)\n    _9_0 = _v.lift(lambda indices: (cluster_x_0[indices[1]]), [len_0, num_cluster_0])\n    _10_0 = _v.lift(lambda indices: (data_x_0[indices[0]]), [len_0, num_cluster_0])\n    _11_0 = _v.lift(lambda indices: (cluster_y_0[indices[1]]), [len_0, num_cluster_0])\n    _12_0 = _v.lift(lambda indices: (data_y_0[indices[0]]), [len_0, num_cluster_0])\n    _29_0 = _v.lift(lambda indices: indices[1], [len_0, num_cluster_0])\n    _13_0 = _v.lift(lambda indices: OUTPUT_cluster_x_0, [num_cluster_0])\n    _14_0 = _v.lift(lambda indices: OUTPUT_cluster_y_0, [num_cluster_0])\n    val_x_2 = siv32(0)\n    val_y_2 = siv32(0)\n    count_2 = siv32(0)\n    _18_0 = _v.lift(lambda indices: indices[0], [num_cluster_0, len_0])\n    _20_0 = _v.lift(lambda indices: (data_x_0[indices[1]]), [num_cluster_0, len_0]);_20_0_B = _v.lift(lambda indices: (data_x_0_B[indices[1]]), [num_cluster_0, len_0])\n    _21_0 = _v.lift(lambda indices: (data_y_0[indices[1]]), [num_cluster_0, len_0]);_21_0_B = _v.lift(lambda indices: (data_y_0_B[indices[1]]), [num_cluster_0, len_0])\n    _8_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [len_0], [None]), [len_0, num_cluster_0])\n    _7_0 = _v.lift(lambda indices: best_dist_2, [len_0, num_cluster_0])\n    _v.vectorized_assign(x_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_9_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_10_0, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_11_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_12_0, [len_0, num_cluster_0], [None, None])))\n    _15_0 = _v.lift(lambda indices: val_x_2, [num_cluster_0, len_0])\n    _16_0 = _v.lift(lambda indices: val_y_2, [num_cluster_0, len_0])\n    _17_0 = _v.lift(lambda indices: count_2, [num_cluster_0, len_0])\n    _v.vectorized_assign(x_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_sq_3, [len_0, num_cluster_0], [None, None]) + _v.vectorized_access_simd(y_sq_3, [len_0, num_cluster_0], [None, None])))\n    for _random_iter in range(0,len(dist_3)):\n      dist_3_B[_random_iter] = _v.convertion_check(dist_3[_random_iter])\n    dist_3_B = siv32(dist_3_B)\n    for _30_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _30_0 == 0:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(_7_0, [len_0, num_cluster_0], [None, _30_0]))\n        else:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n        _v.vectorized_assign(_1_3, [len_0, num_cluster_0], [None, _30_0], (_v.vectorized_access_simd(dist_3, [len_0, num_cluster_0], [None, _30_0]) < _v.vectorized_access_simd(best_dist_3, [len_0, num_cluster_0], [None, _30_0])))\n        _v.iterative_mux(best_dist_5,_1_3,dist_3,best_dist_3,[len_0, num_cluster_0],[None, _30_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n    for _31_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _31_0 == 0:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(_8_0, [len_0, num_cluster_0], [None, _31_0]))\n        else:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n        _v.iterative_mux(val_5,_1_3,_29_0,bestMap_2,[len_0, num_cluster_0],[None, _31_0])\n        _v.vectorized_assign((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(val_5, [len_0, num_cluster_0], [None, _31_0])); _v.vectorized_assign(bestMap_3, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n    _v.vectorized_assign(_6_0, [len_0], [None], _v.drop_dim(bestMap_3, [len_0, num_cluster_0]))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [len_0], [indices[1]]), [num_cluster_0, len_0])\n    _v.vectorized_assign(_2_3, [num_cluster_0, len_0], [None, None], (_v.vectorized_access_simd(_18_0, [num_cluster_0, len_0], [None, None]) == _v.vectorized_access_simd(_19_0, [num_cluster_0, len_0], [None, None])))\n    for _32_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _32_0 == 0:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(_15_0, [num_cluster_0, len_0], [None, _32_0]))\n        else:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n        _v.vectorized_assign(val_x_4, [num_cluster_0, len_0], [None, _32_0], (_v.vectorized_access_simd(val_x_3, [num_cluster_0, len_0], [None, _32_0]) + _v.vectorized_access_simd(_20_0_B, [num_cluster_0, len_0], [None, _32_0])))\n        _v.iterative_mux(val_x_5,_2_3,val_x_4,val_x_3,[num_cluster_0, len_0],[None, _32_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n    for _33_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _33_0 == 0:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(_16_0, [num_cluster_0, len_0], [None, _33_0]))\n        else:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n        _v.vectorized_assign(val_y_4, [num_cluster_0, len_0], [None, _33_0], (_v.vectorized_access_simd(val_y_3, [num_cluster_0, len_0], [None, _33_0]) + _v.vectorized_access_simd(_21_0_B, [num_cluster_0, len_0], [None, _33_0])))\n        _v.iterative_mux(val_y_5,_2_3,val_y_4,val_y_3,[num_cluster_0, len_0],[None, _33_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n    for _34_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _34_0 == 0:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(_17_0, [num_cluster_0, len_0], [None, _34_0]))\n        else:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n        _v.vectorized_assign(count_4, [num_cluster_0, len_0], [None, _34_0], (_v.vectorized_access_simd(count_3, [num_cluster_0, len_0], [None, _34_0]) + siv32(1)))\n        _v.iterative_mux(count_5,_2_3,count_4,count_3,[num_cluster_0, len_0],[None, _34_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n    _v.vectorized_assign(_23_0, [num_cluster_0], [None], _v.drop_dim(val_x_5, [num_cluster_0, len_0]));_23_0_A[c_2] = sint(_23_0[c_2])\n    _v.vectorized_assign(_25_0, [num_cluster_0], [None], _v.drop_dim(val_y_5, [num_cluster_0, len_0]));_25_0_A[c_2] = sint(_25_0[c_2])\n    _v.vectorized_assign(_22_0, [num_cluster_0], [None], _v.drop_dim(count_5, [num_cluster_0, len_0]));_22_0_A[c_2] = sint(_22_0[c_2])\n    _v.vectorized_assign(_3_2, [num_cluster_0], [None], (_v.vectorized_access_simd(_22_0_A, [num_cluster_0], [None]) > sint(0)))\n    _v.vectorized_assign(val_x_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_23_0_A, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0_A, [num_cluster_0], [None])))\n    _v.vectorized_assign(val_y_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_25_0_A, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0_A, [num_cluster_0], [None])))\n    _v.iterative_mux(val_x_7,_3_2,val_x_6,_23_0_A,[num_cluster_0],[None])\n    _v.iterative_mux(val_y_7,_3_2,val_y_6,_25_0_A,[num_cluster_0],[None])\n    _v.vectorized_assign(_13_0, [num_cluster_0], [None], _v.vectorized_access(val_x_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_x_2, [num_cluster_0], [None], _v.vectorized_access(_13_0, [num_cluster_0], [None]))\n    _v.vectorized_assign(_14_0, [num_cluster_0], [None], _v.vectorized_access(val_y_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_y_2, [num_cluster_0], [None], _v.vectorized_access(_14_0, [num_cluster_0], [None]))\n    _4_1 = (OUTPUT_cluster_x_2,OUTPUT_cluster_y_2,)\n    return _4_1"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef kmeans_iteration(data_x_0, data_y_0, cluster_x_0, cluster_y_0, OUTPUT_cluster_x_0, OUTPUT_cluster_y_0, len_0, num_cluster_0, bestMap_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_0 * num_cluster_0)\n    _10_0 = [None] * (len_0 * num_cluster_0)\n    _11_0 = [None] * (len_0 * num_cluster_0)\n    _12_0 = [None] * (len_0 * num_cluster_0)\n    _13_0 = [None] * (num_cluster_0)\n    _14_0 = [None] * (num_cluster_0)\n    _15_0 = [None] * (num_cluster_0 * len_0)\n    _16_0 = [None] * (num_cluster_0 * len_0)\n    _17_0 = [None] * (num_cluster_0 * len_0)\n    _18_0 = [None] * (num_cluster_0 * len_0)\n    _19_0 = [None] * (num_cluster_0 * len_0)\n    _2_3 = [None] * (num_cluster_0 * len_0)\n    _20_0 = [None] * (num_cluster_0 * len_0)\n    _21_0 = [None] * (num_cluster_0 * len_0)\n    _22_0 = [None] * (num_cluster_0)\n    _23_0 = [None] * (num_cluster_0)\n    _25_0 = [None] * (num_cluster_0)\n    _29_0 = [None] * (len_0 * num_cluster_0)\n    _3_2 = [None] * (num_cluster_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0 * num_cluster_0)\n    _8_0 = [None] * (len_0 * num_cluster_0)\n    _9_0 = [None] * (len_0 * num_cluster_0)\n    OUTPUT_cluster_x_2 = [None] * (num_cluster_0)\n    OUTPUT_cluster_y_2 = [None] * (num_cluster_0)\n    bestMap_2 = [None] * (len_0 * num_cluster_0)\n    bestMap_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_5 = [None] * (len_0 * num_cluster_0)\n    count_3 = [None] * (num_cluster_0 * len_0)\n    count_4 = [None] * (num_cluster_0 * len_0)\n    count_5 = [None] * (num_cluster_0 * len_0)\n    dist_3 = [None] * (len_0 * num_cluster_0)\n    val_5 = [None] * (len_0 * num_cluster_0)\n    val_x_3 = [None] * (num_cluster_0 * len_0)\n    val_x_4 = [None] * (num_cluster_0 * len_0)\n    val_x_5 = [None] * (num_cluster_0 * len_0)\n    val_x_6 = [None] * (num_cluster_0)\n    val_x_7 = [None] * (num_cluster_0)\n    val_y_3 = [None] * (num_cluster_0 * len_0)\n    val_y_4 = [None] * (num_cluster_0 * len_0)\n    val_y_5 = [None] * (num_cluster_0 * len_0)\n    val_y_6 = [None] * (num_cluster_0)\n    val_y_7 = [None] * (num_cluster_0)\n    x_dist_3 = [None] * (len_0 * num_cluster_0)\n    x_sq_3 = [None] * (len_0 * num_cluster_0)\n    y_dist_3 = [None] * (len_0 * num_cluster_0)\n    y_sq_3 = [None] * (len_0 * num_cluster_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: bestMap_0, [len_0])\n    best_dist_2 = sint(10000)\n    _9_0 = _v.lift(lambda indices: (cluster_x_0[indices[1]]), [len_0, num_cluster_0])\n    _10_0 = _v.lift(lambda indices: (data_x_0[indices[0]]), [len_0, num_cluster_0])\n    _11_0 = _v.lift(lambda indices: (cluster_y_0[indices[1]]), [len_0, num_cluster_0])\n    _12_0 = _v.lift(lambda indices: (data_y_0[indices[0]]), [len_0, num_cluster_0])\n    _29_0 = _v.lift(lambda indices: indices[1], [len_0, num_cluster_0])\n    _13_0 = _v.lift(lambda indices: OUTPUT_cluster_x_0, [num_cluster_0])\n    _14_0 = _v.lift(lambda indices: OUTPUT_cluster_y_0, [num_cluster_0])\n    val_x_2 = sint(0)\n    val_y_2 = sint(0)\n    count_2 = sint(0)\n    _18_0 = _v.lift(lambda indices: indices[0], [num_cluster_0, len_0])\n    _20_0 = _v.lift(lambda indices: (data_x_0[indices[1]]), [num_cluster_0, len_0])\n    _21_0 = _v.lift(lambda indices: (data_y_0[indices[1]]), [num_cluster_0, len_0])\n    _8_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [len_0], [None]), [len_0, num_cluster_0])\n    _7_0 = _v.lift(lambda indices: best_dist_2, [len_0, num_cluster_0])\n    _v.vectorized_assign(x_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_9_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_10_0, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_11_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_12_0, [len_0, num_cluster_0], [None, None])))\n    _15_0 = _v.lift(lambda indices: val_x_2, [num_cluster_0, len_0])\n    _16_0 = _v.lift(lambda indices: val_y_2, [num_cluster_0, len_0])\n    _17_0 = _v.lift(lambda indices: count_2, [num_cluster_0, len_0])\n    _v.vectorized_assign(x_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_sq_3, [len_0, num_cluster_0], [None, None]) + _v.vectorized_access_simd(y_sq_3, [len_0, num_cluster_0], [None, None])))\n    for _30_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _30_0 == 0:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(_7_0, [len_0, num_cluster_0], [None, _30_0]))\n        else:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n        _v.vectorized_assign(_1_3, [len_0, num_cluster_0], [None, _30_0], (_v.vectorized_access_simd(dist_3, [len_0, num_cluster_0], [None, _30_0]) < _v.vectorized_access_simd(best_dist_3, [len_0, num_cluster_0], [None, _30_0])))\n        _v.iterative_mux(best_dist_5,_1_3,dist_3,best_dist_3,[len_0, num_cluster_0],[None, _30_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n    for _31_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _31_0 == 0:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(_8_0, [len_0, num_cluster_0], [None, _31_0]))\n        else:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n        _v.iterative_mux(val_5,_1_3,_29_0,bestMap_2,[len_0, num_cluster_0],[None, _31_0])\n        _v.vectorized_assign((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(val_5, [len_0, num_cluster_0], [None, _31_0])); _v.vectorized_assign(bestMap_3, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n    _v.vectorized_assign(_6_0, [len_0], [None], _v.drop_dim(bestMap_3, [len_0, num_cluster_0]))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [len_0], [indices[1]]), [num_cluster_0, len_0])\n    _v.vectorized_assign(_2_3, [num_cluster_0, len_0], [None, None], (_v.vectorized_access_simd(_18_0, [num_cluster_0, len_0], [None, None]) == _v.vectorized_access_simd(_19_0, [num_cluster_0, len_0], [None, None])))\n    for _32_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _32_0 == 0:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(_15_0, [num_cluster_0, len_0], [None, _32_0]))\n        else:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n        _v.vectorized_assign(val_x_4, [num_cluster_0, len_0], [None, _32_0], (_v.vectorized_access_simd(val_x_3, [num_cluster_0, len_0], [None, _32_0]) + _v.vectorized_access_simd(_20_0, [num_cluster_0, len_0], [None, _32_0])))\n        _v.iterative_mux(val_x_5,_2_3,val_x_4,val_x_3,[num_cluster_0, len_0],[None, _32_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n    for _33_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _33_0 == 0:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(_16_0, [num_cluster_0, len_0], [None, _33_0]))\n        else:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n        _v.vectorized_assign(val_y_4, [num_cluster_0, len_0], [None, _33_0], (_v.vectorized_access_simd(val_y_3, [num_cluster_0, len_0], [None, _33_0]) + _v.vectorized_access_simd(_21_0, [num_cluster_0, len_0], [None, _33_0])))\n        _v.iterative_mux(val_y_5,_2_3,val_y_4,val_y_3,[num_cluster_0, len_0],[None, _33_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n    for _34_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _34_0 == 0:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(_17_0, [num_cluster_0, len_0], [None, _34_0]))\n        else:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n        _v.vectorized_assign(count_4, [num_cluster_0, len_0], [None, _34_0], (_v.vectorized_access_simd(count_3, [num_cluster_0, len_0], [None, _34_0]) + sint(1)))\n        _v.iterative_mux(count_5,_2_3,count_4,count_3,[num_cluster_0, len_0],[None, _34_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n    _v.vectorized_assign(_23_0, [num_cluster_0], [None], _v.drop_dim(val_x_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_25_0, [num_cluster_0], [None], _v.drop_dim(val_y_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_22_0, [num_cluster_0], [None], _v.drop_dim(count_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_3_2, [num_cluster_0], [None], (_v.vectorized_access_simd(_22_0, [num_cluster_0], [None]) > sint(0)))\n    _v.vectorized_assign(val_x_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_23_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.vectorized_assign(val_y_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_25_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.iterative_mux(val_x_7,_3_2,val_x_6,_23_0,[num_cluster_0],[None])\n    _v.iterative_mux(val_y_7,_3_2,val_y_6,_25_0,[num_cluster_0],[None])\n    _v.vectorized_assign(_13_0, [num_cluster_0], [None], _v.vectorized_access(val_x_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_x_2, [num_cluster_0], [None], _v.vectorized_access(_13_0, [num_cluster_0], [None]))\n    _v.vectorized_assign(_14_0, [num_cluster_0], [None], _v.vectorized_access(val_y_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_y_2, [num_cluster_0], [None], _v.vectorized_access(_14_0, [num_cluster_0], [None]))\n    _4_1 = (OUTPUT_cluster_x_2,OUTPUT_cluster_y_2,)\n    return _4_1",
                "B": "N/A",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef kmeans_iteration(data_x_0, data_y_0, cluster_x_0, cluster_y_0, OUTPUT_cluster_x_0, OUTPUT_cluster_y_0, len_0, num_cluster_0, bestMap_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_0 * num_cluster_0)\n    _10_0 = [None] * (len_0 * num_cluster_0)\n    _11_0 = [None] * (len_0 * num_cluster_0)\n    _12_0 = [None] * (len_0 * num_cluster_0)\n    _13_0 = [None] * (num_cluster_0)\n    _14_0 = [None] * (num_cluster_0)\n    _15_0 = [None] * (num_cluster_0 * len_0)\n    _16_0 = [None] * (num_cluster_0 * len_0)\n    _17_0 = [None] * (num_cluster_0 * len_0)\n    _18_0 = [None] * (num_cluster_0 * len_0)\n    _19_0 = [None] * (num_cluster_0 * len_0)\n    _2_3 = [None] * (num_cluster_0 * len_0)\n    _20_0 = [None] * (num_cluster_0 * len_0)\n    _21_0 = [None] * (num_cluster_0 * len_0)\n    _22_0 = [None] * (num_cluster_0)\n    _23_0 = [None] * (num_cluster_0)\n    _25_0 = [None] * (num_cluster_0)\n    _29_0 = [None] * (len_0 * num_cluster_0)\n    _3_2 = [None] * (num_cluster_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0 * num_cluster_0)\n    _8_0 = [None] * (len_0 * num_cluster_0)\n    _9_0 = [None] * (len_0 * num_cluster_0)\n    OUTPUT_cluster_x_2 = [None] * (num_cluster_0)\n    OUTPUT_cluster_y_2 = [None] * (num_cluster_0)\n    bestMap_2 = [None] * (len_0 * num_cluster_0)\n    bestMap_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_5 = [None] * (len_0 * num_cluster_0)\n    count_3 = [None] * (num_cluster_0 * len_0)\n    count_4 = [None] * (num_cluster_0 * len_0)\n    count_5 = [None] * (num_cluster_0 * len_0)\n    dist_3 = [None] * (len_0 * num_cluster_0)\n    val_5 = [None] * (len_0 * num_cluster_0)\n    val_x_3 = [None] * (num_cluster_0 * len_0)\n    val_x_4 = [None] * (num_cluster_0 * len_0)\n    val_x_5 = [None] * (num_cluster_0 * len_0)\n    val_x_6 = [None] * (num_cluster_0)\n    val_x_7 = [None] * (num_cluster_0)\n    val_y_3 = [None] * (num_cluster_0 * len_0)\n    val_y_4 = [None] * (num_cluster_0 * len_0)\n    val_y_5 = [None] * (num_cluster_0 * len_0)\n    val_y_6 = [None] * (num_cluster_0)\n    val_y_7 = [None] * (num_cluster_0)\n    x_dist_3 = [None] * (len_0 * num_cluster_0)\n    x_sq_3 = [None] * (len_0 * num_cluster_0)\n    y_dist_3 = [None] * (len_0 * num_cluster_0)\n    y_sq_3 = [None] * (len_0 * num_cluster_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: bestMap_0, [len_0])\n    best_dist_2 = sint(10000)\n    _9_0 = _v.lift(lambda indices: (cluster_x_0[indices[1]]), [len_0, num_cluster_0])\n    _10_0 = _v.lift(lambda indices: (data_x_0[indices[0]]), [len_0, num_cluster_0])\n    _11_0 = _v.lift(lambda indices: (cluster_y_0[indices[1]]), [len_0, num_cluster_0])\n    _12_0 = _v.lift(lambda indices: (data_y_0[indices[0]]), [len_0, num_cluster_0])\n    _29_0 = _v.lift(lambda indices: indices[1], [len_0, num_cluster_0])\n    _13_0 = _v.lift(lambda indices: OUTPUT_cluster_x_0, [num_cluster_0])\n    _14_0 = _v.lift(lambda indices: OUTPUT_cluster_y_0, [num_cluster_0])\n    val_x_2 = sint(0)\n    val_y_2 = sint(0)\n    count_2 = sint(0)\n    _18_0 = _v.lift(lambda indices: indices[0], [num_cluster_0, len_0])\n    _20_0 = _v.lift(lambda indices: (data_x_0[indices[1]]), [num_cluster_0, len_0])\n    _21_0 = _v.lift(lambda indices: (data_y_0[indices[1]]), [num_cluster_0, len_0])\n    _8_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [len_0], [None]), [len_0, num_cluster_0])\n    _7_0 = _v.lift(lambda indices: best_dist_2, [len_0, num_cluster_0])\n    _v.vectorized_assign(x_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_9_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_10_0, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_11_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_12_0, [len_0, num_cluster_0], [None, None])))\n    _15_0 = _v.lift(lambda indices: val_x_2, [num_cluster_0, len_0])\n    _16_0 = _v.lift(lambda indices: val_y_2, [num_cluster_0, len_0])\n    _17_0 = _v.lift(lambda indices: count_2, [num_cluster_0, len_0])\n    _v.vectorized_assign(x_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_sq_3, [len_0, num_cluster_0], [None, None]) + _v.vectorized_access_simd(y_sq_3, [len_0, num_cluster_0], [None, None])))\n    for _30_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _30_0 == 0:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(_7_0, [len_0, num_cluster_0], [None, _30_0]))\n        else:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n        _v.vectorized_assign(_1_3, [len_0, num_cluster_0], [None, _30_0], (_v.vectorized_access_simd(dist_3, [len_0, num_cluster_0], [None, _30_0]) < _v.vectorized_access_simd(best_dist_3, [len_0, num_cluster_0], [None, _30_0])))\n        _v.iterative_mux(best_dist_5,_1_3,dist_3,best_dist_3,[len_0, num_cluster_0],[None, _30_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n    for _31_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _31_0 == 0:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(_8_0, [len_0, num_cluster_0], [None, _31_0]))\n        else:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n        _v.iterative_mux(val_5,_1_3,_29_0,bestMap_2,[len_0, num_cluster_0],[None, _31_0])\n        _v.vectorized_assign((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(val_5, [len_0, num_cluster_0], [None, _31_0])); _v.vectorized_assign(bestMap_3, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n    _v.vectorized_assign(_6_0, [len_0], [None], _v.drop_dim(bestMap_3, [len_0, num_cluster_0]))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [len_0], [indices[1]]), [num_cluster_0, len_0])\n    _v.vectorized_assign(_2_3, [num_cluster_0, len_0], [None, None], (_v.vectorized_access_simd(_18_0, [num_cluster_0, len_0], [None, None]) == _v.vectorized_access_simd(_19_0, [num_cluster_0, len_0], [None, None])))\n    for _32_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _32_0 == 0:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(_15_0, [num_cluster_0, len_0], [None, _32_0]))\n        else:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n        _v.vectorized_assign(val_x_4, [num_cluster_0, len_0], [None, _32_0], (_v.vectorized_access_simd(val_x_3, [num_cluster_0, len_0], [None, _32_0]) + _v.vectorized_access_simd(_20_0, [num_cluster_0, len_0], [None, _32_0])))\n        _v.iterative_mux(val_x_5,_2_3,val_x_4,val_x_3,[num_cluster_0, len_0],[None, _32_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n    for _33_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _33_0 == 0:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(_16_0, [num_cluster_0, len_0], [None, _33_0]))\n        else:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n        _v.vectorized_assign(val_y_4, [num_cluster_0, len_0], [None, _33_0], (_v.vectorized_access_simd(val_y_3, [num_cluster_0, len_0], [None, _33_0]) + _v.vectorized_access_simd(_21_0, [num_cluster_0, len_0], [None, _33_0])))\n        _v.iterative_mux(val_y_5,_2_3,val_y_4,val_y_3,[num_cluster_0, len_0],[None, _33_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n    for _34_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _34_0 == 0:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(_17_0, [num_cluster_0, len_0], [None, _34_0]))\n        else:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n        _v.vectorized_assign(count_4, [num_cluster_0, len_0], [None, _34_0], (_v.vectorized_access_simd(count_3, [num_cluster_0, len_0], [None, _34_0]) + sint(1)))\n        _v.iterative_mux(count_5,_2_3,count_4,count_3,[num_cluster_0, len_0],[None, _34_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n    _v.vectorized_assign(_23_0, [num_cluster_0], [None], _v.drop_dim(val_x_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_25_0, [num_cluster_0], [None], _v.drop_dim(val_y_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_22_0, [num_cluster_0], [None], _v.drop_dim(count_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_3_2, [num_cluster_0], [None], (_v.vectorized_access_simd(_22_0, [num_cluster_0], [None]) > sint(0)))\n    _v.vectorized_assign(val_x_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_23_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.vectorized_assign(val_y_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_25_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.iterative_mux(val_x_7,_3_2,val_x_6,_23_0,[num_cluster_0],[None])\n    _v.iterative_mux(val_y_7,_3_2,val_y_6,_25_0,[num_cluster_0],[None])\n    _v.vectorized_assign(_13_0, [num_cluster_0], [None], _v.vectorized_access(val_x_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_x_2, [num_cluster_0], [None], _v.vectorized_access(_13_0, [num_cluster_0], [None]))\n    _v.vectorized_assign(_14_0, [num_cluster_0], [None], _v.vectorized_access(val_y_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_y_2, [num_cluster_0], [None], _v.vectorized_access(_14_0, [num_cluster_0], [None]))\n    _4_1 = (OUTPUT_cluster_x_2,OUTPUT_cluster_y_2,)\n    return _4_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef kmeans_iteration(data_x_0, data_y_0, cluster_x_0, cluster_y_0, OUTPUT_cluster_x_0, OUTPUT_cluster_y_0, len_0, num_cluster_0, bestMap_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_0 * num_cluster_0)\n    _10_0 = [None] * (len_0 * num_cluster_0)\n    _11_0 = [None] * (len_0 * num_cluster_0)\n    _12_0 = [None] * (len_0 * num_cluster_0)\n    _13_0 = [None] * (num_cluster_0)\n    _14_0 = [None] * (num_cluster_0)\n    _15_0 = [None] * (num_cluster_0 * len_0)\n    _16_0 = [None] * (num_cluster_0 * len_0)\n    _17_0 = [None] * (num_cluster_0 * len_0)\n    _18_0 = [None] * (num_cluster_0 * len_0)\n    _19_0 = [None] * (num_cluster_0 * len_0)\n    _2_3 = [None] * (num_cluster_0 * len_0)\n    _20_0 = [None] * (num_cluster_0 * len_0)\n    _21_0 = [None] * (num_cluster_0 * len_0)\n    _22_0 = [None] * (num_cluster_0)\n    _23_0 = [None] * (num_cluster_0)\n    _25_0 = [None] * (num_cluster_0)\n    _29_0 = [None] * (len_0 * num_cluster_0)\n    _3_2 = [None] * (num_cluster_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0 * num_cluster_0)\n    _8_0 = [None] * (len_0 * num_cluster_0)\n    _9_0 = [None] * (len_0 * num_cluster_0)\n    OUTPUT_cluster_x_2 = [None] * (num_cluster_0)\n    OUTPUT_cluster_y_2 = [None] * (num_cluster_0)\n    bestMap_2 = [None] * (len_0 * num_cluster_0)\n    bestMap_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_5 = [None] * (len_0 * num_cluster_0)\n    count_3 = [None] * (num_cluster_0 * len_0)\n    count_4 = [None] * (num_cluster_0 * len_0)\n    count_5 = [None] * (num_cluster_0 * len_0)\n    dist_3 = [None] * (len_0 * num_cluster_0)\n    val_5 = [None] * (len_0 * num_cluster_0)\n    val_x_3 = [None] * (num_cluster_0 * len_0)\n    val_x_4 = [None] * (num_cluster_0 * len_0)\n    val_x_5 = [None] * (num_cluster_0 * len_0)\n    val_x_6 = [None] * (num_cluster_0)\n    val_x_7 = [None] * (num_cluster_0)\n    val_y_3 = [None] * (num_cluster_0 * len_0)\n    val_y_4 = [None] * (num_cluster_0 * len_0)\n    val_y_5 = [None] * (num_cluster_0 * len_0)\n    val_y_6 = [None] * (num_cluster_0)\n    val_y_7 = [None] * (num_cluster_0)\n    x_dist_3 = [None] * (len_0 * num_cluster_0)\n    x_sq_3 = [None] * (len_0 * num_cluster_0)\n    y_dist_3 = [None] * (len_0 * num_cluster_0)\n    y_sq_3 = [None] * (len_0 * num_cluster_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: bestMap_0, [len_0])\n    best_dist_2 = sint(10000)\n    _9_0 = _v.lift(lambda indices: (cluster_x_0[indices[1]]), [len_0, num_cluster_0])\n    _10_0 = _v.lift(lambda indices: (data_x_0[indices[0]]), [len_0, num_cluster_0])\n    _11_0 = _v.lift(lambda indices: (cluster_y_0[indices[1]]), [len_0, num_cluster_0])\n    _12_0 = _v.lift(lambda indices: (data_y_0[indices[0]]), [len_0, num_cluster_0])\n    _29_0 = _v.lift(lambda indices: indices[1], [len_0, num_cluster_0])\n    _13_0 = _v.lift(lambda indices: OUTPUT_cluster_x_0, [num_cluster_0])\n    _14_0 = _v.lift(lambda indices: OUTPUT_cluster_y_0, [num_cluster_0])\n    val_x_2 = sint(0)\n    val_y_2 = sint(0)\n    count_2 = sint(0)\n    _18_0 = _v.lift(lambda indices: indices[0], [num_cluster_0, len_0])\n    _20_0 = _v.lift(lambda indices: (data_x_0[indices[1]]), [num_cluster_0, len_0])\n    _21_0 = _v.lift(lambda indices: (data_y_0[indices[1]]), [num_cluster_0, len_0])\n    _8_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [len_0], [None]), [len_0, num_cluster_0])\n    _7_0 = _v.lift(lambda indices: best_dist_2, [len_0, num_cluster_0])\n    _v.vectorized_assign(x_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_9_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_10_0, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_11_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_12_0, [len_0, num_cluster_0], [None, None])))\n    _15_0 = _v.lift(lambda indices: val_x_2, [num_cluster_0, len_0])\n    _16_0 = _v.lift(lambda indices: val_y_2, [num_cluster_0, len_0])\n    _17_0 = _v.lift(lambda indices: count_2, [num_cluster_0, len_0])\n    _v.vectorized_assign(x_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_sq_3, [len_0, num_cluster_0], [None, None]) + _v.vectorized_access_simd(y_sq_3, [len_0, num_cluster_0], [None, None])))\n    for _30_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _30_0 == 0:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(_7_0, [len_0, num_cluster_0], [None, _30_0]))\n        else:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n        _v.vectorized_assign(_1_3, [len_0, num_cluster_0], [None, _30_0], (_v.vectorized_access_simd(dist_3, [len_0, num_cluster_0], [None, _30_0]) < _v.vectorized_access_simd(best_dist_3, [len_0, num_cluster_0], [None, _30_0])))\n        _v.iterative_mux(best_dist_5,_1_3,dist_3,best_dist_3,[len_0, num_cluster_0],[None, _30_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n    for _31_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _31_0 == 0:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(_8_0, [len_0, num_cluster_0], [None, _31_0]))\n        else:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n        _v.iterative_mux(val_5,_1_3,_29_0,bestMap_2,[len_0, num_cluster_0],[None, _31_0])\n        _v.vectorized_assign((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(val_5, [len_0, num_cluster_0], [None, _31_0])); _v.vectorized_assign(bestMap_3, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n    _v.vectorized_assign(_6_0, [len_0], [None], _v.drop_dim(bestMap_3, [len_0, num_cluster_0]))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [len_0], [indices[1]]), [num_cluster_0, len_0])\n    _v.vectorized_assign(_2_3, [num_cluster_0, len_0], [None, None], (_v.vectorized_access_simd(_18_0, [num_cluster_0, len_0], [None, None]) == _v.vectorized_access_simd(_19_0, [num_cluster_0, len_0], [None, None])))\n    for _32_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _32_0 == 0:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(_15_0, [num_cluster_0, len_0], [None, _32_0]))\n        else:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n        _v.vectorized_assign(val_x_4, [num_cluster_0, len_0], [None, _32_0], (_v.vectorized_access_simd(val_x_3, [num_cluster_0, len_0], [None, _32_0]) + _v.vectorized_access_simd(_20_0, [num_cluster_0, len_0], [None, _32_0])))\n        _v.iterative_mux(val_x_5,_2_3,val_x_4,val_x_3,[num_cluster_0, len_0],[None, _32_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n    for _33_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _33_0 == 0:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(_16_0, [num_cluster_0, len_0], [None, _33_0]))\n        else:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n        _v.vectorized_assign(val_y_4, [num_cluster_0, len_0], [None, _33_0], (_v.vectorized_access_simd(val_y_3, [num_cluster_0, len_0], [None, _33_0]) + _v.vectorized_access_simd(_21_0, [num_cluster_0, len_0], [None, _33_0])))\n        _v.iterative_mux(val_y_5,_2_3,val_y_4,val_y_3,[num_cluster_0, len_0],[None, _33_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n    for _34_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _34_0 == 0:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(_17_0, [num_cluster_0, len_0], [None, _34_0]))\n        else:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n        _v.vectorized_assign(count_4, [num_cluster_0, len_0], [None, _34_0], (_v.vectorized_access_simd(count_3, [num_cluster_0, len_0], [None, _34_0]) + sint(1)))\n        _v.iterative_mux(count_5,_2_3,count_4,count_3,[num_cluster_0, len_0],[None, _34_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n    _v.vectorized_assign(_23_0, [num_cluster_0], [None], _v.drop_dim(val_x_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_25_0, [num_cluster_0], [None], _v.drop_dim(val_y_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_22_0, [num_cluster_0], [None], _v.drop_dim(count_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_3_2, [num_cluster_0], [None], (_v.vectorized_access_simd(_22_0, [num_cluster_0], [None]) > sint(0)))\n    _v.vectorized_assign(val_x_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_23_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.vectorized_assign(val_y_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_25_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.iterative_mux(val_x_7,_3_2,val_x_6,_23_0,[num_cluster_0],[None])\n    _v.iterative_mux(val_y_7,_3_2,val_y_6,_25_0,[num_cluster_0],[None])\n    _v.vectorized_assign(_13_0, [num_cluster_0], [None], _v.vectorized_access(val_x_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_x_2, [num_cluster_0], [None], _v.vectorized_access(_13_0, [num_cluster_0], [None]))\n    _v.vectorized_assign(_14_0, [num_cluster_0], [None], _v.vectorized_access(val_y_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_y_2, [num_cluster_0], [None], _v.vectorized_access(_14_0, [num_cluster_0], [None]))\n    _4_1 = (OUTPUT_cluster_x_2,OUTPUT_cluster_y_2,)\n    return _4_1",
                "mixed": "program.options.binary = 32\nprogram.use_edabit(True)\ndef kmeans_iteration(data_x_0, data_y_0, cluster_x_0, cluster_y_0, OUTPUT_cluster_x_0, OUTPUT_cluster_y_0, len_0, num_cluster_0, bestMap_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    bestMap_0 = [elem for elem in sint(bestMap_0)]\n\n\n    data_y_0_B = [ siv32(elem) for elem in data_y_0] if isinstance(data_y_0, list) else siv32(data_y_0)\n    data_x_0_B = [ siv32(elem) for elem in data_x_0] if isinstance(data_x_0, list) else siv32(data_x_0)\n    \n    # Shared array declarations\n    _1_3 = [None] * (len_0 * num_cluster_0)\n    _10_0 = [None] * (len_0 * num_cluster_0)\n    _11_0 = [None] * (len_0 * num_cluster_0)\n    _12_0 = [None] * (len_0 * num_cluster_0)\n    _13_0 = [None] * (num_cluster_0)\n    _14_0 = [None] * (num_cluster_0)\n    _15_0 = [None] * (num_cluster_0 * len_0)\n    _16_0 = [None] * (num_cluster_0 * len_0)\n    _17_0 = [None] * (num_cluster_0 * len_0)\n    _18_0 = [None] * (num_cluster_0 * len_0)\n    _19_0 = [None] * (num_cluster_0 * len_0)\n    _2_3 = [None] * (num_cluster_0 * len_0)\n    _20_0 = [None] * (num_cluster_0 * len_0)\n    _21_0 = [None] * (num_cluster_0 * len_0)\n    _22_0 = [None] * (num_cluster_0)\n    _23_0 = [None] * (num_cluster_0)\n    _25_0 = [None] * (num_cluster_0)\n    _29_0 = [None] * (len_0 * num_cluster_0)\n    _3_2 = [None] * (num_cluster_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0 * num_cluster_0)\n    _8_0 = [None] * (len_0 * num_cluster_0)\n    _9_0 = [None] * (len_0 * num_cluster_0)\n    OUTPUT_cluster_x_2 = [None] * (num_cluster_0)\n    OUTPUT_cluster_y_2 = [None] * (num_cluster_0)\n    bestMap_2 = [None] * (len_0 * num_cluster_0)\n    bestMap_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_5 = [None] * (len_0 * num_cluster_0)\n    count_3 = [None] * (num_cluster_0 * len_0)\n    count_4 = [None] * (num_cluster_0 * len_0)\n    count_5 = [None] * (num_cluster_0 * len_0)\n    dist_3 = [None] * (len_0 * num_cluster_0)\n    val_5 = [None] * (len_0 * num_cluster_0)\n    val_x_3 = [None] * (num_cluster_0 * len_0)\n    val_x_4 = [None] * (num_cluster_0 * len_0)\n    val_x_5 = [None] * (num_cluster_0 * len_0)\n    val_x_6 = [None] * (num_cluster_0)\n    val_x_7 = [None] * (num_cluster_0)\n    val_y_3 = [None] * (num_cluster_0 * len_0)\n    val_y_4 = [None] * (num_cluster_0 * len_0)\n    val_y_5 = [None] * (num_cluster_0 * len_0)\n    val_y_6 = [None] * (num_cluster_0)\n    val_y_7 = [None] * (num_cluster_0)\n    x_dist_3 = [None] * (len_0 * num_cluster_0)\n    x_sq_3 = [None] * (len_0 * num_cluster_0)\n    y_dist_3 = [None] * (len_0 * num_cluster_0)\n    y_sq_3 = [None] * (len_0 * num_cluster_0)\n    # Shared array convertion declarations\n    dist_3_B = [None] * (len_0 * num_cluster_0)\n    _23_0_A = [None] * (num_cluster_0)\n    _25_0_A = [None] * (num_cluster_0)\n    _22_0_A = [None] * (num_cluster_0)\n    val_x_6_B = [None] * (num_cluster_0)\n    val_y_6_B = [None] * (num_cluster_0)\n    # Function body\n    _5_0 = _v.lift(lambda indices: bestMap_0, [len_0])\n    best_dist_2 = siv32(10000)\n    _9_0 = _v.lift(lambda indices: (cluster_x_0[indices[1]]), [len_0, num_cluster_0])\n    _10_0 = _v.lift(lambda indices: (data_x_0[indices[0]]), [len_0, num_cluster_0])\n    _11_0 = _v.lift(lambda indices: (cluster_y_0[indices[1]]), [len_0, num_cluster_0])\n    _12_0 = _v.lift(lambda indices: (data_y_0[indices[0]]), [len_0, num_cluster_0])\n    _29_0 = _v.lift(lambda indices: indices[1], [len_0, num_cluster_0])\n    _13_0 = _v.lift(lambda indices: OUTPUT_cluster_x_0, [num_cluster_0])\n    _14_0 = _v.lift(lambda indices: OUTPUT_cluster_y_0, [num_cluster_0])\n    val_x_2 = siv32(0)\n    val_y_2 = siv32(0)\n    count_2 = siv32(0)\n    _18_0 = _v.lift(lambda indices: indices[0], [num_cluster_0, len_0])\n    _20_0 = _v.lift(lambda indices: (data_x_0[indices[1]]), [num_cluster_0, len_0]);_20_0_B = _v.lift(lambda indices: (data_x_0_B[indices[1]]), [num_cluster_0, len_0])\n    _21_0 = _v.lift(lambda indices: (data_y_0[indices[1]]), [num_cluster_0, len_0]);_21_0_B = _v.lift(lambda indices: (data_y_0_B[indices[1]]), [num_cluster_0, len_0])\n    _8_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [len_0], [None]), [len_0, num_cluster_0])\n    _7_0 = _v.lift(lambda indices: best_dist_2, [len_0, num_cluster_0])\n    _v.vectorized_assign(x_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_9_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_10_0, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_11_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_12_0, [len_0, num_cluster_0], [None, None])))\n    _15_0 = _v.lift(lambda indices: val_x_2, [num_cluster_0, len_0])\n    _16_0 = _v.lift(lambda indices: val_y_2, [num_cluster_0, len_0])\n    _17_0 = _v.lift(lambda indices: count_2, [num_cluster_0, len_0])\n    _v.vectorized_assign(x_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_sq_3, [len_0, num_cluster_0], [None, None]) + _v.vectorized_access_simd(y_sq_3, [len_0, num_cluster_0], [None, None])))\n    for _random_iter in range(0,len(dist_3)):\n      dist_3_B[_random_iter] = _v.convertion_check(dist_3[_random_iter])\n    dist_3_B = siv32(dist_3_B)\n    for _30_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _30_0 == 0:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(_7_0, [len_0, num_cluster_0], [None, _30_0]))\n        else:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n        _v.vectorized_assign(_1_3, [len_0, num_cluster_0], [None, _30_0], (_v.vectorized_access_simd(dist_3, [len_0, num_cluster_0], [None, _30_0]) < _v.vectorized_access_simd(best_dist_3, [len_0, num_cluster_0], [None, _30_0])))\n        _v.iterative_mux(best_dist_5,_1_3,dist_3,best_dist_3,[len_0, num_cluster_0],[None, _30_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n    for _31_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _31_0 == 0:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(_8_0, [len_0, num_cluster_0], [None, _31_0]))\n        else:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n        _v.iterative_mux(val_5,_1_3,_29_0,bestMap_2,[len_0, num_cluster_0],[None, _31_0])\n        _v.vectorized_assign((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(val_5, [len_0, num_cluster_0], [None, _31_0])); _v.vectorized_assign(bestMap_3, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n    _v.vectorized_assign(_6_0, [len_0], [None], _v.drop_dim(bestMap_3, [len_0, num_cluster_0]))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [len_0], [indices[1]]), [num_cluster_0, len_0])\n    _v.vectorized_assign(_2_3, [num_cluster_0, len_0], [None, None], (_v.vectorized_access_simd(_18_0, [num_cluster_0, len_0], [None, None]) == _v.vectorized_access_simd(_19_0, [num_cluster_0, len_0], [None, None])))\n    for _32_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _32_0 == 0:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(_15_0, [num_cluster_0, len_0], [None, _32_0]))\n        else:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n        _v.vectorized_assign(val_x_4, [num_cluster_0, len_0], [None, _32_0], (_v.vectorized_access_simd(val_x_3, [num_cluster_0, len_0], [None, _32_0]) + _v.vectorized_access_simd(_20_0_B, [num_cluster_0, len_0], [None, _32_0])))\n        _v.iterative_mux(val_x_5,_2_3,val_x_4,val_x_3,[num_cluster_0, len_0],[None, _32_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n    for _33_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _33_0 == 0:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(_16_0, [num_cluster_0, len_0], [None, _33_0]))\n        else:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n        _v.vectorized_assign(val_y_4, [num_cluster_0, len_0], [None, _33_0], (_v.vectorized_access_simd(val_y_3, [num_cluster_0, len_0], [None, _33_0]) + _v.vectorized_access_simd(_21_0_B, [num_cluster_0, len_0], [None, _33_0])))\n        _v.iterative_mux(val_y_5,_2_3,val_y_4,val_y_3,[num_cluster_0, len_0],[None, _33_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n    for _34_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _34_0 == 0:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(_17_0, [num_cluster_0, len_0], [None, _34_0]))\n        else:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n        _v.vectorized_assign(count_4, [num_cluster_0, len_0], [None, _34_0], (_v.vectorized_access_simd(count_3, [num_cluster_0, len_0], [None, _34_0]) + siv32(1)))\n        _v.iterative_mux(count_5,_2_3,count_4,count_3,[num_cluster_0, len_0],[None, _34_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n    _v.vectorized_assign(_23_0, [num_cluster_0], [None], _v.drop_dim(val_x_5, [num_cluster_0, len_0]));_23_0_A[c_2] = sint(_23_0[c_2])\n    _v.vectorized_assign(_25_0, [num_cluster_0], [None], _v.drop_dim(val_y_5, [num_cluster_0, len_0]));_25_0_A[c_2] = sint(_25_0[c_2])\n    _v.vectorized_assign(_22_0, [num_cluster_0], [None], _v.drop_dim(count_5, [num_cluster_0, len_0]));_22_0_A[c_2] = sint(_22_0[c_2])\n    _v.vectorized_assign(_3_2, [num_cluster_0], [None], (_v.vectorized_access_simd(_22_0, [num_cluster_0], [None]) > siv32(0)))\n    _v.vectorized_assign(val_x_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_23_0_A, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0_A, [num_cluster_0], [None])));val_x_6_B[c_2] = _v.convertion_check(val_x_6[c_2])\n    _v.vectorized_assign(val_y_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_25_0_A, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0_A, [num_cluster_0], [None])));val_y_6_B[c_2] = _v.convertion_check(val_y_6[c_2])\n    _v.iterative_mux(val_x_7,_3_2,val_x_6_B,_23_0,[num_cluster_0],[None])\n    _v.iterative_mux(val_y_7,_3_2,val_y_6_B,_25_0,[num_cluster_0],[None])\n    _v.vectorized_assign(_13_0, [num_cluster_0], [None], _v.vectorized_access(val_x_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_x_2, [num_cluster_0], [None], _v.vectorized_access(_13_0, [num_cluster_0], [None]))\n    _v.vectorized_assign(_14_0, [num_cluster_0], [None], _v.vectorized_access(val_y_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_y_2, [num_cluster_0], [None], _v.vectorized_access(_14_0, [num_cluster_0], [None]))\n    _4_1 = (OUTPUT_cluster_x_2,OUTPUT_cluster_y_2,)\n    return _4_1"
            },
            "time": {
                "A": "program.options.binary = 32\ndef kmeans_iteration(data_x_0, data_y_0, cluster_x_0, cluster_y_0, OUTPUT_cluster_x_0, OUTPUT_cluster_y_0, len_0, num_cluster_0, bestMap_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_0 * num_cluster_0)\n    _10_0 = [None] * (len_0 * num_cluster_0)\n    _11_0 = [None] * (len_0 * num_cluster_0)\n    _12_0 = [None] * (len_0 * num_cluster_0)\n    _13_0 = [None] * (num_cluster_0)\n    _14_0 = [None] * (num_cluster_0)\n    _15_0 = [None] * (num_cluster_0 * len_0)\n    _16_0 = [None] * (num_cluster_0 * len_0)\n    _17_0 = [None] * (num_cluster_0 * len_0)\n    _18_0 = [None] * (num_cluster_0 * len_0)\n    _19_0 = [None] * (num_cluster_0 * len_0)\n    _2_3 = [None] * (num_cluster_0 * len_0)\n    _20_0 = [None] * (num_cluster_0 * len_0)\n    _21_0 = [None] * (num_cluster_0 * len_0)\n    _22_0 = [None] * (num_cluster_0)\n    _23_0 = [None] * (num_cluster_0)\n    _25_0 = [None] * (num_cluster_0)\n    _29_0 = [None] * (len_0 * num_cluster_0)\n    _3_2 = [None] * (num_cluster_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0 * num_cluster_0)\n    _8_0 = [None] * (len_0 * num_cluster_0)\n    _9_0 = [None] * (len_0 * num_cluster_0)\n    OUTPUT_cluster_x_2 = [None] * (num_cluster_0)\n    OUTPUT_cluster_y_2 = [None] * (num_cluster_0)\n    bestMap_2 = [None] * (len_0 * num_cluster_0)\n    bestMap_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_5 = [None] * (len_0 * num_cluster_0)\n    count_3 = [None] * (num_cluster_0 * len_0)\n    count_4 = [None] * (num_cluster_0 * len_0)\n    count_5 = [None] * (num_cluster_0 * len_0)\n    dist_3 = [None] * (len_0 * num_cluster_0)\n    val_5 = [None] * (len_0 * num_cluster_0)\n    val_x_3 = [None] * (num_cluster_0 * len_0)\n    val_x_4 = [None] * (num_cluster_0 * len_0)\n    val_x_5 = [None] * (num_cluster_0 * len_0)\n    val_x_6 = [None] * (num_cluster_0)\n    val_x_7 = [None] * (num_cluster_0)\n    val_y_3 = [None] * (num_cluster_0 * len_0)\n    val_y_4 = [None] * (num_cluster_0 * len_0)\n    val_y_5 = [None] * (num_cluster_0 * len_0)\n    val_y_6 = [None] * (num_cluster_0)\n    val_y_7 = [None] * (num_cluster_0)\n    x_dist_3 = [None] * (len_0 * num_cluster_0)\n    x_sq_3 = [None] * (len_0 * num_cluster_0)\n    y_dist_3 = [None] * (len_0 * num_cluster_0)\n    y_sq_3 = [None] * (len_0 * num_cluster_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: bestMap_0, [len_0])\n    best_dist_2 = sint(10000)\n    _9_0 = _v.lift(lambda indices: (cluster_x_0[indices[1]]), [len_0, num_cluster_0])\n    _10_0 = _v.lift(lambda indices: (data_x_0[indices[0]]), [len_0, num_cluster_0])\n    _11_0 = _v.lift(lambda indices: (cluster_y_0[indices[1]]), [len_0, num_cluster_0])\n    _12_0 = _v.lift(lambda indices: (data_y_0[indices[0]]), [len_0, num_cluster_0])\n    _29_0 = _v.lift(lambda indices: indices[1], [len_0, num_cluster_0])\n    _13_0 = _v.lift(lambda indices: OUTPUT_cluster_x_0, [num_cluster_0])\n    _14_0 = _v.lift(lambda indices: OUTPUT_cluster_y_0, [num_cluster_0])\n    val_x_2 = sint(0)\n    val_y_2 = sint(0)\n    count_2 = sint(0)\n    _18_0 = _v.lift(lambda indices: indices[0], [num_cluster_0, len_0])\n    _20_0 = _v.lift(lambda indices: (data_x_0[indices[1]]), [num_cluster_0, len_0])\n    _21_0 = _v.lift(lambda indices: (data_y_0[indices[1]]), [num_cluster_0, len_0])\n    _8_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [len_0], [None]), [len_0, num_cluster_0])\n    _7_0 = _v.lift(lambda indices: best_dist_2, [len_0, num_cluster_0])\n    _v.vectorized_assign(x_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_9_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_10_0, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_11_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_12_0, [len_0, num_cluster_0], [None, None])))\n    _15_0 = _v.lift(lambda indices: val_x_2, [num_cluster_0, len_0])\n    _16_0 = _v.lift(lambda indices: val_y_2, [num_cluster_0, len_0])\n    _17_0 = _v.lift(lambda indices: count_2, [num_cluster_0, len_0])\n    _v.vectorized_assign(x_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_sq_3, [len_0, num_cluster_0], [None, None]) + _v.vectorized_access_simd(y_sq_3, [len_0, num_cluster_0], [None, None])))\n    for _30_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _30_0 == 0:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(_7_0, [len_0, num_cluster_0], [None, _30_0]))\n        else:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n        _v.vectorized_assign(_1_3, [len_0, num_cluster_0], [None, _30_0], (_v.vectorized_access_simd(dist_3, [len_0, num_cluster_0], [None, _30_0]) < _v.vectorized_access_simd(best_dist_3, [len_0, num_cluster_0], [None, _30_0])))\n        _v.iterative_mux(best_dist_5,_1_3,dist_3,best_dist_3,[len_0, num_cluster_0],[None, _30_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n    for _31_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _31_0 == 0:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(_8_0, [len_0, num_cluster_0], [None, _31_0]))\n        else:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n        _v.iterative_mux(val_5,_1_3,_29_0,bestMap_2,[len_0, num_cluster_0],[None, _31_0])\n        _v.vectorized_assign((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(val_5, [len_0, num_cluster_0], [None, _31_0])); _v.vectorized_assign(bestMap_3, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n    _v.vectorized_assign(_6_0, [len_0], [None], _v.drop_dim(bestMap_3, [len_0, num_cluster_0]))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [len_0], [indices[1]]), [num_cluster_0, len_0])\n    _v.vectorized_assign(_2_3, [num_cluster_0, len_0], [None, None], (_v.vectorized_access_simd(_18_0, [num_cluster_0, len_0], [None, None]) == _v.vectorized_access_simd(_19_0, [num_cluster_0, len_0], [None, None])))\n    for _32_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _32_0 == 0:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(_15_0, [num_cluster_0, len_0], [None, _32_0]))\n        else:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n        _v.vectorized_assign(val_x_4, [num_cluster_0, len_0], [None, _32_0], (_v.vectorized_access_simd(val_x_3, [num_cluster_0, len_0], [None, _32_0]) + _v.vectorized_access_simd(_20_0, [num_cluster_0, len_0], [None, _32_0])))\n        _v.iterative_mux(val_x_5,_2_3,val_x_4,val_x_3,[num_cluster_0, len_0],[None, _32_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n    for _33_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _33_0 == 0:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(_16_0, [num_cluster_0, len_0], [None, _33_0]))\n        else:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n        _v.vectorized_assign(val_y_4, [num_cluster_0, len_0], [None, _33_0], (_v.vectorized_access_simd(val_y_3, [num_cluster_0, len_0], [None, _33_0]) + _v.vectorized_access_simd(_21_0, [num_cluster_0, len_0], [None, _33_0])))\n        _v.iterative_mux(val_y_5,_2_3,val_y_4,val_y_3,[num_cluster_0, len_0],[None, _33_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n    for _34_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _34_0 == 0:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(_17_0, [num_cluster_0, len_0], [None, _34_0]))\n        else:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n        _v.vectorized_assign(count_4, [num_cluster_0, len_0], [None, _34_0], (_v.vectorized_access_simd(count_3, [num_cluster_0, len_0], [None, _34_0]) + sint(1)))\n        _v.iterative_mux(count_5,_2_3,count_4,count_3,[num_cluster_0, len_0],[None, _34_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n    _v.vectorized_assign(_23_0, [num_cluster_0], [None], _v.drop_dim(val_x_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_25_0, [num_cluster_0], [None], _v.drop_dim(val_y_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_22_0, [num_cluster_0], [None], _v.drop_dim(count_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_3_2, [num_cluster_0], [None], (_v.vectorized_access_simd(_22_0, [num_cluster_0], [None]) > sint(0)))\n    _v.vectorized_assign(val_x_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_23_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.vectorized_assign(val_y_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_25_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.iterative_mux(val_x_7,_3_2,val_x_6,_23_0,[num_cluster_0],[None])\n    _v.iterative_mux(val_y_7,_3_2,val_y_6,_25_0,[num_cluster_0],[None])\n    _v.vectorized_assign(_13_0, [num_cluster_0], [None], _v.vectorized_access(val_x_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_x_2, [num_cluster_0], [None], _v.vectorized_access(_13_0, [num_cluster_0], [None]))\n    _v.vectorized_assign(_14_0, [num_cluster_0], [None], _v.vectorized_access(val_y_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_y_2, [num_cluster_0], [None], _v.vectorized_access(_14_0, [num_cluster_0], [None]))\n    _4_1 = (OUTPUT_cluster_x_2,OUTPUT_cluster_y_2,)\n    return _4_1",
                "B": "N/A",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef kmeans_iteration(data_x_0, data_y_0, cluster_x_0, cluster_y_0, OUTPUT_cluster_x_0, OUTPUT_cluster_y_0, len_0, num_cluster_0, bestMap_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_0 * num_cluster_0)\n    _10_0 = [None] * (len_0 * num_cluster_0)\n    _11_0 = [None] * (len_0 * num_cluster_0)\n    _12_0 = [None] * (len_0 * num_cluster_0)\n    _13_0 = [None] * (num_cluster_0)\n    _14_0 = [None] * (num_cluster_0)\n    _15_0 = [None] * (num_cluster_0 * len_0)\n    _16_0 = [None] * (num_cluster_0 * len_0)\n    _17_0 = [None] * (num_cluster_0 * len_0)\n    _18_0 = [None] * (num_cluster_0 * len_0)\n    _19_0 = [None] * (num_cluster_0 * len_0)\n    _2_3 = [None] * (num_cluster_0 * len_0)\n    _20_0 = [None] * (num_cluster_0 * len_0)\n    _21_0 = [None] * (num_cluster_0 * len_0)\n    _22_0 = [None] * (num_cluster_0)\n    _23_0 = [None] * (num_cluster_0)\n    _25_0 = [None] * (num_cluster_0)\n    _29_0 = [None] * (len_0 * num_cluster_0)\n    _3_2 = [None] * (num_cluster_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0 * num_cluster_0)\n    _8_0 = [None] * (len_0 * num_cluster_0)\n    _9_0 = [None] * (len_0 * num_cluster_0)\n    OUTPUT_cluster_x_2 = [None] * (num_cluster_0)\n    OUTPUT_cluster_y_2 = [None] * (num_cluster_0)\n    bestMap_2 = [None] * (len_0 * num_cluster_0)\n    bestMap_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_5 = [None] * (len_0 * num_cluster_0)\n    count_3 = [None] * (num_cluster_0 * len_0)\n    count_4 = [None] * (num_cluster_0 * len_0)\n    count_5 = [None] * (num_cluster_0 * len_0)\n    dist_3 = [None] * (len_0 * num_cluster_0)\n    val_5 = [None] * (len_0 * num_cluster_0)\n    val_x_3 = [None] * (num_cluster_0 * len_0)\n    val_x_4 = [None] * (num_cluster_0 * len_0)\n    val_x_5 = [None] * (num_cluster_0 * len_0)\n    val_x_6 = [None] * (num_cluster_0)\n    val_x_7 = [None] * (num_cluster_0)\n    val_y_3 = [None] * (num_cluster_0 * len_0)\n    val_y_4 = [None] * (num_cluster_0 * len_0)\n    val_y_5 = [None] * (num_cluster_0 * len_0)\n    val_y_6 = [None] * (num_cluster_0)\n    val_y_7 = [None] * (num_cluster_0)\n    x_dist_3 = [None] * (len_0 * num_cluster_0)\n    x_sq_3 = [None] * (len_0 * num_cluster_0)\n    y_dist_3 = [None] * (len_0 * num_cluster_0)\n    y_sq_3 = [None] * (len_0 * num_cluster_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: bestMap_0, [len_0])\n    best_dist_2 = sint(10000)\n    _9_0 = _v.lift(lambda indices: (cluster_x_0[indices[1]]), [len_0, num_cluster_0])\n    _10_0 = _v.lift(lambda indices: (data_x_0[indices[0]]), [len_0, num_cluster_0])\n    _11_0 = _v.lift(lambda indices: (cluster_y_0[indices[1]]), [len_0, num_cluster_0])\n    _12_0 = _v.lift(lambda indices: (data_y_0[indices[0]]), [len_0, num_cluster_0])\n    _29_0 = _v.lift(lambda indices: indices[1], [len_0, num_cluster_0])\n    _13_0 = _v.lift(lambda indices: OUTPUT_cluster_x_0, [num_cluster_0])\n    _14_0 = _v.lift(lambda indices: OUTPUT_cluster_y_0, [num_cluster_0])\n    val_x_2 = sint(0)\n    val_y_2 = sint(0)\n    count_2 = sint(0)\n    _18_0 = _v.lift(lambda indices: indices[0], [num_cluster_0, len_0])\n    _20_0 = _v.lift(lambda indices: (data_x_0[indices[1]]), [num_cluster_0, len_0])\n    _21_0 = _v.lift(lambda indices: (data_y_0[indices[1]]), [num_cluster_0, len_0])\n    _8_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [len_0], [None]), [len_0, num_cluster_0])\n    _7_0 = _v.lift(lambda indices: best_dist_2, [len_0, num_cluster_0])\n    _v.vectorized_assign(x_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_9_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_10_0, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_11_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_12_0, [len_0, num_cluster_0], [None, None])))\n    _15_0 = _v.lift(lambda indices: val_x_2, [num_cluster_0, len_0])\n    _16_0 = _v.lift(lambda indices: val_y_2, [num_cluster_0, len_0])\n    _17_0 = _v.lift(lambda indices: count_2, [num_cluster_0, len_0])\n    _v.vectorized_assign(x_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_sq_3, [len_0, num_cluster_0], [None, None]) + _v.vectorized_access_simd(y_sq_3, [len_0, num_cluster_0], [None, None])))\n    for _30_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _30_0 == 0:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(_7_0, [len_0, num_cluster_0], [None, _30_0]))\n        else:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n        _v.vectorized_assign(_1_3, [len_0, num_cluster_0], [None, _30_0], (_v.vectorized_access_simd(dist_3, [len_0, num_cluster_0], [None, _30_0]) < _v.vectorized_access_simd(best_dist_3, [len_0, num_cluster_0], [None, _30_0])))\n        _v.iterative_mux(best_dist_5,_1_3,dist_3,best_dist_3,[len_0, num_cluster_0],[None, _30_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n    for _31_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _31_0 == 0:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(_8_0, [len_0, num_cluster_0], [None, _31_0]))\n        else:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n        _v.iterative_mux(val_5,_1_3,_29_0,bestMap_2,[len_0, num_cluster_0],[None, _31_0])\n        _v.vectorized_assign((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(val_5, [len_0, num_cluster_0], [None, _31_0])); _v.vectorized_assign(bestMap_3, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n    _v.vectorized_assign(_6_0, [len_0], [None], _v.drop_dim(bestMap_3, [len_0, num_cluster_0]))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [len_0], [indices[1]]), [num_cluster_0, len_0])\n    _v.vectorized_assign(_2_3, [num_cluster_0, len_0], [None, None], (_v.vectorized_access_simd(_18_0, [num_cluster_0, len_0], [None, None]) == _v.vectorized_access_simd(_19_0, [num_cluster_0, len_0], [None, None])))\n    for _32_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _32_0 == 0:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(_15_0, [num_cluster_0, len_0], [None, _32_0]))\n        else:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n        _v.vectorized_assign(val_x_4, [num_cluster_0, len_0], [None, _32_0], (_v.vectorized_access_simd(val_x_3, [num_cluster_0, len_0], [None, _32_0]) + _v.vectorized_access_simd(_20_0, [num_cluster_0, len_0], [None, _32_0])))\n        _v.iterative_mux(val_x_5,_2_3,val_x_4,val_x_3,[num_cluster_0, len_0],[None, _32_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n    for _33_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _33_0 == 0:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(_16_0, [num_cluster_0, len_0], [None, _33_0]))\n        else:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n        _v.vectorized_assign(val_y_4, [num_cluster_0, len_0], [None, _33_0], (_v.vectorized_access_simd(val_y_3, [num_cluster_0, len_0], [None, _33_0]) + _v.vectorized_access_simd(_21_0, [num_cluster_0, len_0], [None, _33_0])))\n        _v.iterative_mux(val_y_5,_2_3,val_y_4,val_y_3,[num_cluster_0, len_0],[None, _33_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n    for _34_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _34_0 == 0:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(_17_0, [num_cluster_0, len_0], [None, _34_0]))\n        else:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n        _v.vectorized_assign(count_4, [num_cluster_0, len_0], [None, _34_0], (_v.vectorized_access_simd(count_3, [num_cluster_0, len_0], [None, _34_0]) + sint(1)))\n        _v.iterative_mux(count_5,_2_3,count_4,count_3,[num_cluster_0, len_0],[None, _34_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n    _v.vectorized_assign(_23_0, [num_cluster_0], [None], _v.drop_dim(val_x_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_25_0, [num_cluster_0], [None], _v.drop_dim(val_y_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_22_0, [num_cluster_0], [None], _v.drop_dim(count_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_3_2, [num_cluster_0], [None], (_v.vectorized_access_simd(_22_0, [num_cluster_0], [None]) > sint(0)))\n    _v.vectorized_assign(val_x_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_23_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.vectorized_assign(val_y_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_25_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.iterative_mux(val_x_7,_3_2,val_x_6,_23_0,[num_cluster_0],[None])\n    _v.iterative_mux(val_y_7,_3_2,val_y_6,_25_0,[num_cluster_0],[None])\n    _v.vectorized_assign(_13_0, [num_cluster_0], [None], _v.vectorized_access(val_x_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_x_2, [num_cluster_0], [None], _v.vectorized_access(_13_0, [num_cluster_0], [None]))\n    _v.vectorized_assign(_14_0, [num_cluster_0], [None], _v.vectorized_access(val_y_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_y_2, [num_cluster_0], [None], _v.vectorized_access(_14_0, [num_cluster_0], [None]))\n    _4_1 = (OUTPUT_cluster_x_2,OUTPUT_cluster_y_2,)\n    return _4_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef kmeans_iteration(data_x_0, data_y_0, cluster_x_0, cluster_y_0, OUTPUT_cluster_x_0, OUTPUT_cluster_y_0, len_0, num_cluster_0, bestMap_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_0 * num_cluster_0)\n    _10_0 = [None] * (len_0 * num_cluster_0)\n    _11_0 = [None] * (len_0 * num_cluster_0)\n    _12_0 = [None] * (len_0 * num_cluster_0)\n    _13_0 = [None] * (num_cluster_0)\n    _14_0 = [None] * (num_cluster_0)\n    _15_0 = [None] * (num_cluster_0 * len_0)\n    _16_0 = [None] * (num_cluster_0 * len_0)\n    _17_0 = [None] * (num_cluster_0 * len_0)\n    _18_0 = [None] * (num_cluster_0 * len_0)\n    _19_0 = [None] * (num_cluster_0 * len_0)\n    _2_3 = [None] * (num_cluster_0 * len_0)\n    _20_0 = [None] * (num_cluster_0 * len_0)\n    _21_0 = [None] * (num_cluster_0 * len_0)\n    _22_0 = [None] * (num_cluster_0)\n    _23_0 = [None] * (num_cluster_0)\n    _25_0 = [None] * (num_cluster_0)\n    _29_0 = [None] * (len_0 * num_cluster_0)\n    _3_2 = [None] * (num_cluster_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0 * num_cluster_0)\n    _8_0 = [None] * (len_0 * num_cluster_0)\n    _9_0 = [None] * (len_0 * num_cluster_0)\n    OUTPUT_cluster_x_2 = [None] * (num_cluster_0)\n    OUTPUT_cluster_y_2 = [None] * (num_cluster_0)\n    bestMap_2 = [None] * (len_0 * num_cluster_0)\n    bestMap_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_5 = [None] * (len_0 * num_cluster_0)\n    count_3 = [None] * (num_cluster_0 * len_0)\n    count_4 = [None] * (num_cluster_0 * len_0)\n    count_5 = [None] * (num_cluster_0 * len_0)\n    dist_3 = [None] * (len_0 * num_cluster_0)\n    val_5 = [None] * (len_0 * num_cluster_0)\n    val_x_3 = [None] * (num_cluster_0 * len_0)\n    val_x_4 = [None] * (num_cluster_0 * len_0)\n    val_x_5 = [None] * (num_cluster_0 * len_0)\n    val_x_6 = [None] * (num_cluster_0)\n    val_x_7 = [None] * (num_cluster_0)\n    val_y_3 = [None] * (num_cluster_0 * len_0)\n    val_y_4 = [None] * (num_cluster_0 * len_0)\n    val_y_5 = [None] * (num_cluster_0 * len_0)\n    val_y_6 = [None] * (num_cluster_0)\n    val_y_7 = [None] * (num_cluster_0)\n    x_dist_3 = [None] * (len_0 * num_cluster_0)\n    x_sq_3 = [None] * (len_0 * num_cluster_0)\n    y_dist_3 = [None] * (len_0 * num_cluster_0)\n    y_sq_3 = [None] * (len_0 * num_cluster_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _5_0 = _v.lift(lambda indices: bestMap_0, [len_0])\n    best_dist_2 = sint(10000)\n    _9_0 = _v.lift(lambda indices: (cluster_x_0[indices[1]]), [len_0, num_cluster_0])\n    _10_0 = _v.lift(lambda indices: (data_x_0[indices[0]]), [len_0, num_cluster_0])\n    _11_0 = _v.lift(lambda indices: (cluster_y_0[indices[1]]), [len_0, num_cluster_0])\n    _12_0 = _v.lift(lambda indices: (data_y_0[indices[0]]), [len_0, num_cluster_0])\n    _29_0 = _v.lift(lambda indices: indices[1], [len_0, num_cluster_0])\n    _13_0 = _v.lift(lambda indices: OUTPUT_cluster_x_0, [num_cluster_0])\n    _14_0 = _v.lift(lambda indices: OUTPUT_cluster_y_0, [num_cluster_0])\n    val_x_2 = sint(0)\n    val_y_2 = sint(0)\n    count_2 = sint(0)\n    _18_0 = _v.lift(lambda indices: indices[0], [num_cluster_0, len_0])\n    _20_0 = _v.lift(lambda indices: (data_x_0[indices[1]]), [num_cluster_0, len_0])\n    _21_0 = _v.lift(lambda indices: (data_y_0[indices[1]]), [num_cluster_0, len_0])\n    _8_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [len_0], [None]), [len_0, num_cluster_0])\n    _7_0 = _v.lift(lambda indices: best_dist_2, [len_0, num_cluster_0])\n    _v.vectorized_assign(x_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_9_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_10_0, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_11_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_12_0, [len_0, num_cluster_0], [None, None])))\n    _15_0 = _v.lift(lambda indices: val_x_2, [num_cluster_0, len_0])\n    _16_0 = _v.lift(lambda indices: val_y_2, [num_cluster_0, len_0])\n    _17_0 = _v.lift(lambda indices: count_2, [num_cluster_0, len_0])\n    _v.vectorized_assign(x_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_sq_3, [len_0, num_cluster_0], [None, None]) + _v.vectorized_access_simd(y_sq_3, [len_0, num_cluster_0], [None, None])))\n    for _30_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _30_0 == 0:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(_7_0, [len_0, num_cluster_0], [None, _30_0]))\n        else:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n        _v.vectorized_assign(_1_3, [len_0, num_cluster_0], [None, _30_0], (_v.vectorized_access_simd(dist_3, [len_0, num_cluster_0], [None, _30_0]) < _v.vectorized_access_simd(best_dist_3, [len_0, num_cluster_0], [None, _30_0])))\n        _v.iterative_mux(best_dist_5,_1_3,dist_3,best_dist_3,[len_0, num_cluster_0],[None, _30_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n    for _31_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _31_0 == 0:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(_8_0, [len_0, num_cluster_0], [None, _31_0]))\n        else:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n        _v.iterative_mux(val_5,_1_3,_29_0,bestMap_2,[len_0, num_cluster_0],[None, _31_0])\n        _v.vectorized_assign((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(val_5, [len_0, num_cluster_0], [None, _31_0])); _v.vectorized_assign(bestMap_3, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n    _v.vectorized_assign(_6_0, [len_0], [None], _v.drop_dim(bestMap_3, [len_0, num_cluster_0]))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [len_0], [indices[1]]), [num_cluster_0, len_0])\n    _v.vectorized_assign(_2_3, [num_cluster_0, len_0], [None, None], (_v.vectorized_access_simd(_18_0, [num_cluster_0, len_0], [None, None]) == _v.vectorized_access_simd(_19_0, [num_cluster_0, len_0], [None, None])))\n    for _32_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _32_0 == 0:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(_15_0, [num_cluster_0, len_0], [None, _32_0]))\n        else:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n        _v.vectorized_assign(val_x_4, [num_cluster_0, len_0], [None, _32_0], (_v.vectorized_access_simd(val_x_3, [num_cluster_0, len_0], [None, _32_0]) + _v.vectorized_access_simd(_20_0, [num_cluster_0, len_0], [None, _32_0])))\n        _v.iterative_mux(val_x_5,_2_3,val_x_4,val_x_3,[num_cluster_0, len_0],[None, _32_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n    for _33_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _33_0 == 0:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(_16_0, [num_cluster_0, len_0], [None, _33_0]))\n        else:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n        _v.vectorized_assign(val_y_4, [num_cluster_0, len_0], [None, _33_0], (_v.vectorized_access_simd(val_y_3, [num_cluster_0, len_0], [None, _33_0]) + _v.vectorized_access_simd(_21_0, [num_cluster_0, len_0], [None, _33_0])))\n        _v.iterative_mux(val_y_5,_2_3,val_y_4,val_y_3,[num_cluster_0, len_0],[None, _33_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n    for _34_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _34_0 == 0:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(_17_0, [num_cluster_0, len_0], [None, _34_0]))\n        else:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n        _v.vectorized_assign(count_4, [num_cluster_0, len_0], [None, _34_0], (_v.vectorized_access_simd(count_3, [num_cluster_0, len_0], [None, _34_0]) + sint(1)))\n        _v.iterative_mux(count_5,_2_3,count_4,count_3,[num_cluster_0, len_0],[None, _34_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n    _v.vectorized_assign(_23_0, [num_cluster_0], [None], _v.drop_dim(val_x_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_25_0, [num_cluster_0], [None], _v.drop_dim(val_y_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_22_0, [num_cluster_0], [None], _v.drop_dim(count_5, [num_cluster_0, len_0]))\n    _v.vectorized_assign(_3_2, [num_cluster_0], [None], (_v.vectorized_access_simd(_22_0, [num_cluster_0], [None]) > sint(0)))\n    _v.vectorized_assign(val_x_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_23_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.vectorized_assign(val_y_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_25_0, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0, [num_cluster_0], [None])))\n    _v.iterative_mux(val_x_7,_3_2,val_x_6,_23_0,[num_cluster_0],[None])\n    _v.iterative_mux(val_y_7,_3_2,val_y_6,_25_0,[num_cluster_0],[None])\n    _v.vectorized_assign(_13_0, [num_cluster_0], [None], _v.vectorized_access(val_x_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_x_2, [num_cluster_0], [None], _v.vectorized_access(_13_0, [num_cluster_0], [None]))\n    _v.vectorized_assign(_14_0, [num_cluster_0], [None], _v.vectorized_access(val_y_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_y_2, [num_cluster_0], [None], _v.vectorized_access(_14_0, [num_cluster_0], [None]))\n    _4_1 = (OUTPUT_cluster_x_2,OUTPUT_cluster_y_2,)\n    return _4_1",
                "mixed": "program.options.binary = 32\nprogram.use_edabit(True)\ndef kmeans_iteration(data_x_0, data_y_0, cluster_x_0, cluster_y_0, OUTPUT_cluster_x_0, OUTPUT_cluster_y_0, len_0, num_cluster_0, bestMap_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    bestMap_0 = [elem for elem in sint(bestMap_0)]\n\n\n    data_y_0_B = [ siv32(elem) for elem in data_y_0] if isinstance(data_y_0, list) else siv32(data_y_0)\n    data_x_0_B = [ siv32(elem) for elem in data_x_0] if isinstance(data_x_0, list) else siv32(data_x_0)\n    \n    # Shared array declarations\n    _1_3 = [None] * (len_0 * num_cluster_0)\n    _10_0 = [None] * (len_0 * num_cluster_0)\n    _11_0 = [None] * (len_0 * num_cluster_0)\n    _12_0 = [None] * (len_0 * num_cluster_0)\n    _13_0 = [None] * (num_cluster_0)\n    _14_0 = [None] * (num_cluster_0)\n    _15_0 = [None] * (num_cluster_0 * len_0)\n    _16_0 = [None] * (num_cluster_0 * len_0)\n    _17_0 = [None] * (num_cluster_0 * len_0)\n    _18_0 = [None] * (num_cluster_0 * len_0)\n    _19_0 = [None] * (num_cluster_0 * len_0)\n    _2_3 = [None] * (num_cluster_0 * len_0)\n    _20_0 = [None] * (num_cluster_0 * len_0)\n    _21_0 = [None] * (num_cluster_0 * len_0)\n    _22_0 = [None] * (num_cluster_0)\n    _23_0 = [None] * (num_cluster_0)\n    _25_0 = [None] * (num_cluster_0)\n    _29_0 = [None] * (len_0 * num_cluster_0)\n    _3_2 = [None] * (num_cluster_0)\n    _5_0 = [None] * (len_0)\n    _6_0 = [None] * (len_0)\n    _7_0 = [None] * (len_0 * num_cluster_0)\n    _8_0 = [None] * (len_0 * num_cluster_0)\n    _9_0 = [None] * (len_0 * num_cluster_0)\n    OUTPUT_cluster_x_2 = [None] * (num_cluster_0)\n    OUTPUT_cluster_y_2 = [None] * (num_cluster_0)\n    bestMap_2 = [None] * (len_0 * num_cluster_0)\n    bestMap_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_3 = [None] * (len_0 * num_cluster_0)\n    best_dist_5 = [None] * (len_0 * num_cluster_0)\n    count_3 = [None] * (num_cluster_0 * len_0)\n    count_4 = [None] * (num_cluster_0 * len_0)\n    count_5 = [None] * (num_cluster_0 * len_0)\n    dist_3 = [None] * (len_0 * num_cluster_0)\n    val_5 = [None] * (len_0 * num_cluster_0)\n    val_x_3 = [None] * (num_cluster_0 * len_0)\n    val_x_4 = [None] * (num_cluster_0 * len_0)\n    val_x_5 = [None] * (num_cluster_0 * len_0)\n    val_x_6 = [None] * (num_cluster_0)\n    val_x_7 = [None] * (num_cluster_0)\n    val_y_3 = [None] * (num_cluster_0 * len_0)\n    val_y_4 = [None] * (num_cluster_0 * len_0)\n    val_y_5 = [None] * (num_cluster_0 * len_0)\n    val_y_6 = [None] * (num_cluster_0)\n    val_y_7 = [None] * (num_cluster_0)\n    x_dist_3 = [None] * (len_0 * num_cluster_0)\n    x_sq_3 = [None] * (len_0 * num_cluster_0)\n    y_dist_3 = [None] * (len_0 * num_cluster_0)\n    y_sq_3 = [None] * (len_0 * num_cluster_0)\n    # Shared array convertion declarations\n    dist_3_B = [None] * (len_0 * num_cluster_0)\n    _23_0_A = [None] * (num_cluster_0)\n    _25_0_A = [None] * (num_cluster_0)\n    _22_0_A = [None] * (num_cluster_0)\n    # Function body\n    _5_0 = _v.lift(lambda indices: bestMap_0, [len_0])\n    best_dist_2 = siv32(10000)\n    _9_0 = _v.lift(lambda indices: (cluster_x_0[indices[1]]), [len_0, num_cluster_0])\n    _10_0 = _v.lift(lambda indices: (data_x_0[indices[0]]), [len_0, num_cluster_0])\n    _11_0 = _v.lift(lambda indices: (cluster_y_0[indices[1]]), [len_0, num_cluster_0])\n    _12_0 = _v.lift(lambda indices: (data_y_0[indices[0]]), [len_0, num_cluster_0])\n    _29_0 = _v.lift(lambda indices: indices[1], [len_0, num_cluster_0])\n    _13_0 = _v.lift(lambda indices: OUTPUT_cluster_x_0, [num_cluster_0])\n    _14_0 = _v.lift(lambda indices: OUTPUT_cluster_y_0, [num_cluster_0])\n    val_x_2 = siv32(0)\n    val_y_2 = siv32(0)\n    count_2 = siv32(0)\n    _18_0 = _v.lift(lambda indices: indices[0], [num_cluster_0, len_0])\n    _20_0 = _v.lift(lambda indices: (data_x_0[indices[1]]), [num_cluster_0, len_0]);_20_0_B = _v.lift(lambda indices: (data_x_0_B[indices[1]]), [num_cluster_0, len_0])\n    _21_0 = _v.lift(lambda indices: (data_y_0[indices[1]]), [num_cluster_0, len_0]);_21_0_B = _v.lift(lambda indices: (data_y_0_B[indices[1]]), [num_cluster_0, len_0])\n    _8_0 = _v.lift(lambda indices: _v.vectorized_access(_5_0, [len_0], [None]), [len_0, num_cluster_0])\n    _7_0 = _v.lift(lambda indices: best_dist_2, [len_0, num_cluster_0])\n    _v.vectorized_assign(x_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_9_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_10_0, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(_11_0, [len_0, num_cluster_0], [None, None]) - _v.vectorized_access_simd(_12_0, [len_0, num_cluster_0], [None, None])))\n    _15_0 = _v.lift(lambda indices: val_x_2, [num_cluster_0, len_0])\n    _16_0 = _v.lift(lambda indices: val_y_2, [num_cluster_0, len_0])\n    _17_0 = _v.lift(lambda indices: count_2, [num_cluster_0, len_0])\n    _v.vectorized_assign(x_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(x_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(y_sq_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None]) * _v.vectorized_access_simd(y_dist_3, [len_0, num_cluster_0], [None, None])))\n    _v.vectorized_assign(dist_3, [len_0, num_cluster_0], [None, None], (_v.vectorized_access_simd(x_sq_3, [len_0, num_cluster_0], [None, None]) + _v.vectorized_access_simd(y_sq_3, [len_0, num_cluster_0], [None, None])))\n    for _random_iter in range(0,len(dist_3)):\n      dist_3_B[_random_iter] = _v.convertion_check(dist_3[_random_iter])\n    dist_3_B = siv32(dist_3_B)\n    for _30_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _30_0 == 0:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(_7_0, [len_0, num_cluster_0], [None, _30_0]))\n        else:\n            _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n        _v.vectorized_assign(_1_3, [len_0, num_cluster_0], [None, _30_0], (_v.vectorized_access_simd(dist_3, [len_0, num_cluster_0], [None, _30_0]) < _v.vectorized_access_simd(best_dist_3, [len_0, num_cluster_0], [None, _30_0])))\n        _v.iterative_mux(best_dist_5,_1_3,dist_3,best_dist_3,[len_0, num_cluster_0],[None, _30_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(best_dist_3, [len_0, num_cluster_0], [None, _30_0], _v.vectorized_access(best_dist_5, [len_0, num_cluster_0], [None, (_30_0 - 1)]))\n    for _31_0 in range(0, num_cluster_0):\n        # Set \u03d5 value\n        if _31_0 == 0:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(_8_0, [len_0, num_cluster_0], [None, _31_0]))\n        else:\n            _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n        _v.iterative_mux(val_5,_1_3,_29_0,bestMap_2,[len_0, num_cluster_0],[None, _31_0])\n        _v.vectorized_assign((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(val_5, [len_0, num_cluster_0], [None, _31_0])); _v.vectorized_assign(bestMap_3, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access((TODO: fix this case), [len_0, num_cluster_0], [None, _31_0]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bestMap_2, [len_0, num_cluster_0], [None, _31_0], _v.vectorized_access(bestMap_3, [len_0, num_cluster_0], [None, (_31_0 - 1)]))\n    _v.vectorized_assign(_6_0, [len_0], [None], _v.drop_dim(bestMap_3, [len_0, num_cluster_0]))\n    _19_0 = _v.lift(lambda indices: _v.vectorized_access(_6_0, [len_0], [indices[1]]), [num_cluster_0, len_0])\n    _v.vectorized_assign(_2_3, [num_cluster_0, len_0], [None, None], (_v.vectorized_access_simd(_18_0, [num_cluster_0, len_0], [None, None]) == _v.vectorized_access_simd(_19_0, [num_cluster_0, len_0], [None, None])))\n    for _32_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _32_0 == 0:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(_15_0, [num_cluster_0, len_0], [None, _32_0]))\n        else:\n            _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n        _v.vectorized_assign(val_x_4, [num_cluster_0, len_0], [None, _32_0], (_v.vectorized_access_simd(val_x_3, [num_cluster_0, len_0], [None, _32_0]) + _v.vectorized_access_simd(_20_0_B, [num_cluster_0, len_0], [None, _32_0])))\n        _v.iterative_mux(val_x_5,_2_3,val_x_4,val_x_3,[num_cluster_0, len_0],[None, _32_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_x_3, [num_cluster_0, len_0], [None, _32_0], _v.vectorized_access(val_x_5, [num_cluster_0, len_0], [None, (_32_0 - 1)]))\n    for _33_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _33_0 == 0:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(_16_0, [num_cluster_0, len_0], [None, _33_0]))\n        else:\n            _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n        _v.vectorized_assign(val_y_4, [num_cluster_0, len_0], [None, _33_0], (_v.vectorized_access_simd(val_y_3, [num_cluster_0, len_0], [None, _33_0]) + _v.vectorized_access_simd(_21_0_B, [num_cluster_0, len_0], [None, _33_0])))\n        _v.iterative_mux(val_y_5,_2_3,val_y_4,val_y_3,[num_cluster_0, len_0],[None, _33_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(val_y_3, [num_cluster_0, len_0], [None, _33_0], _v.vectorized_access(val_y_5, [num_cluster_0, len_0], [None, (_33_0 - 1)]))\n    for _34_0 in range(0, len_0):\n        # Set \u03d5 value\n        if _34_0 == 0:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(_17_0, [num_cluster_0, len_0], [None, _34_0]))\n        else:\n            _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n        _v.vectorized_assign(count_4, [num_cluster_0, len_0], [None, _34_0], (_v.vectorized_access_simd(count_3, [num_cluster_0, len_0], [None, _34_0]) + siv32(1)))\n        _v.iterative_mux(count_5,_2_3,count_4,count_3,[num_cluster_0, len_0],[None, _34_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(count_3, [num_cluster_0, len_0], [None, _34_0], _v.vectorized_access(count_5, [num_cluster_0, len_0], [None, (_34_0 - 1)]))\n    _v.vectorized_assign(_23_0, [num_cluster_0], [None], _v.drop_dim(val_x_5, [num_cluster_0, len_0]));_23_0_A[c_2] = sint(_23_0[c_2])\n    _v.vectorized_assign(_25_0, [num_cluster_0], [None], _v.drop_dim(val_y_5, [num_cluster_0, len_0]));_25_0_A[c_2] = sint(_25_0[c_2])\n    _v.vectorized_assign(_22_0, [num_cluster_0], [None], _v.drop_dim(count_5, [num_cluster_0, len_0]));_22_0_A[c_2] = sint(_22_0[c_2])\n    _v.vectorized_assign(_3_2, [num_cluster_0], [None], (_v.vectorized_access_simd(_22_0_A, [num_cluster_0], [None]) > sint(0)))\n    _v.vectorized_assign(val_x_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_23_0_A, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0_A, [num_cluster_0], [None])))\n    _v.vectorized_assign(val_y_6, [num_cluster_0], [None], _v.div(_v.vectorized_access_simd(_25_0_A, [num_cluster_0], [None]), _v.vectorized_access_simd(_22_0_A, [num_cluster_0], [None])))\n    _v.iterative_mux(val_x_7,_3_2,val_x_6,_23_0_A,[num_cluster_0],[None])\n    _v.iterative_mux(val_y_7,_3_2,val_y_6,_25_0_A,[num_cluster_0],[None])\n    _v.vectorized_assign(_13_0, [num_cluster_0], [None], _v.vectorized_access(val_x_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_x_2, [num_cluster_0], [None], _v.vectorized_access(_13_0, [num_cluster_0], [None]))\n    _v.vectorized_assign(_14_0, [num_cluster_0], [None], _v.vectorized_access(val_y_7, [num_cluster_0], [None])); _v.vectorized_assign(OUTPUT_cluster_y_2, [num_cluster_0], [None], _v.vectorized_access(_14_0, [num_cluster_0], [None]))\n    _4_1 = (OUTPUT_cluster_x_2,OUTPUT_cluster_y_2,)\n    return _4_1"
            }
        }
    },
    "longest_102": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger longest_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    encrypto::motion::SecureUnsignedInteger _19_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _20_0;\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_len_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__19_0;\n    std::uint32_t _MPC_PLAINTEXT__20_0;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_len_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    max_len_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_len_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_len_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__19_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__19_0] = _9_0[_MPC_PLAINTEXT__19_0];\n    for (; _MPC_PLAINTEXT__19_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__19_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__19_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__19_0] = s0_3[(_MPC_PLAINTEXT__19_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__19_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__19_0]));\n        s0_3[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(_2_2[_MPC_PLAINTEXT__19_0]) | to_share_wrapper(_5_2[_MPC_PLAINTEXT__19_0]));\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__20_0 = std::uint32_t(0);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__20_0] = _11_0[_MPC_PLAINTEXT__20_0];\n    for (; _MPC_PLAINTEXT__20_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__20_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__20_0 != std::uint32_t(0)) {\n            length_2[_MPC_PLAINTEXT__20_0] = length_5[(_MPC_PLAINTEXT__20_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__20_0] = (length_2[_MPC_PLAINTEXT__20_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__20_0] = _6_2[_MPC_PLAINTEXT__20_0].Mux(length_3[_MPC_PLAINTEXT__20_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_len_2[_MPC_PLAINTEXT__21_0] = _10_0[_MPC_PLAINTEXT__21_0];\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            max_len_2[_MPC_PLAINTEXT__21_0] = max_len_4[(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))];\n        }\n\n        _7_2[_MPC_PLAINTEXT__21_0] = (length_5[_MPC_PLAINTEXT__21_0] > max_len_2[_MPC_PLAINTEXT__21_0]);\n        _8_2[_MPC_PLAINTEXT__21_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__21_0]) & to_share_wrapper(_7_2[_MPC_PLAINTEXT__21_0]));\n        max_len_4[_MPC_PLAINTEXT__21_0] = _8_2[_MPC_PLAINTEXT__21_0].Mux(length_5[_MPC_PLAINTEXT__21_0].Get(), max_len_2[_MPC_PLAINTEXT__21_0].Get());\n\n    }\n\n    _18_0 = drop_dim_monoreturn(vectorized_access(max_len_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _18_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger longest_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    encrypto::motion::SecureUnsignedInteger _19_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _20_0;\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_len_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__19_0;\n    std::uint32_t _MPC_PLAINTEXT__20_0;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_len_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    max_len_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_len_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_len_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__19_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__19_0] = _9_0[_MPC_PLAINTEXT__19_0];\n    for (; _MPC_PLAINTEXT__19_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__19_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__19_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__19_0] = s0_3[(_MPC_PLAINTEXT__19_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__19_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__19_0]));\n        s0_3[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(_2_2[_MPC_PLAINTEXT__19_0]) | to_share_wrapper(_5_2[_MPC_PLAINTEXT__19_0]));\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__20_0 = std::uint32_t(0);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__20_0] = _11_0[_MPC_PLAINTEXT__20_0];\n    for (; _MPC_PLAINTEXT__20_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__20_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__20_0 != std::uint32_t(0)) {\n            length_2[_MPC_PLAINTEXT__20_0] = length_5[(_MPC_PLAINTEXT__20_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__20_0] = (length_2[_MPC_PLAINTEXT__20_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__20_0] = _6_2[_MPC_PLAINTEXT__20_0].Mux(length_3[_MPC_PLAINTEXT__20_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_len_2[_MPC_PLAINTEXT__21_0] = _10_0[_MPC_PLAINTEXT__21_0];\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            max_len_2[_MPC_PLAINTEXT__21_0] = max_len_4[(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))];\n        }\n\n        _7_2[_MPC_PLAINTEXT__21_0] = (length_5[_MPC_PLAINTEXT__21_0] > max_len_2[_MPC_PLAINTEXT__21_0]);\n        _8_2[_MPC_PLAINTEXT__21_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__21_0]) & to_share_wrapper(_7_2[_MPC_PLAINTEXT__21_0]));\n        max_len_4[_MPC_PLAINTEXT__21_0] = _8_2[_MPC_PLAINTEXT__21_0].Mux(length_5[_MPC_PLAINTEXT__21_0].Get(), max_len_2[_MPC_PLAINTEXT__21_0].Get());\n\n    }\n\n    _18_0 = drop_dim_monoreturn(vectorized_access(max_len_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _18_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger longest_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    encrypto::motion::SecureUnsignedInteger _19_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _20_0;\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_len_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__19_0;\n    std::uint32_t _MPC_PLAINTEXT__20_0;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_len_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    max_len_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_max_len_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_len_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__19_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__19_0] = _9_0[_MPC_PLAINTEXT__19_0];\n    for (; _MPC_PLAINTEXT__19_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__19_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__19_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__19_0] = s0_3[(_MPC_PLAINTEXT__19_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__19_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__19_0]));\n        s0_3[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(_2_2[_MPC_PLAINTEXT__19_0]) | to_share_wrapper(_5_2[_MPC_PLAINTEXT__19_0]));\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__20_0 = std::uint32_t(0);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__20_0] = _11_0[_MPC_PLAINTEXT__20_0];\n    for (; _MPC_PLAINTEXT__20_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__20_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__20_0 != std::uint32_t(0)) {\n            length_2[_MPC_PLAINTEXT__20_0] = length_5_Y[(_MPC_PLAINTEXT__20_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__20_0] = (length_2[_MPC_PLAINTEXT__20_0] + _MPC_CONSTANT_1_Y); length_3_B[_MPC_PLAINTEXT__20_0] = length_3[_MPC_PLAINTEXT__20_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        length_5[_MPC_PLAINTEXT__20_0] = _6_2[_MPC_PLAINTEXT__20_0].Mux(length_3_B[_MPC_PLAINTEXT__20_0].Get(), length_4.Get()); length_5_Y[_MPC_PLAINTEXT__20_0] = length_5[_MPC_PLAINTEXT__20_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_len_2[_MPC_PLAINTEXT__21_0] = _10_0[_MPC_PLAINTEXT__21_0]; max_len_2_B[_MPC_PLAINTEXT__21_0] = max_len_2[_MPC_PLAINTEXT__21_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            max_len_2[_MPC_PLAINTEXT__21_0] = max_len_4_Y[(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))]; max_len_2_B[_MPC_PLAINTEXT__21_0] = max_len_2[_MPC_PLAINTEXT__21_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        _7_2[_MPC_PLAINTEXT__21_0] = (length_5_Y[_MPC_PLAINTEXT__21_0] > max_len_2[_MPC_PLAINTEXT__21_0]); _7_2_B[_MPC_PLAINTEXT__21_0] = _7_2[_MPC_PLAINTEXT__21_0].Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        _8_2[_MPC_PLAINTEXT__21_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__21_0]) & to_share_wrapper(_7_2_B[_MPC_PLAINTEXT__21_0]));\n        max_len_4[_MPC_PLAINTEXT__21_0] = _8_2[_MPC_PLAINTEXT__21_0].Mux(length_5[_MPC_PLAINTEXT__21_0].Get(), max_len_2_B[_MPC_PLAINTEXT__21_0].Get()); max_len_4_Y[_MPC_PLAINTEXT__21_0] = max_len_4[_MPC_PLAINTEXT__21_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    _18_0 = drop_dim_monoreturn(vectorized_access(max_len_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _18_0_Y; _18_0_Y = drop_dim_monoreturn(vectorized_access(max_len_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _18_0;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger longest_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    encrypto::motion::SecureUnsignedInteger _19_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _20_0;\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_len_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__19_0;\n    std::uint32_t _MPC_PLAINTEXT__20_0;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_len_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    max_len_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_len_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_len_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__19_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__19_0] = _9_0[_MPC_PLAINTEXT__19_0];\n    for (; _MPC_PLAINTEXT__19_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__19_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__19_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__19_0] = s0_3[(_MPC_PLAINTEXT__19_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__19_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__19_0]));\n        s0_3[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(_2_2[_MPC_PLAINTEXT__19_0]) | to_share_wrapper(_5_2[_MPC_PLAINTEXT__19_0]));\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__20_0 = std::uint32_t(0);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__20_0] = _11_0[_MPC_PLAINTEXT__20_0];\n    for (; _MPC_PLAINTEXT__20_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__20_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__20_0 != std::uint32_t(0)) {\n            length_2[_MPC_PLAINTEXT__20_0] = length_5[(_MPC_PLAINTEXT__20_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__20_0] = (length_2[_MPC_PLAINTEXT__20_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__20_0] = _6_2[_MPC_PLAINTEXT__20_0].Mux(length_3[_MPC_PLAINTEXT__20_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_len_2[_MPC_PLAINTEXT__21_0] = _10_0[_MPC_PLAINTEXT__21_0];\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            max_len_2[_MPC_PLAINTEXT__21_0] = max_len_4[(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))];\n        }\n\n        _7_2[_MPC_PLAINTEXT__21_0] = (length_5[_MPC_PLAINTEXT__21_0] > max_len_2[_MPC_PLAINTEXT__21_0]);\n        _8_2[_MPC_PLAINTEXT__21_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__21_0]) & to_share_wrapper(_7_2[_MPC_PLAINTEXT__21_0]));\n        max_len_4[_MPC_PLAINTEXT__21_0] = _8_2[_MPC_PLAINTEXT__21_0].Mux(length_5[_MPC_PLAINTEXT__21_0].Get(), max_len_2[_MPC_PLAINTEXT__21_0].Get());\n\n    }\n\n    _18_0 = drop_dim_monoreturn(vectorized_access(max_len_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _18_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger longest_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    encrypto::motion::SecureUnsignedInteger _19_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _20_0;\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_len_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__19_0;\n    std::uint32_t _MPC_PLAINTEXT__20_0;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_len_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    max_len_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_len_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_len_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__19_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__19_0] = _9_0[_MPC_PLAINTEXT__19_0];\n    for (; _MPC_PLAINTEXT__19_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__19_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__19_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__19_0] = s0_3[(_MPC_PLAINTEXT__19_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__19_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__19_0]));\n        s0_3[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(_2_2[_MPC_PLAINTEXT__19_0]) | to_share_wrapper(_5_2[_MPC_PLAINTEXT__19_0]));\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__20_0 = std::uint32_t(0);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__20_0] = _11_0[_MPC_PLAINTEXT__20_0];\n    for (; _MPC_PLAINTEXT__20_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__20_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__20_0 != std::uint32_t(0)) {\n            length_2[_MPC_PLAINTEXT__20_0] = length_5[(_MPC_PLAINTEXT__20_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__20_0] = (length_2[_MPC_PLAINTEXT__20_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__20_0] = _6_2[_MPC_PLAINTEXT__20_0].Mux(length_3[_MPC_PLAINTEXT__20_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_len_2[_MPC_PLAINTEXT__21_0] = _10_0[_MPC_PLAINTEXT__21_0];\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            max_len_2[_MPC_PLAINTEXT__21_0] = max_len_4[(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))];\n        }\n\n        _7_2[_MPC_PLAINTEXT__21_0] = (length_5[_MPC_PLAINTEXT__21_0] > max_len_2[_MPC_PLAINTEXT__21_0]);\n        _8_2[_MPC_PLAINTEXT__21_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__21_0]) & to_share_wrapper(_7_2[_MPC_PLAINTEXT__21_0]));\n        max_len_4[_MPC_PLAINTEXT__21_0] = _8_2[_MPC_PLAINTEXT__21_0].Mux(length_5[_MPC_PLAINTEXT__21_0].Get(), max_len_2[_MPC_PLAINTEXT__21_0].Get());\n\n    }\n\n    _18_0 = drop_dim_monoreturn(vectorized_access(max_len_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _18_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger longest_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    encrypto::motion::SecureUnsignedInteger _19_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _20_0;\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_len_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__19_0;\n    std::uint32_t _MPC_PLAINTEXT__20_0;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_len_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    max_len_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_len_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_len_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__19_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__19_0] = _9_0[_MPC_PLAINTEXT__19_0];\n    for (; _MPC_PLAINTEXT__19_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__19_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__19_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__19_0] = s0_3[(_MPC_PLAINTEXT__19_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__19_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__19_0]));\n        s0_3[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(_2_2[_MPC_PLAINTEXT__19_0]) | to_share_wrapper(_5_2[_MPC_PLAINTEXT__19_0]));\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__20_0 = std::uint32_t(0);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__20_0] = _11_0[_MPC_PLAINTEXT__20_0];\n    for (; _MPC_PLAINTEXT__20_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__20_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__20_0 != std::uint32_t(0)) {\n            length_2[_MPC_PLAINTEXT__20_0] = length_5_Y[(_MPC_PLAINTEXT__20_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__20_0] = (length_2[_MPC_PLAINTEXT__20_0] + _MPC_CONSTANT_1_Y); length_3_B[_MPC_PLAINTEXT__20_0] = length_3[_MPC_PLAINTEXT__20_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        length_5[_MPC_PLAINTEXT__20_0] = _6_2[_MPC_PLAINTEXT__20_0].Mux(length_3_B[_MPC_PLAINTEXT__20_0].Get(), length_4.Get()); length_5_Y[_MPC_PLAINTEXT__20_0] = length_5[_MPC_PLAINTEXT__20_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_len_2[_MPC_PLAINTEXT__21_0] = _10_0[_MPC_PLAINTEXT__21_0];\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            max_len_2[_MPC_PLAINTEXT__21_0] = max_len_4[(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))];\n        }\n\n        _7_2[_MPC_PLAINTEXT__21_0] = (length_5[_MPC_PLAINTEXT__21_0] > max_len_2[_MPC_PLAINTEXT__21_0]);\n        _8_2[_MPC_PLAINTEXT__21_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__21_0]) & to_share_wrapper(_7_2[_MPC_PLAINTEXT__21_0]));\n        max_len_4[_MPC_PLAINTEXT__21_0] = _8_2[_MPC_PLAINTEXT__21_0].Mux(length_5[_MPC_PLAINTEXT__21_0].Get(), max_len_2[_MPC_PLAINTEXT__21_0].Get());\n\n    }\n\n    _18_0 = drop_dim_monoreturn(vectorized_access(max_len_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _18_0;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger longest_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    encrypto::motion::SecureUnsignedInteger _19_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _20_0;\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_len_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__19_0;\n    std::uint32_t _MPC_PLAINTEXT__20_0;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_len_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    max_len_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_len_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_len_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__19_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__19_0] = _9_0[_MPC_PLAINTEXT__19_0];\n    for (; _MPC_PLAINTEXT__19_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__19_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__19_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__19_0] = s0_3[(_MPC_PLAINTEXT__19_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__19_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__19_0]));\n        s0_3[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(_2_2[_MPC_PLAINTEXT__19_0]) | to_share_wrapper(_5_2[_MPC_PLAINTEXT__19_0]));\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__20_0 = std::uint32_t(0);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__20_0] = _11_0[_MPC_PLAINTEXT__20_0];\n    for (; _MPC_PLAINTEXT__20_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__20_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__20_0 != std::uint32_t(0)) {\n            length_2[_MPC_PLAINTEXT__20_0] = length_5[(_MPC_PLAINTEXT__20_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__20_0] = (length_2[_MPC_PLAINTEXT__20_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__20_0] = _6_2[_MPC_PLAINTEXT__20_0].Mux(length_3[_MPC_PLAINTEXT__20_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_len_2[_MPC_PLAINTEXT__21_0] = _10_0[_MPC_PLAINTEXT__21_0];\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            max_len_2[_MPC_PLAINTEXT__21_0] = max_len_4[(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))];\n        }\n\n        _7_2[_MPC_PLAINTEXT__21_0] = (length_5[_MPC_PLAINTEXT__21_0] > max_len_2[_MPC_PLAINTEXT__21_0]);\n        _8_2[_MPC_PLAINTEXT__21_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__21_0]) & to_share_wrapper(_7_2[_MPC_PLAINTEXT__21_0]));\n        max_len_4[_MPC_PLAINTEXT__21_0] = _8_2[_MPC_PLAINTEXT__21_0].Mux(length_5[_MPC_PLAINTEXT__21_0].Get(), max_len_2[_MPC_PLAINTEXT__21_0].Get());\n\n    }\n\n    _18_0 = drop_dim_monoreturn(vectorized_access(max_len_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _18_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger longest_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    encrypto::motion::SecureUnsignedInteger _19_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _20_0;\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_len_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__19_0;\n    std::uint32_t _MPC_PLAINTEXT__20_0;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_len_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    max_len_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_len_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_len_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__19_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__19_0] = _9_0[_MPC_PLAINTEXT__19_0];\n    for (; _MPC_PLAINTEXT__19_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__19_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__19_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__19_0] = s0_3[(_MPC_PLAINTEXT__19_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__19_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__19_0]));\n        s0_3[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(_2_2[_MPC_PLAINTEXT__19_0]) | to_share_wrapper(_5_2[_MPC_PLAINTEXT__19_0]));\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__20_0 = std::uint32_t(0);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__20_0] = _11_0[_MPC_PLAINTEXT__20_0];\n    for (; _MPC_PLAINTEXT__20_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__20_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__20_0 != std::uint32_t(0)) {\n            length_2[_MPC_PLAINTEXT__20_0] = length_5[(_MPC_PLAINTEXT__20_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__20_0] = (length_2[_MPC_PLAINTEXT__20_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__20_0] = _6_2[_MPC_PLAINTEXT__20_0].Mux(length_3[_MPC_PLAINTEXT__20_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_len_2[_MPC_PLAINTEXT__21_0] = _10_0[_MPC_PLAINTEXT__21_0];\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            max_len_2[_MPC_PLAINTEXT__21_0] = max_len_4[(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))];\n        }\n\n        _7_2[_MPC_PLAINTEXT__21_0] = (length_5[_MPC_PLAINTEXT__21_0] > max_len_2[_MPC_PLAINTEXT__21_0]);\n        _8_2[_MPC_PLAINTEXT__21_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__21_0]) & to_share_wrapper(_7_2[_MPC_PLAINTEXT__21_0]));\n        max_len_4[_MPC_PLAINTEXT__21_0] = _8_2[_MPC_PLAINTEXT__21_0].Mux(length_5[_MPC_PLAINTEXT__21_0].Get(), max_len_2[_MPC_PLAINTEXT__21_0].Get());\n\n    }\n\n    _18_0 = drop_dim_monoreturn(vectorized_access(max_len_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _18_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger longest_102(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    encrypto::motion::SecureUnsignedInteger _19_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _20_0;\n    encrypto::motion::SecureUnsignedInteger _21_0;\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _8_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_len_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_len_4((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s0_1;\n    std::vector<encrypto::motion::ShareWrapper> s0_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s0_3((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__19_0;\n    std::uint32_t _MPC_PLAINTEXT__20_0;\n    std::uint32_t _MPC_PLAINTEXT__21_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_len_1;\n    bool _MPC_PLAINTEXT_s0_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    s0_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s0_1 = false;\n    max_len_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_len_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(2)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s0_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_len_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__19_0 = std::uint32_t(0);\n    // Initialize phi values\n    s0_2[_MPC_PLAINTEXT__19_0] = _9_0[_MPC_PLAINTEXT__19_0];\n    for (; _MPC_PLAINTEXT__19_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__19_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__19_0 != std::uint32_t(0)) {\n            s0_2[_MPC_PLAINTEXT__19_0] = s0_3[(_MPC_PLAINTEXT__19_0 - std::uint32_t(1))];\n        }\n\n        _5_2[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(s0_2[_MPC_PLAINTEXT__19_0]) & to_share_wrapper(_4_2[_MPC_PLAINTEXT__19_0]));\n        s0_3[_MPC_PLAINTEXT__19_0] = (to_share_wrapper(_2_2[_MPC_PLAINTEXT__19_0]) | to_share_wrapper(_5_2[_MPC_PLAINTEXT__19_0]));\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s0_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) | to_share_wrapper(vectorized_access(s0_3, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__20_0 = std::uint32_t(0);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__20_0] = _11_0[_MPC_PLAINTEXT__20_0];\n    for (; _MPC_PLAINTEXT__20_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__20_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__20_0 != std::uint32_t(0)) {\n            length_2[_MPC_PLAINTEXT__20_0] = length_5[(_MPC_PLAINTEXT__20_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__20_0] = (length_2[_MPC_PLAINTEXT__20_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__20_0] = _6_2[_MPC_PLAINTEXT__20_0].Mux(length_3[_MPC_PLAINTEXT__20_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__21_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_len_2[_MPC_PLAINTEXT__21_0] = _10_0[_MPC_PLAINTEXT__21_0];\n    for (; _MPC_PLAINTEXT__21_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__21_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__21_0 != std::uint32_t(0)) {\n            max_len_2[_MPC_PLAINTEXT__21_0] = max_len_4[(_MPC_PLAINTEXT__21_0 - std::uint32_t(1))];\n        }\n\n        _7_2[_MPC_PLAINTEXT__21_0] = (length_5[_MPC_PLAINTEXT__21_0] > max_len_2[_MPC_PLAINTEXT__21_0]);\n        _8_2[_MPC_PLAINTEXT__21_0] = (to_share_wrapper(s1_2[_MPC_PLAINTEXT__21_0]) & to_share_wrapper(_7_2[_MPC_PLAINTEXT__21_0]));\n        max_len_4[_MPC_PLAINTEXT__21_0] = _8_2[_MPC_PLAINTEXT__21_0].Mux(length_5[_MPC_PLAINTEXT__21_0].Get(), max_len_2[_MPC_PLAINTEXT__21_0].Get());\n\n    }\n\n    _18_0 = drop_dim_monoreturn(vectorized_access(max_len_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _18_0;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    max_len_1 = sint(0)\n    length_1 = sint(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = sint(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + sint(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0",
                "B": "program.options.binary = 32\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    max_len_1 = siv32(0)\n    length_1 = siv32(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = siv32(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + siv32(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    max_len_1 = sint(0)\n    length_1 = sint(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = sint(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + sint(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    max_len_1 = sint(0)\n    length_1 = sint(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = sint(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + sint(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    max_len_1 = siv32(0)\n    length_1 = siv32(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = siv32(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + siv32(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    max_len_1 = sint(0)\n    length_1 = sint(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = sint(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + sint(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0",
                "B": "program.options.binary = 32\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    max_len_1 = siv32(0)\n    length_1 = siv32(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = siv32(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + siv32(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    max_len_1 = sint(0)\n    length_1 = sint(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = sint(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + sint(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    max_len_1 = sint(0)\n    length_1 = sint(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = sint(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + sint(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    max_len_1 = siv32(0)\n    length_1 = siv32(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = siv32(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + siv32(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0"
            },
            "time": {
                "A": "program.options.binary = 32\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    max_len_1 = sint(0)\n    length_1 = sint(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = sint(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + sint(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0",
                "B": "program.options.binary = 32\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    max_len_1 = siv32(0)\n    length_1 = siv32(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = siv32(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + siv32(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    max_len_1 = sint(0)\n    length_1 = sint(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = sint(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + sint(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sint(_v.sbool(False))\n    max_len_1 = sint(0)\n    length_1 = sint(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = sint(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + sint(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef longest_102(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _13_0 = [None] * (N_0)\n    _15_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_2 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    length_2 = [None] * (N_0)\n    length_3 = [None] * (N_0)\n    length_5 = [None] * (N_0)\n    max_len_2 = [None] * (N_0)\n    max_len_4 = [None] * (N_0)\n    s0_2 = [None] * (N_0)\n    s0_3 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    s0_1 = sbit(0)\n    max_len_1 = siv32(0)\n    length_1 = siv32(0)\n    _12_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _13_0 = _v.lift(lambda indices: (Syms_0[2]), [N_0])\n    _15_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    length_4 = siv32(0)\n    _9_0 = _v.lift(lambda indices: s0_1, [N_0])\n    _10_0 = _v.lift(lambda indices: max_len_1, [N_0])\n    _11_0 = _v.lift(lambda indices: length_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_13_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_15_0, [N_0], [None])))\n    _v.vectorized_assign(_4_2, [N_0], [None], (_v.vectorized_access_simd(_12_0, [N_0], [None]) == _v.vectorized_access_simd(_17_0, [N_0], [None])))\n    for _19_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _19_0 == 0:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(_9_0, [N_0], [_19_0]))\n        else:\n            _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n        _v.vectorized_assign(_5_2, [N_0], [_19_0], _v.vectorized_access_simd(s0_2, [N_0], [_19_0]).bit_and(_v.vectorized_access_simd(_4_2, [N_0], [_19_0])))\n        _v.vectorized_assign(s0_3, [N_0], [_19_0], OR(_v.vectorized_access_simd(_2_2, [N_0], [_19_0]), _v.vectorized_access_simd(_5_2, [N_0], [_19_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s0_2, [N_0], [_19_0], _v.vectorized_access(s0_3, [N_0], [(_19_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s0_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_6_2, [N_0], [None], OR(_v.vectorized_access_simd(s1_2, [N_0], [None]), _v.vectorized_access_simd(s0_3, [N_0], [None])))\n    for _20_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _20_0 == 0:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(_11_0, [N_0], [_20_0]))\n        else:\n            _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n        _v.vectorized_assign(length_3, [N_0], [_20_0], (_v.vectorized_access_simd(length_2, [N_0], [_20_0]) + siv32(1)))\n        _v.iterative_mux(length_5,_6_2,length_3,length_4,[N_0],[_20_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(length_2, [N_0], [_20_0], _v.vectorized_access(length_5, [N_0], [(_20_0 - 1)]))\n    for _21_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _21_0 == 0:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(_10_0, [N_0], [_21_0]))\n        else:\n            _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n        _v.vectorized_assign(_7_2, [N_0], [_21_0], (_v.vectorized_access_simd(max_len_2, [N_0], [_21_0]) < _v.vectorized_access_simd(length_5, [N_0], [_21_0])))\n        _v.vectorized_assign(_8_2, [N_0], [_21_0], _v.vectorized_access_simd(s1_2, [N_0], [_21_0]).bit_and(_v.vectorized_access_simd(_7_2, [N_0], [_21_0])))\n        _v.iterative_mux(max_len_4,_8_2,length_5,max_len_2,[N_0],[_21_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_len_2, [N_0], [_21_0], _v.vectorized_access(max_len_4, [N_0], [(_21_0 - 1)]))\n    _18_0 = _v.drop_dim(max_len_4, [N_0])\n    return _18_0"
            }
        }
    },
    "longest_1s": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger longest_1s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _7_0;\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(1);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__8_0] = _4_0[_MPC_PLAINTEXT__8_0];\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(1)) {\n            length_2[_MPC_PLAINTEXT__8_0] = length_5[(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__8_0] = (length_2[_MPC_PLAINTEXT__8_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__8_0] = _1_2[_MPC_PLAINTEXT__8_0].Mux(length_3[_MPC_PLAINTEXT__8_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__9_0] = _3_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__9_0] = max_length_4[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__9_0] = (length_5[_MPC_PLAINTEXT__9_0] > max_length_2[_MPC_PLAINTEXT__9_0]);\n        max_length_4[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(length_5[_MPC_PLAINTEXT__9_0].Get(), max_length_2[_MPC_PLAINTEXT__9_0].Get());\n\n    }\n\n    _7_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _7_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger longest_1s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _7_0;\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(1);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__8_0] = _4_0[_MPC_PLAINTEXT__8_0];\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(1)) {\n            length_2[_MPC_PLAINTEXT__8_0] = length_5[(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__8_0] = (length_2[_MPC_PLAINTEXT__8_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__8_0] = _1_2[_MPC_PLAINTEXT__8_0].Mux(length_3[_MPC_PLAINTEXT__8_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__9_0] = _3_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__9_0] = max_length_4[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__9_0] = (length_5[_MPC_PLAINTEXT__9_0] > max_length_2[_MPC_PLAINTEXT__9_0]);\n        max_length_4[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(length_5[_MPC_PLAINTEXT__9_0].Get(), max_length_2[_MPC_PLAINTEXT__9_0].Get());\n\n    }\n\n    _7_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _7_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger longest_1s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _7_0;\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_length_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(1);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__8_0] = _4_0[_MPC_PLAINTEXT__8_0];\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(1)) {\n            length_2[_MPC_PLAINTEXT__8_0] = length_5_Y[(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__8_0] = (length_2[_MPC_PLAINTEXT__8_0] + _MPC_CONSTANT_1_Y); length_3_B[_MPC_PLAINTEXT__8_0] = length_3[_MPC_PLAINTEXT__8_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        length_5[_MPC_PLAINTEXT__8_0] = _1_2[_MPC_PLAINTEXT__8_0].Mux(length_3_B[_MPC_PLAINTEXT__8_0].Get(), length_4.Get()); length_5_Y[_MPC_PLAINTEXT__8_0] = length_5[_MPC_PLAINTEXT__8_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__9_0] = _3_0[_MPC_PLAINTEXT__9_0]; max_length_2_B[_MPC_PLAINTEXT__9_0] = max_length_2[_MPC_PLAINTEXT__9_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__9_0] = max_length_4_Y[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))]; max_length_2_B[_MPC_PLAINTEXT__9_0] = max_length_2[_MPC_PLAINTEXT__9_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        _2_2[_MPC_PLAINTEXT__9_0] = (length_5_Y[_MPC_PLAINTEXT__9_0] > max_length_2[_MPC_PLAINTEXT__9_0]); _2_2_B[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        max_length_4[_MPC_PLAINTEXT__9_0] = _2_2_B[_MPC_PLAINTEXT__9_0].Mux(length_5[_MPC_PLAINTEXT__9_0].Get(), max_length_2_B[_MPC_PLAINTEXT__9_0].Get()); max_length_4_Y[_MPC_PLAINTEXT__9_0] = max_length_4[_MPC_PLAINTEXT__9_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    _7_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _7_0_Y; _7_0_Y = drop_dim_monoreturn(vectorized_access(max_length_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _7_0;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger longest_1s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _7_0;\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(1);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__8_0] = _4_0[_MPC_PLAINTEXT__8_0];\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(1)) {\n            length_2[_MPC_PLAINTEXT__8_0] = length_5[(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__8_0] = (length_2[_MPC_PLAINTEXT__8_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__8_0] = _1_2[_MPC_PLAINTEXT__8_0].Mux(length_3[_MPC_PLAINTEXT__8_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__9_0] = _3_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__9_0] = max_length_4[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__9_0] = (length_5[_MPC_PLAINTEXT__9_0] > max_length_2[_MPC_PLAINTEXT__9_0]);\n        max_length_4[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(length_5[_MPC_PLAINTEXT__9_0].Get(), max_length_2[_MPC_PLAINTEXT__9_0].Get());\n\n    }\n\n    _7_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _7_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger longest_1s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _7_0;\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(1);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__8_0] = _4_0[_MPC_PLAINTEXT__8_0];\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(1)) {\n            length_2[_MPC_PLAINTEXT__8_0] = length_5[(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__8_0] = (length_2[_MPC_PLAINTEXT__8_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__8_0] = _1_2[_MPC_PLAINTEXT__8_0].Mux(length_3[_MPC_PLAINTEXT__8_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__9_0] = _3_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__9_0] = max_length_4[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__9_0] = (length_5[_MPC_PLAINTEXT__9_0] > max_length_2[_MPC_PLAINTEXT__9_0]);\n        max_length_4[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(length_5[_MPC_PLAINTEXT__9_0].Get(), max_length_2[_MPC_PLAINTEXT__9_0].Get());\n\n    }\n\n    _7_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _7_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger longest_1s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _7_0;\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(1);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__8_0] = _4_0[_MPC_PLAINTEXT__8_0];\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(1)) {\n            length_2[_MPC_PLAINTEXT__8_0] = length_5_Y[(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__8_0] = (length_2[_MPC_PLAINTEXT__8_0] + _MPC_CONSTANT_1_Y); length_3_B[_MPC_PLAINTEXT__8_0] = length_3[_MPC_PLAINTEXT__8_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        length_5[_MPC_PLAINTEXT__8_0] = _1_2[_MPC_PLAINTEXT__8_0].Mux(length_3_B[_MPC_PLAINTEXT__8_0].Get(), length_4.Get()); length_5_Y[_MPC_PLAINTEXT__8_0] = length_5[_MPC_PLAINTEXT__8_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__9_0] = _3_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__9_0] = max_length_4[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__9_0] = (length_5[_MPC_PLAINTEXT__9_0] > max_length_2[_MPC_PLAINTEXT__9_0]);\n        max_length_4[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(length_5[_MPC_PLAINTEXT__9_0].Get(), max_length_2[_MPC_PLAINTEXT__9_0].Get());\n\n    }\n\n    _7_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _7_0;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger longest_1s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _7_0;\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(1);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__8_0] = _4_0[_MPC_PLAINTEXT__8_0];\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(1)) {\n            length_2[_MPC_PLAINTEXT__8_0] = length_5[(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__8_0] = (length_2[_MPC_PLAINTEXT__8_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__8_0] = _1_2[_MPC_PLAINTEXT__8_0].Mux(length_3[_MPC_PLAINTEXT__8_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__9_0] = _3_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__9_0] = max_length_4[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__9_0] = (length_5[_MPC_PLAINTEXT__9_0] > max_length_2[_MPC_PLAINTEXT__9_0]);\n        max_length_4[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(length_5[_MPC_PLAINTEXT__9_0].Get(), max_length_2[_MPC_PLAINTEXT__9_0].Get());\n\n    }\n\n    _7_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _7_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger longest_1s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _7_0;\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(1);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__8_0] = _4_0[_MPC_PLAINTEXT__8_0];\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(1)) {\n            length_2[_MPC_PLAINTEXT__8_0] = length_5[(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__8_0] = (length_2[_MPC_PLAINTEXT__8_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__8_0] = _1_2[_MPC_PLAINTEXT__8_0].Mux(length_3[_MPC_PLAINTEXT__8_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__9_0] = _3_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__9_0] = max_length_4[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__9_0] = (length_5[_MPC_PLAINTEXT__9_0] > max_length_2[_MPC_PLAINTEXT__9_0]);\n        max_length_4[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(length_5[_MPC_PLAINTEXT__9_0].Get(), max_length_2[_MPC_PLAINTEXT__9_0].Get());\n\n    }\n\n    _7_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _7_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger longest_1s(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _7_0;\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_length_1;\n    std::uint32_t _MPC_PLAINTEXT_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_1 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_length_4 = std::uint32_t(0);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(1);\n    // Initialize phi values\n    length_2[_MPC_PLAINTEXT__8_0] = _4_0[_MPC_PLAINTEXT__8_0];\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(1)) {\n            length_2[_MPC_PLAINTEXT__8_0] = length_5[(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))];\n        }\n\n        length_3[_MPC_PLAINTEXT__8_0] = (length_2[_MPC_PLAINTEXT__8_0] + _MPC_CONSTANT_1);\n        length_5[_MPC_PLAINTEXT__8_0] = _1_2[_MPC_PLAINTEXT__8_0].Mux(length_3[_MPC_PLAINTEXT__8_0].Get(), length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__9_0] = _3_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__9_0] = max_length_4[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__9_0] = (length_5[_MPC_PLAINTEXT__9_0] > max_length_2[_MPC_PLAINTEXT__9_0]);\n        max_length_4[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(length_5[_MPC_PLAINTEXT__9_0].Get(), max_length_2[_MPC_PLAINTEXT__9_0].Get());\n\n    }\n\n    _7_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _7_0;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "ERROR: ",
                "B": "ERROR: ",
                "X": "ERROR: ",
                "Y": "ERROR: ",
                "mixed": "ERROR: "
            },
            "dataSent": {
                "A": "ERROR: ",
                "B": "ERROR: ",
                "X": "ERROR: ",
                "Y": "ERROR: ",
                "mixed": "ERROR: "
            },
            "time": {
                "A": "ERROR: ",
                "B": "ERROR: ",
                "X": "ERROR: ",
                "Y": "ERROR: ",
                "mixed": "ERROR: "
            }
        }
    },
    "longest_even_0": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger longest_even_0(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_max_len_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(1);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(1)) {\n            current_length_2[_MPC_PLAINTEXT__10_0] = current_length_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_length_3[_MPC_PLAINTEXT__10_0] = (current_length_2[_MPC_PLAINTEXT__10_0] + _MPC_CONSTANT_1);\n        current_length_5[_MPC_PLAINTEXT__10_0] = _1_2[_MPC_PLAINTEXT__10_0].Mux(current_length_3[_MPC_PLAINTEXT__10_0].Get(), current_length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__11_0] = _6_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__11_0] = max_length_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__11_0] = (current_length_5[_MPC_PLAINTEXT__11_0] > max_length_2[_MPC_PLAINTEXT__11_0]);\n        tmp_max_len_4[_MPC_PLAINTEXT__11_0] = _2_2[_MPC_PLAINTEXT__11_0].Mux(current_length_5[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n        _3_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(tmp_max_len_4[_MPC_PLAINTEXT__11_0]) & to_share_wrapper(_MPC_CONSTANT_1));\n        _4_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__11_0]) == to_share_wrapper(_MPC_CONSTANT_0));\n        max_length_4[_MPC_PLAINTEXT__11_0] = _4_2[_MPC_PLAINTEXT__11_0].Mux(tmp_max_len_4[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger longest_even_0(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_max_len_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(1);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(1)) {\n            current_length_2[_MPC_PLAINTEXT__10_0] = current_length_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_length_3[_MPC_PLAINTEXT__10_0] = (current_length_2[_MPC_PLAINTEXT__10_0] + _MPC_CONSTANT_1);\n        current_length_5[_MPC_PLAINTEXT__10_0] = _1_2[_MPC_PLAINTEXT__10_0].Mux(current_length_3[_MPC_PLAINTEXT__10_0].Get(), current_length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__11_0] = _6_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__11_0] = max_length_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__11_0] = (current_length_5[_MPC_PLAINTEXT__11_0] > max_length_2[_MPC_PLAINTEXT__11_0]);\n        tmp_max_len_4[_MPC_PLAINTEXT__11_0] = _2_2[_MPC_PLAINTEXT__11_0].Mux(current_length_5[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n        _3_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(tmp_max_len_4[_MPC_PLAINTEXT__11_0]) & to_share_wrapper(_MPC_CONSTANT_1));\n        _4_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__11_0]) == to_share_wrapper(_MPC_CONSTANT_0));\n        max_length_4[_MPC_PLAINTEXT__11_0] = _4_2[_MPC_PLAINTEXT__11_0].Mux(tmp_max_len_4[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger longest_even_0(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_max_len_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(1);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(1)) {\n            current_length_2[_MPC_PLAINTEXT__10_0] = current_length_5_Y[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_length_3[_MPC_PLAINTEXT__10_0] = (current_length_2[_MPC_PLAINTEXT__10_0] + _MPC_CONSTANT_1_Y); current_length_3_B[_MPC_PLAINTEXT__10_0] = current_length_3[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        current_length_5[_MPC_PLAINTEXT__10_0] = _1_2[_MPC_PLAINTEXT__10_0].Mux(current_length_3_B[_MPC_PLAINTEXT__10_0].Get(), current_length_4.Get()); current_length_5_Y[_MPC_PLAINTEXT__10_0] = current_length_5[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _2_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__11_0] = _6_0[_MPC_PLAINTEXT__11_0]; max_length_2_B[_MPC_PLAINTEXT__11_0] = max_length_2[_MPC_PLAINTEXT__11_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__11_0] = max_length_4_Y[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))]; max_length_2_B[_MPC_PLAINTEXT__11_0] = max_length_2[_MPC_PLAINTEXT__11_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        _2_2[_MPC_PLAINTEXT__11_0] = (current_length_5_Y[_MPC_PLAINTEXT__11_0] > max_length_2[_MPC_PLAINTEXT__11_0]); _2_2_B[_MPC_PLAINTEXT__11_0] = _2_2[_MPC_PLAINTEXT__11_0].Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        tmp_max_len_4[_MPC_PLAINTEXT__11_0] = _2_2_B[_MPC_PLAINTEXT__11_0].Mux(current_length_5[_MPC_PLAINTEXT__11_0].Get(), max_length_2_B[_MPC_PLAINTEXT__11_0].Get());\n        _3_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(tmp_max_len_4[_MPC_PLAINTEXT__11_0]) & to_share_wrapper(_MPC_CONSTANT_1));\n        _4_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__11_0]) == to_share_wrapper(_MPC_CONSTANT_0));\n        max_length_4[_MPC_PLAINTEXT__11_0] = _4_2[_MPC_PLAINTEXT__11_0].Mux(tmp_max_len_4[_MPC_PLAINTEXT__11_0].Get(), max_length_2_B[_MPC_PLAINTEXT__11_0].Get()); max_length_4_Y[_MPC_PLAINTEXT__11_0] = max_length_4[_MPC_PLAINTEXT__11_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _9_0_Y; _9_0_Y = drop_dim_monoreturn(vectorized_access(max_length_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger longest_even_0(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_max_len_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(1);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(1)) {\n            current_length_2[_MPC_PLAINTEXT__10_0] = current_length_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_length_3[_MPC_PLAINTEXT__10_0] = (current_length_2[_MPC_PLAINTEXT__10_0] + _MPC_CONSTANT_1);\n        current_length_5[_MPC_PLAINTEXT__10_0] = _1_2[_MPC_PLAINTEXT__10_0].Mux(current_length_3[_MPC_PLAINTEXT__10_0].Get(), current_length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__11_0] = _6_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__11_0] = max_length_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__11_0] = (current_length_5[_MPC_PLAINTEXT__11_0] > max_length_2[_MPC_PLAINTEXT__11_0]);\n        tmp_max_len_4[_MPC_PLAINTEXT__11_0] = _2_2[_MPC_PLAINTEXT__11_0].Mux(current_length_5[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n        _3_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(tmp_max_len_4[_MPC_PLAINTEXT__11_0]) & to_share_wrapper(_MPC_CONSTANT_1));\n        _4_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__11_0]) == to_share_wrapper(_MPC_CONSTANT_0));\n        max_length_4[_MPC_PLAINTEXT__11_0] = _4_2[_MPC_PLAINTEXT__11_0].Mux(tmp_max_len_4[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger longest_even_0(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_max_len_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(1);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(1)) {\n            current_length_2[_MPC_PLAINTEXT__10_0] = current_length_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_length_3[_MPC_PLAINTEXT__10_0] = (current_length_2[_MPC_PLAINTEXT__10_0] + _MPC_CONSTANT_1);\n        current_length_5[_MPC_PLAINTEXT__10_0] = _1_2[_MPC_PLAINTEXT__10_0].Mux(current_length_3[_MPC_PLAINTEXT__10_0].Get(), current_length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__11_0] = _6_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__11_0] = max_length_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__11_0] = (current_length_5[_MPC_PLAINTEXT__11_0] > max_length_2[_MPC_PLAINTEXT__11_0]);\n        tmp_max_len_4[_MPC_PLAINTEXT__11_0] = _2_2[_MPC_PLAINTEXT__11_0].Mux(current_length_5[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n        _3_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(tmp_max_len_4[_MPC_PLAINTEXT__11_0]) & to_share_wrapper(_MPC_CONSTANT_1));\n        _4_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__11_0]) == to_share_wrapper(_MPC_CONSTANT_0));\n        max_length_4[_MPC_PLAINTEXT__11_0] = _4_2[_MPC_PLAINTEXT__11_0].Mux(tmp_max_len_4[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger longest_even_0(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_max_len_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(1);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(1)) {\n            current_length_2[_MPC_PLAINTEXT__10_0] = current_length_5_Y[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_length_3[_MPC_PLAINTEXT__10_0] = (current_length_2[_MPC_PLAINTEXT__10_0] + _MPC_CONSTANT_1_Y); current_length_3_B[_MPC_PLAINTEXT__10_0] = current_length_3[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        current_length_5[_MPC_PLAINTEXT__10_0] = _1_2[_MPC_PLAINTEXT__10_0].Mux(current_length_3_B[_MPC_PLAINTEXT__10_0].Get(), current_length_4.Get()); current_length_5_Y[_MPC_PLAINTEXT__10_0] = current_length_5[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__11_0] = _6_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__11_0] = max_length_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__11_0] = (current_length_5[_MPC_PLAINTEXT__11_0] > max_length_2[_MPC_PLAINTEXT__11_0]);\n        tmp_max_len_4[_MPC_PLAINTEXT__11_0] = _2_2[_MPC_PLAINTEXT__11_0].Mux(current_length_5[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n        _3_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(tmp_max_len_4[_MPC_PLAINTEXT__11_0]) & to_share_wrapper(_MPC_CONSTANT_1));\n        _4_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__11_0]) == to_share_wrapper(_MPC_CONSTANT_0));\n        max_length_4[_MPC_PLAINTEXT__11_0] = _4_2[_MPC_PLAINTEXT__11_0].Mux(tmp_max_len_4[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger longest_even_0(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_max_len_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(1);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(1)) {\n            current_length_2[_MPC_PLAINTEXT__10_0] = current_length_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_length_3[_MPC_PLAINTEXT__10_0] = (current_length_2[_MPC_PLAINTEXT__10_0] + _MPC_CONSTANT_1);\n        current_length_5[_MPC_PLAINTEXT__10_0] = _1_2[_MPC_PLAINTEXT__10_0].Mux(current_length_3[_MPC_PLAINTEXT__10_0].Get(), current_length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__11_0] = _6_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__11_0] = max_length_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__11_0] = (current_length_5[_MPC_PLAINTEXT__11_0] > max_length_2[_MPC_PLAINTEXT__11_0]);\n        tmp_max_len_4[_MPC_PLAINTEXT__11_0] = _2_2[_MPC_PLAINTEXT__11_0].Mux(current_length_5[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n        _3_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(tmp_max_len_4[_MPC_PLAINTEXT__11_0]) & to_share_wrapper(_MPC_CONSTANT_1));\n        _4_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__11_0]) == to_share_wrapper(_MPC_CONSTANT_0));\n        max_length_4[_MPC_PLAINTEXT__11_0] = _4_2[_MPC_PLAINTEXT__11_0].Mux(tmp_max_len_4[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger longest_even_0(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_max_len_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(1);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(1)) {\n            current_length_2[_MPC_PLAINTEXT__10_0] = current_length_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_length_3[_MPC_PLAINTEXT__10_0] = (current_length_2[_MPC_PLAINTEXT__10_0] + _MPC_CONSTANT_1);\n        current_length_5[_MPC_PLAINTEXT__10_0] = _1_2[_MPC_PLAINTEXT__10_0].Mux(current_length_3[_MPC_PLAINTEXT__10_0].Get(), current_length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__11_0] = _6_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__11_0] = max_length_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__11_0] = (current_length_5[_MPC_PLAINTEXT__11_0] > max_length_2[_MPC_PLAINTEXT__11_0]);\n        tmp_max_len_4[_MPC_PLAINTEXT__11_0] = _2_2[_MPC_PLAINTEXT__11_0].Mux(current_length_5[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n        _3_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(tmp_max_len_4[_MPC_PLAINTEXT__11_0]) & to_share_wrapper(_MPC_CONSTANT_1));\n        _4_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__11_0]) == to_share_wrapper(_MPC_CONSTANT_0));\n        max_length_4[_MPC_PLAINTEXT__11_0] = _4_2[_MPC_PLAINTEXT__11_0].Mux(tmp_max_len_4[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger longest_even_0(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> tmp_max_len_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(1);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(1)) {\n            current_length_2[_MPC_PLAINTEXT__10_0] = current_length_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_length_3[_MPC_PLAINTEXT__10_0] = (current_length_2[_MPC_PLAINTEXT__10_0] + _MPC_CONSTANT_1);\n        current_length_5[_MPC_PLAINTEXT__10_0] = _1_2[_MPC_PLAINTEXT__10_0].Mux(current_length_3[_MPC_PLAINTEXT__10_0].Get(), current_length_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(1);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__11_0] = _6_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(1)) {\n            max_length_2[_MPC_PLAINTEXT__11_0] = max_length_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _2_2[_MPC_PLAINTEXT__11_0] = (current_length_5[_MPC_PLAINTEXT__11_0] > max_length_2[_MPC_PLAINTEXT__11_0]);\n        tmp_max_len_4[_MPC_PLAINTEXT__11_0] = _2_2[_MPC_PLAINTEXT__11_0].Mux(current_length_5[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n        _3_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(tmp_max_len_4[_MPC_PLAINTEXT__11_0]) & to_share_wrapper(_MPC_CONSTANT_1));\n        _4_2[_MPC_PLAINTEXT__11_0] = (to_share_wrapper(_3_2[_MPC_PLAINTEXT__11_0]) == to_share_wrapper(_MPC_CONSTANT_0));\n        max_length_4[_MPC_PLAINTEXT__11_0] = _4_2[_MPC_PLAINTEXT__11_0].Mux(tmp_max_len_4[_MPC_PLAINTEXT__11_0].Get(), max_length_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "N/A",
                "B": "ERROR: ",
                "X": "N/A",
                "Y": "N/A",
                "mixed": "ERROR: "
            },
            "dataSent": {
                "A": "N/A",
                "B": "ERROR: ",
                "X": "N/A",
                "Y": "N/A",
                "mixed": "ERROR: "
            },
            "time": {
                "A": "N/A",
                "B": "ERROR: ",
                "X": "N/A",
                "Y": "N/A",
                "mixed": "ERROR: "
            }
        }
    },
    "longest_odd_10": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger longest_odd_10(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_6((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s2_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__16_0] = _10_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__16_0] = s2_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            current_length_2[_MPC_PLAINTEXT__17_0] = current_length_6[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        current_length_5[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(current_length_4.Get(), current_length_2[_MPC_PLAINTEXT__17_0].Get());\n        current_length_3[_MPC_PLAINTEXT__17_0] = (current_length_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        current_length_6[_MPC_PLAINTEXT__17_0] = s1_2[_MPC_PLAINTEXT__17_0].Mux(current_length_3[_MPC_PLAINTEXT__17_0].Get(), current_length_5[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(current_length_6, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__18_0] = _9_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            max_length_2[_MPC_PLAINTEXT__18_0] = max_length_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__18_0] = (current_length_6[_MPC_PLAINTEXT__18_0] > max_length_2[_MPC_PLAINTEXT__18_0]);\n        _7_2[_MPC_PLAINTEXT__18_0] = (to_share_wrapper(_5_2[_MPC_PLAINTEXT__18_0]) & to_share_wrapper(_6_2[_MPC_PLAINTEXT__18_0]));\n        max_length_4[_MPC_PLAINTEXT__18_0] = _7_2[_MPC_PLAINTEXT__18_0].Mux(current_length_6[_MPC_PLAINTEXT__18_0].Get(), max_length_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger longest_odd_10(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_6((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s2_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__16_0] = _10_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__16_0] = s2_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            current_length_2[_MPC_PLAINTEXT__17_0] = current_length_6[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        current_length_5[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(current_length_4.Get(), current_length_2[_MPC_PLAINTEXT__17_0].Get());\n        current_length_3[_MPC_PLAINTEXT__17_0] = (current_length_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        current_length_6[_MPC_PLAINTEXT__17_0] = s1_2[_MPC_PLAINTEXT__17_0].Mux(current_length_3[_MPC_PLAINTEXT__17_0].Get(), current_length_5[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(current_length_6, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__18_0] = _9_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            max_length_2[_MPC_PLAINTEXT__18_0] = max_length_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__18_0] = (current_length_6[_MPC_PLAINTEXT__18_0] > max_length_2[_MPC_PLAINTEXT__18_0]);\n        _7_2[_MPC_PLAINTEXT__18_0] = (to_share_wrapper(_5_2[_MPC_PLAINTEXT__18_0]) & to_share_wrapper(_6_2[_MPC_PLAINTEXT__18_0]));\n        max_length_4[_MPC_PLAINTEXT__18_0] = _7_2[_MPC_PLAINTEXT__18_0].Mux(current_length_6[_MPC_PLAINTEXT__18_0].Get(), max_length_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger longest_odd_10(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_6((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s2_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__16_0] = _10_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__16_0] = s2_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_6_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0]; current_length_2_B[_MPC_PLAINTEXT__17_0] = current_length_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            current_length_2[_MPC_PLAINTEXT__17_0] = current_length_6_Y[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))]; current_length_2_B[_MPC_PLAINTEXT__17_0] = current_length_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        current_length_5[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(current_length_4.Get(), current_length_2_B[_MPC_PLAINTEXT__17_0].Get());\n        current_length_3[_MPC_PLAINTEXT__17_0] = (current_length_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1_Y); current_length_3_B[_MPC_PLAINTEXT__17_0] = current_length_3[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        current_length_6[_MPC_PLAINTEXT__17_0] = s1_2[_MPC_PLAINTEXT__17_0].Mux(current_length_3_B[_MPC_PLAINTEXT__17_0].Get(), current_length_5[_MPC_PLAINTEXT__17_0].Get()); current_length_6_Y[_MPC_PLAINTEXT__17_0] = current_length_6[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(current_length_6, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__18_0] = _9_0[_MPC_PLAINTEXT__18_0]; max_length_2_B[_MPC_PLAINTEXT__18_0] = max_length_2[_MPC_PLAINTEXT__18_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            max_length_2[_MPC_PLAINTEXT__18_0] = max_length_4_Y[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))]; max_length_2_B[_MPC_PLAINTEXT__18_0] = max_length_2[_MPC_PLAINTEXT__18_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        _6_2[_MPC_PLAINTEXT__18_0] = (current_length_6_Y[_MPC_PLAINTEXT__18_0] > max_length_2[_MPC_PLAINTEXT__18_0]); _6_2_B[_MPC_PLAINTEXT__18_0] = _6_2[_MPC_PLAINTEXT__18_0].Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        _7_2[_MPC_PLAINTEXT__18_0] = (to_share_wrapper(_5_2[_MPC_PLAINTEXT__18_0]) & to_share_wrapper(_6_2_B[_MPC_PLAINTEXT__18_0]));\n        max_length_4[_MPC_PLAINTEXT__18_0] = _7_2[_MPC_PLAINTEXT__18_0].Mux(current_length_6[_MPC_PLAINTEXT__18_0].Get(), max_length_2_B[_MPC_PLAINTEXT__18_0].Get()); max_length_4_Y[_MPC_PLAINTEXT__18_0] = max_length_4[_MPC_PLAINTEXT__18_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _15_0_Y; _15_0_Y = drop_dim_monoreturn(vectorized_access(max_length_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger longest_odd_10(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_6((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s2_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__16_0] = _10_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__16_0] = s2_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            current_length_2[_MPC_PLAINTEXT__17_0] = current_length_6[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        current_length_5[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(current_length_4.Get(), current_length_2[_MPC_PLAINTEXT__17_0].Get());\n        current_length_3[_MPC_PLAINTEXT__17_0] = (current_length_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        current_length_6[_MPC_PLAINTEXT__17_0] = s1_2[_MPC_PLAINTEXT__17_0].Mux(current_length_3[_MPC_PLAINTEXT__17_0].Get(), current_length_5[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(current_length_6, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__18_0] = _9_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            max_length_2[_MPC_PLAINTEXT__18_0] = max_length_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__18_0] = (current_length_6[_MPC_PLAINTEXT__18_0] > max_length_2[_MPC_PLAINTEXT__18_0]);\n        _7_2[_MPC_PLAINTEXT__18_0] = (to_share_wrapper(_5_2[_MPC_PLAINTEXT__18_0]) & to_share_wrapper(_6_2[_MPC_PLAINTEXT__18_0]));\n        max_length_4[_MPC_PLAINTEXT__18_0] = _7_2[_MPC_PLAINTEXT__18_0].Mux(current_length_6[_MPC_PLAINTEXT__18_0].Get(), max_length_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger longest_odd_10(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_6((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s2_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__16_0] = _10_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__16_0] = s2_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            current_length_2[_MPC_PLAINTEXT__17_0] = current_length_6[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        current_length_5[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(current_length_4.Get(), current_length_2[_MPC_PLAINTEXT__17_0].Get());\n        current_length_3[_MPC_PLAINTEXT__17_0] = (current_length_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        current_length_6[_MPC_PLAINTEXT__17_0] = s1_2[_MPC_PLAINTEXT__17_0].Mux(current_length_3[_MPC_PLAINTEXT__17_0].Get(), current_length_5[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(current_length_6, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__18_0] = _9_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            max_length_2[_MPC_PLAINTEXT__18_0] = max_length_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__18_0] = (current_length_6[_MPC_PLAINTEXT__18_0] > max_length_2[_MPC_PLAINTEXT__18_0]);\n        _7_2[_MPC_PLAINTEXT__18_0] = (to_share_wrapper(_5_2[_MPC_PLAINTEXT__18_0]) & to_share_wrapper(_6_2[_MPC_PLAINTEXT__18_0]));\n        max_length_4[_MPC_PLAINTEXT__18_0] = _7_2[_MPC_PLAINTEXT__18_0].Mux(current_length_6[_MPC_PLAINTEXT__18_0].Get(), max_length_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger longest_odd_10(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_6((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s2_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__16_0] = _10_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__16_0] = s2_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_6_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0]; current_length_2_B[_MPC_PLAINTEXT__17_0] = current_length_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            current_length_2[_MPC_PLAINTEXT__17_0] = current_length_6_Y[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))]; current_length_2_B[_MPC_PLAINTEXT__17_0] = current_length_2[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        current_length_5[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(current_length_4.Get(), current_length_2_B[_MPC_PLAINTEXT__17_0].Get());\n        current_length_3[_MPC_PLAINTEXT__17_0] = (current_length_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1_Y); current_length_3_B[_MPC_PLAINTEXT__17_0] = current_length_3[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        current_length_6[_MPC_PLAINTEXT__17_0] = s1_2[_MPC_PLAINTEXT__17_0].Mux(current_length_3_B[_MPC_PLAINTEXT__17_0].Get(), current_length_5[_MPC_PLAINTEXT__17_0].Get()); current_length_6_Y[_MPC_PLAINTEXT__17_0] = current_length_6[_MPC_PLAINTEXT__17_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(current_length_6, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__18_0] = _9_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            max_length_2[_MPC_PLAINTEXT__18_0] = max_length_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__18_0] = (current_length_6[_MPC_PLAINTEXT__18_0] > max_length_2[_MPC_PLAINTEXT__18_0]);\n        _7_2[_MPC_PLAINTEXT__18_0] = (to_share_wrapper(_5_2[_MPC_PLAINTEXT__18_0]) & to_share_wrapper(_6_2[_MPC_PLAINTEXT__18_0]));\n        max_length_4[_MPC_PLAINTEXT__18_0] = _7_2[_MPC_PLAINTEXT__18_0].Mux(current_length_6[_MPC_PLAINTEXT__18_0].Get(), max_length_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger longest_odd_10(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_6((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s2_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__16_0] = _10_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__16_0] = s2_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            current_length_2[_MPC_PLAINTEXT__17_0] = current_length_6[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        current_length_5[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(current_length_4.Get(), current_length_2[_MPC_PLAINTEXT__17_0].Get());\n        current_length_3[_MPC_PLAINTEXT__17_0] = (current_length_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        current_length_6[_MPC_PLAINTEXT__17_0] = s1_2[_MPC_PLAINTEXT__17_0].Mux(current_length_3[_MPC_PLAINTEXT__17_0].Get(), current_length_5[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(current_length_6, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__18_0] = _9_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            max_length_2[_MPC_PLAINTEXT__18_0] = max_length_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__18_0] = (current_length_6[_MPC_PLAINTEXT__18_0] > max_length_2[_MPC_PLAINTEXT__18_0]);\n        _7_2[_MPC_PLAINTEXT__18_0] = (to_share_wrapper(_5_2[_MPC_PLAINTEXT__18_0]) & to_share_wrapper(_6_2[_MPC_PLAINTEXT__18_0]));\n        max_length_4[_MPC_PLAINTEXT__18_0] = _7_2[_MPC_PLAINTEXT__18_0].Mux(current_length_6[_MPC_PLAINTEXT__18_0].Get(), max_length_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger longest_odd_10(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_6((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s2_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__16_0] = _10_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__16_0] = s2_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            current_length_2[_MPC_PLAINTEXT__17_0] = current_length_6[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        current_length_5[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(current_length_4.Get(), current_length_2[_MPC_PLAINTEXT__17_0].Get());\n        current_length_3[_MPC_PLAINTEXT__17_0] = (current_length_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        current_length_6[_MPC_PLAINTEXT__17_0] = s1_2[_MPC_PLAINTEXT__17_0].Mux(current_length_3[_MPC_PLAINTEXT__17_0].Get(), current_length_5[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(current_length_6, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__18_0] = _9_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            max_length_2[_MPC_PLAINTEXT__18_0] = max_length_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__18_0] = (current_length_6[_MPC_PLAINTEXT__18_0] > max_length_2[_MPC_PLAINTEXT__18_0]);\n        _7_2[_MPC_PLAINTEXT__18_0] = (to_share_wrapper(_5_2[_MPC_PLAINTEXT__18_0]) & to_share_wrapper(_6_2[_MPC_PLAINTEXT__18_0]));\n        max_length_4[_MPC_PLAINTEXT__18_0] = _7_2[_MPC_PLAINTEXT__18_0].Mux(current_length_6[_MPC_PLAINTEXT__18_0].Get(), max_length_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger longest_odd_10(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Syms_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _15_0;\n    encrypto::motion::SecureUnsignedInteger _16_0;\n    encrypto::motion::SecureUnsignedInteger _17_0;\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_length_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_5((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_length_6((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_length_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_length_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::ShareWrapper s2_1;\n    std::vector<encrypto::motion::ShareWrapper> s2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> s2_3((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__16_0;\n    std::uint32_t _MPC_PLAINTEXT__17_0;\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::uint32_t _MPC_PLAINTEXT_current_length_1;\n    std::uint32_t _MPC_PLAINTEXT_current_length_4;\n    std::uint32_t _MPC_PLAINTEXT_max_length_1;\n    bool _MPC_PLAINTEXT_s2_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    current_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_1 = std::uint32_t(0);\n    max_length_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_length_1 = std::uint32_t(0);\n    s2_1 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_s2_1 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(1)];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Syms_0[std::uint32_t(0)];}), {_MPC_PLAINTEXT_N_0}));\n    current_length_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_length_4 = std::uint32_t(0);\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_length_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return s2_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(s2_3, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__16_0 = std::uint32_t(0);\n    // Initialize phi values\n    s2_2[_MPC_PLAINTEXT__16_0] = _10_0[_MPC_PLAINTEXT__16_0];\n    for (; _MPC_PLAINTEXT__16_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__16_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__16_0 != std::uint32_t(0)) {\n            s2_2[_MPC_PLAINTEXT__16_0] = s2_3[(_MPC_PLAINTEXT__16_0 - std::uint32_t(1))];\n        }\n\n\n\n    }\n\n    vectorized_assign(s1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(s2_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__17_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_length_2[_MPC_PLAINTEXT__17_0] = _8_0[_MPC_PLAINTEXT__17_0];\n    for (; _MPC_PLAINTEXT__17_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__17_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__17_0 != std::uint32_t(0)) {\n            current_length_2[_MPC_PLAINTEXT__17_0] = current_length_6[(_MPC_PLAINTEXT__17_0 - std::uint32_t(1))];\n        }\n\n        current_length_5[_MPC_PLAINTEXT__17_0] = _2_2[_MPC_PLAINTEXT__17_0].Mux(current_length_4.Get(), current_length_2[_MPC_PLAINTEXT__17_0].Get());\n        current_length_3[_MPC_PLAINTEXT__17_0] = (current_length_2[_MPC_PLAINTEXT__17_0] + _MPC_CONSTANT_1);\n        current_length_6[_MPC_PLAINTEXT__17_0] = s1_2[_MPC_PLAINTEXT__17_0].Mux(current_length_3[_MPC_PLAINTEXT__17_0].Get(), current_length_5[_MPC_PLAINTEXT__17_0].Get());\n\n    }\n\n    vectorized_assign(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(current_length_6, {_MPC_PLAINTEXT_N_0}, {true}, {})) & to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n    vectorized_assign(_5_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_4_2, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(decltype(_MPC_CONSTANT_1)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return _MPC_CONSTANT_1;}), {_MPC_PLAINTEXT_N_0})))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_length_2[_MPC_PLAINTEXT__18_0] = _9_0[_MPC_PLAINTEXT__18_0];\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            max_length_2[_MPC_PLAINTEXT__18_0] = max_length_4[(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))];\n        }\n\n        _6_2[_MPC_PLAINTEXT__18_0] = (current_length_6[_MPC_PLAINTEXT__18_0] > max_length_2[_MPC_PLAINTEXT__18_0]);\n        _7_2[_MPC_PLAINTEXT__18_0] = (to_share_wrapper(_5_2[_MPC_PLAINTEXT__18_0]) & to_share_wrapper(_6_2[_MPC_PLAINTEXT__18_0]));\n        max_length_4[_MPC_PLAINTEXT__18_0] = _7_2[_MPC_PLAINTEXT__18_0].Mux(current_length_6[_MPC_PLAINTEXT__18_0].Get(), max_length_2[_MPC_PLAINTEXT__18_0].Get());\n\n    }\n\n    _15_0 = drop_dim_monoreturn(vectorized_access(max_length_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _15_0;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "N/A",
                "B": "program.options.binary = 32\ndef longest_odd_10(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    current_length_2 = [None] * (N_0)\n    current_length_3 = [None] * (N_0)\n    current_length_5 = [None] * (N_0)\n    current_length_6 = [None] * (N_0)\n    max_length_2 = [None] * (N_0)\n    max_length_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    current_length_1 = siv32(0)\n    max_length_1 = siv32(0)\n    s2_1 = sbit(0)\n    _11_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    current_length_4 = siv32(0)\n    _8_0 = _v.lift(lambda indices: current_length_1, [N_0])\n    _9_0 = _v.lift(lambda indices: max_length_1, [N_0])\n    _10_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_11_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s2_3, [N_0], [None], (_v.vectorized_access_simd(_11_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(_10_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(s2_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(s2_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s2_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(s2_2, [N_0], [None]).bit_not()))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(current_length_6, [N_0], [(_17_0 - 1)]))\n        _v.iterative_mux(current_length_5,_2_2,current_length_4,current_length_2,[N_0],[_17_0])\n        _v.vectorized_assign(current_length_3, [N_0], [_17_0], (_v.vectorized_access_simd(current_length_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(current_length_6,s1_2,current_length_3,current_length_5,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(current_length_6, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_4_2, [N_0], [None], _v.vectorized_access_simd(current_length_6, [N_0], [None]).bit_and(siv32(1)))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_4_2, [N_0], [None]) == siv32(1)))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(_9_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(max_length_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_18_0], (_v.vectorized_access_simd(current_length_6, [N_0], [_18_0]) > _v.vectorized_access_simd(max_length_2, [N_0], [_18_0])))\n        _v.vectorized_assign(_7_2, [N_0], [_18_0], _v.vectorized_access_simd(_5_2, [N_0], [_18_0]).bit_and(_v.vectorized_access_simd(_6_2, [N_0], [_18_0])))\n        _v.iterative_mux(max_length_4,_7_2,current_length_6,max_length_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(max_length_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(max_length_4, [N_0])\n    return _15_0",
                "X": "N/A",
                "Y": "N/A",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef longest_odd_10(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    current_length_2 = [None] * (N_0)\n    current_length_3 = [None] * (N_0)\n    current_length_5 = [None] * (N_0)\n    current_length_6 = [None] * (N_0)\n    max_length_2 = [None] * (N_0)\n    max_length_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    current_length_1 = siv32(0)\n    max_length_1 = siv32(0)\n    s2_1 = sbit(0)\n    _11_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    current_length_4 = siv32(0)\n    _8_0 = _v.lift(lambda indices: current_length_1, [N_0])\n    _9_0 = _v.lift(lambda indices: max_length_1, [N_0])\n    _10_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_11_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s2_3, [N_0], [None], (_v.vectorized_access_simd(_11_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(_10_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(s2_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(s2_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s2_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(s2_2, [N_0], [None]).bit_not()))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(current_length_6, [N_0], [(_17_0 - 1)]))\n        _v.iterative_mux(current_length_5,_2_2,current_length_4,current_length_2,[N_0],[_17_0])\n        _v.vectorized_assign(current_length_3, [N_0], [_17_0], (_v.vectorized_access_simd(current_length_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(current_length_6,s1_2,current_length_3,current_length_5,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(current_length_6, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_4_2, [N_0], [None], _v.vectorized_access_simd(current_length_6, [N_0], [None]).bit_and(siv32(1)))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_4_2, [N_0], [None]) == siv32(1)))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(_9_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(max_length_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_18_0], (_v.vectorized_access_simd(current_length_6, [N_0], [_18_0]) > _v.vectorized_access_simd(max_length_2, [N_0], [_18_0])))\n        _v.vectorized_assign(_7_2, [N_0], [_18_0], _v.vectorized_access_simd(_5_2, [N_0], [_18_0]).bit_and(_v.vectorized_access_simd(_6_2, [N_0], [_18_0])))\n        _v.iterative_mux(max_length_4,_7_2,current_length_6,max_length_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(max_length_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(max_length_4, [N_0])\n    return _15_0"
            },
            "dataSent": {
                "A": "N/A",
                "B": "program.options.binary = 32\ndef longest_odd_10(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    current_length_2 = [None] * (N_0)\n    current_length_3 = [None] * (N_0)\n    current_length_5 = [None] * (N_0)\n    current_length_6 = [None] * (N_0)\n    max_length_2 = [None] * (N_0)\n    max_length_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    current_length_1 = siv32(0)\n    max_length_1 = siv32(0)\n    s2_1 = sbit(0)\n    _11_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    current_length_4 = siv32(0)\n    _8_0 = _v.lift(lambda indices: current_length_1, [N_0])\n    _9_0 = _v.lift(lambda indices: max_length_1, [N_0])\n    _10_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_11_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s2_3, [N_0], [None], (_v.vectorized_access_simd(_11_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(_10_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(s2_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(s2_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s2_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(s2_2, [N_0], [None]).bit_not()))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(current_length_6, [N_0], [(_17_0 - 1)]))\n        _v.iterative_mux(current_length_5,_2_2,current_length_4,current_length_2,[N_0],[_17_0])\n        _v.vectorized_assign(current_length_3, [N_0], [_17_0], (_v.vectorized_access_simd(current_length_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(current_length_6,s1_2,current_length_3,current_length_5,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(current_length_6, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_4_2, [N_0], [None], _v.vectorized_access_simd(current_length_6, [N_0], [None]).bit_and(siv32(1)))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_4_2, [N_0], [None]) == siv32(1)))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(_9_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(max_length_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_18_0], (_v.vectorized_access_simd(current_length_6, [N_0], [_18_0]) > _v.vectorized_access_simd(max_length_2, [N_0], [_18_0])))\n        _v.vectorized_assign(_7_2, [N_0], [_18_0], _v.vectorized_access_simd(_5_2, [N_0], [_18_0]).bit_and(_v.vectorized_access_simd(_6_2, [N_0], [_18_0])))\n        _v.iterative_mux(max_length_4,_7_2,current_length_6,max_length_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(max_length_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(max_length_4, [N_0])\n    return _15_0",
                "X": "N/A",
                "Y": "N/A",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef longest_odd_10(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    current_length_2 = [None] * (N_0)\n    current_length_3 = [None] * (N_0)\n    current_length_5 = [None] * (N_0)\n    current_length_6 = [None] * (N_0)\n    max_length_2 = [None] * (N_0)\n    max_length_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    current_length_1 = siv32(0)\n    max_length_1 = siv32(0)\n    s2_1 = sbit(0)\n    _11_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    current_length_4 = siv32(0)\n    _8_0 = _v.lift(lambda indices: current_length_1, [N_0])\n    _9_0 = _v.lift(lambda indices: max_length_1, [N_0])\n    _10_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_11_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s2_3, [N_0], [None], (_v.vectorized_access_simd(_11_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(_10_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(s2_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(s2_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s2_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(s2_2, [N_0], [None]).bit_not()))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(current_length_6, [N_0], [(_17_0 - 1)]))\n        _v.iterative_mux(current_length_5,_2_2,current_length_4,current_length_2,[N_0],[_17_0])\n        _v.vectorized_assign(current_length_3, [N_0], [_17_0], (_v.vectorized_access_simd(current_length_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(current_length_6,s1_2,current_length_3,current_length_5,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(current_length_6, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_4_2, [N_0], [None], _v.vectorized_access_simd(current_length_6, [N_0], [None]).bit_and(siv32(1)))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_4_2, [N_0], [None]) == siv32(1)))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(_9_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(max_length_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_18_0], (_v.vectorized_access_simd(current_length_6, [N_0], [_18_0]) > _v.vectorized_access_simd(max_length_2, [N_0], [_18_0])))\n        _v.vectorized_assign(_7_2, [N_0], [_18_0], _v.vectorized_access_simd(_5_2, [N_0], [_18_0]).bit_and(_v.vectorized_access_simd(_6_2, [N_0], [_18_0])))\n        _v.iterative_mux(max_length_4,_7_2,current_length_6,max_length_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(max_length_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(max_length_4, [N_0])\n    return _15_0"
            },
            "time": {
                "A": "N/A",
                "B": "program.options.binary = 32\ndef longest_odd_10(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    current_length_2 = [None] * (N_0)\n    current_length_3 = [None] * (N_0)\n    current_length_5 = [None] * (N_0)\n    current_length_6 = [None] * (N_0)\n    max_length_2 = [None] * (N_0)\n    max_length_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    current_length_1 = siv32(0)\n    max_length_1 = siv32(0)\n    s2_1 = sbit(0)\n    _11_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    current_length_4 = siv32(0)\n    _8_0 = _v.lift(lambda indices: current_length_1, [N_0])\n    _9_0 = _v.lift(lambda indices: max_length_1, [N_0])\n    _10_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_11_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s2_3, [N_0], [None], (_v.vectorized_access_simd(_11_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(_10_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(s2_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(s2_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s2_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(s2_2, [N_0], [None]).bit_not()))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(current_length_6, [N_0], [(_17_0 - 1)]))\n        _v.iterative_mux(current_length_5,_2_2,current_length_4,current_length_2,[N_0],[_17_0])\n        _v.vectorized_assign(current_length_3, [N_0], [_17_0], (_v.vectorized_access_simd(current_length_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(current_length_6,s1_2,current_length_3,current_length_5,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(current_length_6, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_4_2, [N_0], [None], _v.vectorized_access_simd(current_length_6, [N_0], [None]).bit_and(siv32(1)))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_4_2, [N_0], [None]) == siv32(1)))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(_9_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(max_length_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_18_0], (_v.vectorized_access_simd(current_length_6, [N_0], [_18_0]) > _v.vectorized_access_simd(max_length_2, [N_0], [_18_0])))\n        _v.vectorized_assign(_7_2, [N_0], [_18_0], _v.vectorized_access_simd(_5_2, [N_0], [_18_0]).bit_and(_v.vectorized_access_simd(_6_2, [N_0], [_18_0])))\n        _v.iterative_mux(max_length_4,_7_2,current_length_6,max_length_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(max_length_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(max_length_4, [N_0])\n    return _15_0",
                "X": "N/A",
                "Y": "N/A",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef longest_odd_10(Seq_0, N_0, Syms_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _10_0 = [None] * (N_0)\n    _11_0 = [None] * (N_0)\n    _12_0 = [None] * (N_0)\n    _14_0 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _4_2 = [None] * (N_0)\n    _5_2 = [None] * (N_0)\n    _6_2 = [None] * (N_0)\n    _7_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    current_length_2 = [None] * (N_0)\n    current_length_3 = [None] * (N_0)\n    current_length_5 = [None] * (N_0)\n    current_length_6 = [None] * (N_0)\n    max_length_2 = [None] * (N_0)\n    max_length_4 = [None] * (N_0)\n    s1_2 = [None] * (N_0)\n    s2_2 = [None] * (N_0)\n    s2_3 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    current_length_1 = siv32(0)\n    max_length_1 = siv32(0)\n    s2_1 = sbit(0)\n    _11_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _12_0 = _v.lift(lambda indices: (Syms_0[1]), [N_0])\n    _14_0 = _v.lift(lambda indices: (Syms_0[0]), [N_0])\n    current_length_4 = siv32(0)\n    _8_0 = _v.lift(lambda indices: current_length_1, [N_0])\n    _9_0 = _v.lift(lambda indices: max_length_1, [N_0])\n    _10_0 = _v.lift(lambda indices: s2_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_11_0, [N_0], [None]) == _v.vectorized_access_simd(_12_0, [N_0], [None])))\n    _v.vectorized_assign(s2_3, [N_0], [None], (_v.vectorized_access_simd(_11_0, [N_0], [None]) == _v.vectorized_access_simd(_14_0, [N_0], [None])))\n    for _16_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _16_0 == 0:\n            _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(_10_0, [N_0], [_16_0]))\n        else:\n            _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(s2_3, [N_0], [(_16_0 - 1)]))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(s2_2, [N_0], [_16_0], _v.vectorized_access(s2_3, [N_0], [(_16_0 - 1)]))\n    _v.vectorized_assign(s1_2, [N_0], [None], _v.vectorized_access_simd(s2_2, [N_0], [None]).bit_and(_v.vectorized_access_simd(_1_2, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(s2_2, [N_0], [None]).bit_not()))\n    for _17_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _17_0 == 0:\n            _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(_8_0, [N_0], [_17_0]))\n        else:\n            _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(current_length_6, [N_0], [(_17_0 - 1)]))\n        _v.iterative_mux(current_length_5,_2_2,current_length_4,current_length_2,[N_0],[_17_0])\n        _v.vectorized_assign(current_length_3, [N_0], [_17_0], (_v.vectorized_access_simd(current_length_2, [N_0], [_17_0]) + siv32(1)))\n        _v.iterative_mux(current_length_6,s1_2,current_length_3,current_length_5,[N_0],[_17_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_length_2, [N_0], [_17_0], _v.vectorized_access(current_length_6, [N_0], [(_17_0 - 1)]))\n    _v.vectorized_assign(_4_2, [N_0], [None], _v.vectorized_access_simd(current_length_6, [N_0], [None]).bit_and(siv32(1)))\n    _v.vectorized_assign(_5_2, [N_0], [None], (_v.vectorized_access_simd(_4_2, [N_0], [None]) == siv32(1)))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(_9_0, [N_0], [_18_0]))\n        else:\n            _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(max_length_4, [N_0], [(_18_0 - 1)]))\n        _v.vectorized_assign(_6_2, [N_0], [_18_0], (_v.vectorized_access_simd(current_length_6, [N_0], [_18_0]) > _v.vectorized_access_simd(max_length_2, [N_0], [_18_0])))\n        _v.vectorized_assign(_7_2, [N_0], [_18_0], _v.vectorized_access_simd(_5_2, [N_0], [_18_0]).bit_and(_v.vectorized_access_simd(_6_2, [N_0], [_18_0])))\n        _v.iterative_mux(max_length_4,_7_2,current_length_6,max_length_2,[N_0],[_18_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_length_2, [N_0], [_18_0], _v.vectorized_access(max_length_4, [N_0], [(_18_0 - 1)]))\n    _15_0 = _v.drop_dim(max_length_4, [N_0])\n    return _15_0"
            }
        }
    },
    "matrix_multiply": {
        "MOTION": {
            "commRounds": {
                "A": "ERROR: '!9!0'",
                "B": "ERROR: '!9!0'",
                "Y": "ERROR: '!9!0'",
                "mixed": "ERROR: '!9!0'"
            },
            "dataSent": {
                "A": "ERROR: '!9!0'",
                "B": "ERROR: '!9!0'",
                "Y": "ERROR: '!9!0'",
                "mixed": "ERROR: '!9!0'"
            },
            "time": {
                "A": "ERROR: '!9!0'",
                "B": "ERROR: '!9!0'",
                "Y": "ERROR: '!9!0'",
                "mixed": "ERROR: '!9!0'"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "ERROR: ",
                "B": "ERROR: ",
                "X": "ERROR: ",
                "Y": "ERROR: ",
                "mixed": "ERROR: "
            },
            "dataSent": {
                "A": "ERROR: ",
                "B": "ERROR: ",
                "X": "ERROR: ",
                "Y": "ERROR: ",
                "mixed": "ERROR: "
            },
            "time": {
                "A": "ERROR: ",
                "B": "ERROR: ",
                "X": "ERROR: ",
                "Y": "ERROR: ",
                "mixed": "ERROR: "
            }
        }
    },
    "max_dist_between_syms": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger max_dist_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_dist_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_1;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_4;\n    std::uint32_t _MPC_PLAINTEXT_max_dist_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_dist_1 = std::uint32_t(0);\n    current_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_dist_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_dist_2[_MPC_PLAINTEXT__9_0] = _5_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(0)) {\n            current_dist_2[_MPC_PLAINTEXT__9_0] = current_dist_5[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        current_dist_3[_MPC_PLAINTEXT__9_0] = (current_dist_2[_MPC_PLAINTEXT__9_0] + _MPC_CONSTANT_1);\n        current_dist_5[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(current_dist_3[_MPC_PLAINTEXT__9_0].Get(), current_dist_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_dist_2[_MPC_PLAINTEXT__10_0] = _4_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            max_dist_2[_MPC_PLAINTEXT__10_0] = max_dist_4[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__10_0] = (current_dist_5[_MPC_PLAINTEXT__10_0] > max_dist_2[_MPC_PLAINTEXT__10_0]);\n        max_dist_4[_MPC_PLAINTEXT__10_0] = _3_2[_MPC_PLAINTEXT__10_0].Mux(current_dist_5[_MPC_PLAINTEXT__10_0].Get(), max_dist_2[_MPC_PLAINTEXT__10_0].Get());\n\n    }\n\n    _8_0 = drop_dim_monoreturn(vectorized_access(max_dist_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _8_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger max_dist_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_dist_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_1;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_4;\n    std::uint32_t _MPC_PLAINTEXT_max_dist_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_dist_1 = std::uint32_t(0);\n    current_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_dist_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_dist_2[_MPC_PLAINTEXT__9_0] = _5_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(0)) {\n            current_dist_2[_MPC_PLAINTEXT__9_0] = current_dist_5[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        current_dist_3[_MPC_PLAINTEXT__9_0] = (current_dist_2[_MPC_PLAINTEXT__9_0] + _MPC_CONSTANT_1);\n        current_dist_5[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(current_dist_3[_MPC_PLAINTEXT__9_0].Get(), current_dist_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_dist_2[_MPC_PLAINTEXT__10_0] = _4_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            max_dist_2[_MPC_PLAINTEXT__10_0] = max_dist_4[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__10_0] = (current_dist_5[_MPC_PLAINTEXT__10_0] > max_dist_2[_MPC_PLAINTEXT__10_0]);\n        max_dist_4[_MPC_PLAINTEXT__10_0] = _3_2[_MPC_PLAINTEXT__10_0].Mux(current_dist_5[_MPC_PLAINTEXT__10_0].Get(), max_dist_2[_MPC_PLAINTEXT__10_0].Get());\n\n    }\n\n    _8_0 = drop_dim_monoreturn(vectorized_access(max_dist_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _8_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger max_dist_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_dist_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_1;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_4;\n    std::uint32_t _MPC_PLAINTEXT_max_dist_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_dist_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_max_dist_1 = std::uint32_t(0);\n    current_dist_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_current_dist_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_dist_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_5_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_dist_2[_MPC_PLAINTEXT__9_0] = _5_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(0)) {\n            current_dist_2[_MPC_PLAINTEXT__9_0] = current_dist_5_Y[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        current_dist_3[_MPC_PLAINTEXT__9_0] = (current_dist_2[_MPC_PLAINTEXT__9_0] + _MPC_CONSTANT_1_Y); current_dist_3_B[_MPC_PLAINTEXT__9_0] = current_dist_3[_MPC_PLAINTEXT__9_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        current_dist_5[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(current_dist_3_B[_MPC_PLAINTEXT__9_0].Get(), current_dist_4.Get()); current_dist_5_Y[_MPC_PLAINTEXT__9_0] = current_dist_5[_MPC_PLAINTEXT__9_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_dist_2[_MPC_PLAINTEXT__10_0] = _4_0[_MPC_PLAINTEXT__10_0]; max_dist_2_B[_MPC_PLAINTEXT__10_0] = max_dist_2[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            max_dist_2[_MPC_PLAINTEXT__10_0] = max_dist_4_Y[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))]; max_dist_2_B[_MPC_PLAINTEXT__10_0] = max_dist_2[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        _3_2[_MPC_PLAINTEXT__10_0] = (current_dist_5_Y[_MPC_PLAINTEXT__10_0] > max_dist_2[_MPC_PLAINTEXT__10_0]); _3_2_B[_MPC_PLAINTEXT__10_0] = _3_2[_MPC_PLAINTEXT__10_0].Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        max_dist_4[_MPC_PLAINTEXT__10_0] = _3_2_B[_MPC_PLAINTEXT__10_0].Mux(current_dist_5[_MPC_PLAINTEXT__10_0].Get(), max_dist_2_B[_MPC_PLAINTEXT__10_0].Get()); max_dist_4_Y[_MPC_PLAINTEXT__10_0] = max_dist_4[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    _8_0 = drop_dim_monoreturn(vectorized_access(max_dist_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _8_0_Y; _8_0_Y = drop_dim_monoreturn(vectorized_access(max_dist_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _8_0;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger max_dist_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_dist_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_1;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_4;\n    std::uint32_t _MPC_PLAINTEXT_max_dist_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_dist_1 = std::uint32_t(0);\n    current_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_dist_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_dist_2[_MPC_PLAINTEXT__9_0] = _5_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(0)) {\n            current_dist_2[_MPC_PLAINTEXT__9_0] = current_dist_5[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        current_dist_3[_MPC_PLAINTEXT__9_0] = (current_dist_2[_MPC_PLAINTEXT__9_0] + _MPC_CONSTANT_1);\n        current_dist_5[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(current_dist_3[_MPC_PLAINTEXT__9_0].Get(), current_dist_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_dist_2[_MPC_PLAINTEXT__10_0] = _4_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            max_dist_2[_MPC_PLAINTEXT__10_0] = max_dist_4[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__10_0] = (current_dist_5[_MPC_PLAINTEXT__10_0] > max_dist_2[_MPC_PLAINTEXT__10_0]);\n        max_dist_4[_MPC_PLAINTEXT__10_0] = _3_2[_MPC_PLAINTEXT__10_0].Mux(current_dist_5[_MPC_PLAINTEXT__10_0].Get(), max_dist_2[_MPC_PLAINTEXT__10_0].Get());\n\n    }\n\n    _8_0 = drop_dim_monoreturn(vectorized_access(max_dist_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _8_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger max_dist_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_dist_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_1;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_4;\n    std::uint32_t _MPC_PLAINTEXT_max_dist_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_dist_1 = std::uint32_t(0);\n    current_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_dist_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_dist_2[_MPC_PLAINTEXT__9_0] = _5_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(0)) {\n            current_dist_2[_MPC_PLAINTEXT__9_0] = current_dist_5[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        current_dist_3[_MPC_PLAINTEXT__9_0] = (current_dist_2[_MPC_PLAINTEXT__9_0] + _MPC_CONSTANT_1);\n        current_dist_5[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(current_dist_3[_MPC_PLAINTEXT__9_0].Get(), current_dist_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_dist_2[_MPC_PLAINTEXT__10_0] = _4_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            max_dist_2[_MPC_PLAINTEXT__10_0] = max_dist_4[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__10_0] = (current_dist_5[_MPC_PLAINTEXT__10_0] > max_dist_2[_MPC_PLAINTEXT__10_0]);\n        max_dist_4[_MPC_PLAINTEXT__10_0] = _3_2[_MPC_PLAINTEXT__10_0].Mux(current_dist_5[_MPC_PLAINTEXT__10_0].Get(), max_dist_2[_MPC_PLAINTEXT__10_0].Get());\n\n    }\n\n    _8_0 = drop_dim_monoreturn(vectorized_access(max_dist_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _8_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger max_dist_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_dist_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_1;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_4;\n    std::uint32_t _MPC_PLAINTEXT_max_dist_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_dist_1 = std::uint32_t(0);\n    current_dist_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_current_dist_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_dist_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_5_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_dist_2[_MPC_PLAINTEXT__9_0] = _5_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(0)) {\n            current_dist_2[_MPC_PLAINTEXT__9_0] = current_dist_5_Y[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        current_dist_3[_MPC_PLAINTEXT__9_0] = (current_dist_2[_MPC_PLAINTEXT__9_0] + _MPC_CONSTANT_1_Y); current_dist_3_B[_MPC_PLAINTEXT__9_0] = current_dist_3[_MPC_PLAINTEXT__9_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        current_dist_5[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(current_dist_3_B[_MPC_PLAINTEXT__9_0].Get(), current_dist_4.Get()); current_dist_5_Y[_MPC_PLAINTEXT__9_0] = current_dist_5[_MPC_PLAINTEXT__9_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_dist_2[_MPC_PLAINTEXT__10_0] = _4_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            max_dist_2[_MPC_PLAINTEXT__10_0] = max_dist_4[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__10_0] = (current_dist_5[_MPC_PLAINTEXT__10_0] > max_dist_2[_MPC_PLAINTEXT__10_0]);\n        max_dist_4[_MPC_PLAINTEXT__10_0] = _3_2[_MPC_PLAINTEXT__10_0].Mux(current_dist_5[_MPC_PLAINTEXT__10_0].Get(), max_dist_2[_MPC_PLAINTEXT__10_0].Get());\n\n    }\n\n    _8_0 = drop_dim_monoreturn(vectorized_access(max_dist_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _8_0;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger max_dist_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_dist_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_1;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_4;\n    std::uint32_t _MPC_PLAINTEXT_max_dist_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_dist_1 = std::uint32_t(0);\n    current_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_dist_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_dist_2[_MPC_PLAINTEXT__9_0] = _5_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(0)) {\n            current_dist_2[_MPC_PLAINTEXT__9_0] = current_dist_5[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        current_dist_3[_MPC_PLAINTEXT__9_0] = (current_dist_2[_MPC_PLAINTEXT__9_0] + _MPC_CONSTANT_1);\n        current_dist_5[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(current_dist_3[_MPC_PLAINTEXT__9_0].Get(), current_dist_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_dist_2[_MPC_PLAINTEXT__10_0] = _4_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            max_dist_2[_MPC_PLAINTEXT__10_0] = max_dist_4[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__10_0] = (current_dist_5[_MPC_PLAINTEXT__10_0] > max_dist_2[_MPC_PLAINTEXT__10_0]);\n        max_dist_4[_MPC_PLAINTEXT__10_0] = _3_2[_MPC_PLAINTEXT__10_0].Mux(current_dist_5[_MPC_PLAINTEXT__10_0].Get(), max_dist_2[_MPC_PLAINTEXT__10_0].Get());\n\n    }\n\n    _8_0 = drop_dim_monoreturn(vectorized_access(max_dist_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _8_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger max_dist_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_dist_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_1;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_4;\n    std::uint32_t _MPC_PLAINTEXT_max_dist_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_dist_1 = std::uint32_t(0);\n    current_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_dist_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_dist_2[_MPC_PLAINTEXT__9_0] = _5_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(0)) {\n            current_dist_2[_MPC_PLAINTEXT__9_0] = current_dist_5[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        current_dist_3[_MPC_PLAINTEXT__9_0] = (current_dist_2[_MPC_PLAINTEXT__9_0] + _MPC_CONSTANT_1);\n        current_dist_5[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(current_dist_3[_MPC_PLAINTEXT__9_0].Get(), current_dist_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_dist_2[_MPC_PLAINTEXT__10_0] = _4_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            max_dist_2[_MPC_PLAINTEXT__10_0] = max_dist_4[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__10_0] = (current_dist_5[_MPC_PLAINTEXT__10_0] > max_dist_2[_MPC_PLAINTEXT__10_0]);\n        max_dist_4[_MPC_PLAINTEXT__10_0] = _3_2[_MPC_PLAINTEXT__10_0].Mux(current_dist_5[_MPC_PLAINTEXT__10_0].Get(), max_dist_2[_MPC_PLAINTEXT__10_0].Get());\n\n    }\n\n    _8_0 = drop_dim_monoreturn(vectorized_access(max_dist_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _8_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger max_dist_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_dist_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_dist_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_dist_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_dist_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__9_0;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_1;\n    std::uint32_t _MPC_PLAINTEXT_current_dist_4;\n    std::uint32_t _MPC_PLAINTEXT_max_dist_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_dist_1 = std::uint32_t(0);\n    current_dist_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_dist_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_dist_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_dist_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__9_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_dist_2[_MPC_PLAINTEXT__9_0] = _5_0[_MPC_PLAINTEXT__9_0];\n    for (; _MPC_PLAINTEXT__9_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__9_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__9_0 != std::uint32_t(0)) {\n            current_dist_2[_MPC_PLAINTEXT__9_0] = current_dist_5[(_MPC_PLAINTEXT__9_0 - std::uint32_t(1))];\n        }\n\n        current_dist_3[_MPC_PLAINTEXT__9_0] = (current_dist_2[_MPC_PLAINTEXT__9_0] + _MPC_CONSTANT_1);\n        current_dist_5[_MPC_PLAINTEXT__9_0] = _2_2[_MPC_PLAINTEXT__9_0].Mux(current_dist_3[_MPC_PLAINTEXT__9_0].Get(), current_dist_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_dist_2[_MPC_PLAINTEXT__10_0] = _4_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            max_dist_2[_MPC_PLAINTEXT__10_0] = max_dist_4[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__10_0] = (current_dist_5[_MPC_PLAINTEXT__10_0] > max_dist_2[_MPC_PLAINTEXT__10_0]);\n        max_dist_4[_MPC_PLAINTEXT__10_0] = _3_2[_MPC_PLAINTEXT__10_0].Mux(current_dist_5[_MPC_PLAINTEXT__10_0].Get(), max_dist_2[_MPC_PLAINTEXT__10_0].Get());\n\n    }\n\n    _8_0 = drop_dim_monoreturn(vectorized_access(max_dist_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _8_0;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = sint(0)\n    current_dist_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + sint(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0",
                "B": "program.options.binary = 32\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = siv32(0)\n    current_dist_1 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = siv32(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + siv32(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = sint(0)\n    current_dist_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + sint(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = sint(0)\n    current_dist_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + sint(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = siv32(0)\n    current_dist_1 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = siv32(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + siv32(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = sint(0)\n    current_dist_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + sint(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0",
                "B": "program.options.binary = 32\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = siv32(0)\n    current_dist_1 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = siv32(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + siv32(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = sint(0)\n    current_dist_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + sint(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = sint(0)\n    current_dist_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + sint(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = siv32(0)\n    current_dist_1 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = siv32(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + siv32(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0"
            },
            "time": {
                "A": "program.options.binary = 32\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = sint(0)\n    current_dist_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + sint(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0",
                "B": "program.options.binary = 32\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = siv32(0)\n    current_dist_1 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = siv32(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + siv32(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = sint(0)\n    current_dist_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + sint(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = sint(0)\n    current_dist_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + sint(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef max_dist_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_dist_2 = [None] * (N_0)\n    current_dist_3 = [None] * (N_0)\n    current_dist_5 = [None] * (N_0)\n    max_dist_2 = [None] * (N_0)\n    max_dist_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_dist_1 = siv32(0)\n    current_dist_1 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_dist_4 = siv32(0)\n    _4_0 = _v.lift(lambda indices: max_dist_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_dist_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _9_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _9_0 == 0:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(_5_0, [N_0], [_9_0]))\n        else:\n            _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n        _v.vectorized_assign(current_dist_3, [N_0], [_9_0], (_v.vectorized_access_simd(current_dist_2, [N_0], [_9_0]) + siv32(1)))\n        _v.iterative_mux(current_dist_5,_2_2,current_dist_3,current_dist_4,[N_0],[_9_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_dist_2, [N_0], [_9_0], _v.vectorized_access(current_dist_5, [N_0], [(_9_0 - 1)]))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(_4_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_10_0], (_v.vectorized_access_simd(current_dist_5, [N_0], [_10_0]) > _v.vectorized_access_simd(max_dist_2, [N_0], [_10_0])))\n        _v.iterative_mux(max_dist_4,_3_2,current_dist_5,max_dist_2,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_dist_2, [N_0], [_10_0], _v.vectorized_access(max_dist_4, [N_0], [(_10_0 - 1)]))\n    _8_0 = _v.drop_dim(max_dist_4, [N_0])\n    return _8_0"
            }
        }
    },
    "max_sum_between_syms": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger max_sum_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_sum_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_4;\n    std::uint32_t _MPC_PLAINTEXT_max_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_sum_1 = std::uint32_t(0);\n    current_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_sum_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_sum_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            current_sum_2[_MPC_PLAINTEXT__10_0] = current_sum_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_sum_3[_MPC_PLAINTEXT__10_0] = (current_sum_2[_MPC_PLAINTEXT__10_0] + _6_0[_MPC_PLAINTEXT__10_0]);\n        current_sum_5[_MPC_PLAINTEXT__10_0] = _2_2[_MPC_PLAINTEXT__10_0].Mux(current_sum_3[_MPC_PLAINTEXT__10_0].Get(), current_sum_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_sum_2[_MPC_PLAINTEXT__11_0] = _4_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            max_sum_2[_MPC_PLAINTEXT__11_0] = max_sum_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__11_0] = (current_sum_5[_MPC_PLAINTEXT__11_0] > max_sum_2[_MPC_PLAINTEXT__11_0]);\n        max_sum_4[_MPC_PLAINTEXT__11_0] = _3_2[_MPC_PLAINTEXT__11_0].Mux(current_sum_5[_MPC_PLAINTEXT__11_0].Get(), max_sum_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger max_sum_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_sum_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_4;\n    std::uint32_t _MPC_PLAINTEXT_max_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_sum_1 = std::uint32_t(0);\n    current_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_sum_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_sum_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            current_sum_2[_MPC_PLAINTEXT__10_0] = current_sum_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_sum_3[_MPC_PLAINTEXT__10_0] = (current_sum_2[_MPC_PLAINTEXT__10_0] + _6_0[_MPC_PLAINTEXT__10_0]);\n        current_sum_5[_MPC_PLAINTEXT__10_0] = _2_2[_MPC_PLAINTEXT__10_0].Mux(current_sum_3[_MPC_PLAINTEXT__10_0].Get(), current_sum_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_sum_2[_MPC_PLAINTEXT__11_0] = _4_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            max_sum_2[_MPC_PLAINTEXT__11_0] = max_sum_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__11_0] = (current_sum_5[_MPC_PLAINTEXT__11_0] > max_sum_2[_MPC_PLAINTEXT__11_0]);\n        max_sum_4[_MPC_PLAINTEXT__11_0] = _3_2[_MPC_PLAINTEXT__11_0].Mux(current_sum_5[_MPC_PLAINTEXT__11_0].Get(), max_sum_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger max_sum_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_sum_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_4;\n    std::uint32_t _MPC_PLAINTEXT_max_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0_Y(Seq_0.size());\n    vectorized_assign(Seq_0_Y, {Seq_0.size()}, {true}, {}, (vectorized_access(Seq_0, {Seq_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_sum_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_max_sum_1 = std::uint32_t(0);\n    current_sum_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_current_sum_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _6_0_Y((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_6_0_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0_Y[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_sum_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_5_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_sum_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            current_sum_2[_MPC_PLAINTEXT__10_0] = current_sum_5_Y[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_sum_3[_MPC_PLAINTEXT__10_0] = (current_sum_2[_MPC_PLAINTEXT__10_0] + _6_0_Y[_MPC_PLAINTEXT__10_0]); current_sum_3_B[_MPC_PLAINTEXT__10_0] = current_sum_3[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        current_sum_5[_MPC_PLAINTEXT__10_0] = _2_2[_MPC_PLAINTEXT__10_0].Mux(current_sum_3_B[_MPC_PLAINTEXT__10_0].Get(), current_sum_4.Get()); current_sum_5_Y[_MPC_PLAINTEXT__10_0] = current_sum_5[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_4_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_sum_2[_MPC_PLAINTEXT__11_0] = _4_0[_MPC_PLAINTEXT__11_0]; max_sum_2_B[_MPC_PLAINTEXT__11_0] = max_sum_2[_MPC_PLAINTEXT__11_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            max_sum_2[_MPC_PLAINTEXT__11_0] = max_sum_4_Y[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))]; max_sum_2_B[_MPC_PLAINTEXT__11_0] = max_sum_2[_MPC_PLAINTEXT__11_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        }\n\n        _3_2[_MPC_PLAINTEXT__11_0] = (current_sum_5_Y[_MPC_PLAINTEXT__11_0] > max_sum_2[_MPC_PLAINTEXT__11_0]); _3_2_B[_MPC_PLAINTEXT__11_0] = _3_2[_MPC_PLAINTEXT__11_0].Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        max_sum_4[_MPC_PLAINTEXT__11_0] = _3_2_B[_MPC_PLAINTEXT__11_0].Mux(current_sum_5[_MPC_PLAINTEXT__11_0].Get(), max_sum_2_B[_MPC_PLAINTEXT__11_0].Get()); max_sum_4_Y[_MPC_PLAINTEXT__11_0] = max_sum_4[_MPC_PLAINTEXT__11_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0}); \n    encrypto::motion::SecureUnsignedInteger _9_0_Y; _9_0_Y = drop_dim_monoreturn(vectorized_access(max_sum_4_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger max_sum_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_sum_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_4;\n    std::uint32_t _MPC_PLAINTEXT_max_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_sum_1 = std::uint32_t(0);\n    current_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_sum_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_sum_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            current_sum_2[_MPC_PLAINTEXT__10_0] = current_sum_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_sum_3[_MPC_PLAINTEXT__10_0] = (current_sum_2[_MPC_PLAINTEXT__10_0] + _6_0[_MPC_PLAINTEXT__10_0]);\n        current_sum_5[_MPC_PLAINTEXT__10_0] = _2_2[_MPC_PLAINTEXT__10_0].Mux(current_sum_3[_MPC_PLAINTEXT__10_0].Get(), current_sum_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_sum_2[_MPC_PLAINTEXT__11_0] = _4_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            max_sum_2[_MPC_PLAINTEXT__11_0] = max_sum_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__11_0] = (current_sum_5[_MPC_PLAINTEXT__11_0] > max_sum_2[_MPC_PLAINTEXT__11_0]);\n        max_sum_4[_MPC_PLAINTEXT__11_0] = _3_2[_MPC_PLAINTEXT__11_0].Mux(current_sum_5[_MPC_PLAINTEXT__11_0].Get(), max_sum_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger max_sum_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_sum_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_4;\n    std::uint32_t _MPC_PLAINTEXT_max_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_sum_1 = std::uint32_t(0);\n    current_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_sum_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_sum_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            current_sum_2[_MPC_PLAINTEXT__10_0] = current_sum_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_sum_3[_MPC_PLAINTEXT__10_0] = (current_sum_2[_MPC_PLAINTEXT__10_0] + _6_0[_MPC_PLAINTEXT__10_0]);\n        current_sum_5[_MPC_PLAINTEXT__10_0] = _2_2[_MPC_PLAINTEXT__10_0].Mux(current_sum_3[_MPC_PLAINTEXT__10_0].Get(), current_sum_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_sum_2[_MPC_PLAINTEXT__11_0] = _4_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            max_sum_2[_MPC_PLAINTEXT__11_0] = max_sum_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__11_0] = (current_sum_5[_MPC_PLAINTEXT__11_0] > max_sum_2[_MPC_PLAINTEXT__11_0]);\n        max_sum_4[_MPC_PLAINTEXT__11_0] = _3_2[_MPC_PLAINTEXT__11_0].Mux(current_sum_5[_MPC_PLAINTEXT__11_0].Get(), max_sum_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger max_sum_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_sum_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_4;\n    std::uint32_t _MPC_PLAINTEXT_max_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0_Y(Seq_0.size());\n    vectorized_assign(Seq_0_Y, {Seq_0.size()}, {true}, {}, (vectorized_access(Seq_0, {Seq_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_sum_1 = std::uint32_t(0);\n    current_sum_1 = _MPC_CONSTANT_0_Y;\n    _MPC_PLAINTEXT_current_sum_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _6_0_Y((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_6_0_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0_Y[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_sum_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_3_B((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_5_Y((_MPC_PLAINTEXT_N_0));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_sum_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            current_sum_2[_MPC_PLAINTEXT__10_0] = current_sum_5_Y[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_sum_3[_MPC_PLAINTEXT__10_0] = (current_sum_2[_MPC_PLAINTEXT__10_0] + _6_0_Y[_MPC_PLAINTEXT__10_0]); current_sum_3_B[_MPC_PLAINTEXT__10_0] = current_sum_3[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kBooleanGmw>();\n        current_sum_5[_MPC_PLAINTEXT__10_0] = _2_2[_MPC_PLAINTEXT__10_0].Mux(current_sum_3_B[_MPC_PLAINTEXT__10_0].Get(), current_sum_4.Get()); current_sum_5_Y[_MPC_PLAINTEXT__10_0] = current_sum_5[_MPC_PLAINTEXT__10_0].Get().Convert<encrypto::motion::MpcProtocol::kBmr>();\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_sum_2[_MPC_PLAINTEXT__11_0] = _4_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            max_sum_2[_MPC_PLAINTEXT__11_0] = max_sum_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__11_0] = (current_sum_5[_MPC_PLAINTEXT__11_0] > max_sum_2[_MPC_PLAINTEXT__11_0]);\n        max_sum_4[_MPC_PLAINTEXT__11_0] = _3_2[_MPC_PLAINTEXT__11_0].Mux(current_sum_5[_MPC_PLAINTEXT__11_0].Get(), max_sum_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "encrypto::motion::SecureUnsignedInteger max_sum_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_sum_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_4;\n    std::uint32_t _MPC_PLAINTEXT_max_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_sum_1 = std::uint32_t(0);\n    current_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_sum_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_sum_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            current_sum_2[_MPC_PLAINTEXT__10_0] = current_sum_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_sum_3[_MPC_PLAINTEXT__10_0] = (current_sum_2[_MPC_PLAINTEXT__10_0] + _6_0[_MPC_PLAINTEXT__10_0]);\n        current_sum_5[_MPC_PLAINTEXT__10_0] = _2_2[_MPC_PLAINTEXT__10_0].Mux(current_sum_3[_MPC_PLAINTEXT__10_0].Get(), current_sum_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_sum_2[_MPC_PLAINTEXT__11_0] = _4_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            max_sum_2[_MPC_PLAINTEXT__11_0] = max_sum_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__11_0] = (current_sum_5[_MPC_PLAINTEXT__11_0] > max_sum_2[_MPC_PLAINTEXT__11_0]);\n        max_sum_4[_MPC_PLAINTEXT__11_0] = _3_2[_MPC_PLAINTEXT__11_0].Mux(current_sum_5[_MPC_PLAINTEXT__11_0].Get(), max_sum_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}",
                "Y": "encrypto::motion::SecureUnsignedInteger max_sum_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_sum_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_4;\n    std::uint32_t _MPC_PLAINTEXT_max_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_sum_1 = std::uint32_t(0);\n    current_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_sum_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_sum_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            current_sum_2[_MPC_PLAINTEXT__10_0] = current_sum_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_sum_3[_MPC_PLAINTEXT__10_0] = (current_sum_2[_MPC_PLAINTEXT__10_0] + _6_0[_MPC_PLAINTEXT__10_0]);\n        current_sum_5[_MPC_PLAINTEXT__10_0] = _2_2[_MPC_PLAINTEXT__10_0].Mux(current_sum_3[_MPC_PLAINTEXT__10_0].Get(), current_sum_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_sum_2[_MPC_PLAINTEXT__11_0] = _4_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            max_sum_2[_MPC_PLAINTEXT__11_0] = max_sum_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__11_0] = (current_sum_5[_MPC_PLAINTEXT__11_0] > max_sum_2[_MPC_PLAINTEXT__11_0]);\n        max_sum_4[_MPC_PLAINTEXT__11_0] = _3_2[_MPC_PLAINTEXT__11_0].Mux(current_sum_5[_MPC_PLAINTEXT__11_0].Get(), max_sum_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}",
                "mixed": "encrypto::motion::SecureUnsignedInteger max_sum_between_syms(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Seq_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    encrypto::motion::SecureUnsignedInteger Sym_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_2((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _10_0;\n    encrypto::motion::SecureUnsignedInteger _11_0;\n    std::vector<encrypto::motion::ShareWrapper> _2_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _7_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _9_0;\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::SecureUnsignedInteger current_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_3((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger current_sum_4;\n    std::vector<encrypto::motion::SecureUnsignedInteger> current_sum_5((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger max_sum_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> max_sum_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__10_0;\n    std::uint32_t _MPC_PLAINTEXT__11_0;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_1;\n    std::uint32_t _MPC_PLAINTEXT_current_sum_4;\n    std::uint32_t _MPC_PLAINTEXT_max_sum_1;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(0)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    max_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_max_sum_1 = std::uint32_t(0);\n    current_sum_1 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_1 = std::uint32_t(0);\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Seq_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Sym_0;}), {_MPC_PLAINTEXT_N_0}));\n    current_sum_4 = _MPC_CONSTANT_0;\n    _MPC_PLAINTEXT_current_sum_4 = std::uint32_t(0);\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return max_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return current_sum_1;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (to_share_wrapper(vectorized_access(_6_0, {_MPC_PLAINTEXT_N_0}, {true}, {})) == to_share_wrapper(vectorized_access(_7_0, {_MPC_PLAINTEXT_N_0}, {true}, {}))));\n    vectorized_assign(_2_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_1_2, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__10_0 = std::uint32_t(0);\n    // Initialize phi values\n    current_sum_2[_MPC_PLAINTEXT__10_0] = _5_0[_MPC_PLAINTEXT__10_0];\n    for (; _MPC_PLAINTEXT__10_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__10_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__10_0 != std::uint32_t(0)) {\n            current_sum_2[_MPC_PLAINTEXT__10_0] = current_sum_5[(_MPC_PLAINTEXT__10_0 - std::uint32_t(1))];\n        }\n\n        current_sum_3[_MPC_PLAINTEXT__10_0] = (current_sum_2[_MPC_PLAINTEXT__10_0] + _6_0[_MPC_PLAINTEXT__10_0]);\n        current_sum_5[_MPC_PLAINTEXT__10_0] = _2_2[_MPC_PLAINTEXT__10_0].Mux(current_sum_3[_MPC_PLAINTEXT__10_0].Get(), current_sum_4.Get());\n\n    }\n\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__11_0 = std::uint32_t(0);\n    // Initialize phi values\n    max_sum_2[_MPC_PLAINTEXT__11_0] = _4_0[_MPC_PLAINTEXT__11_0];\n    for (; _MPC_PLAINTEXT__11_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__11_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__11_0 != std::uint32_t(0)) {\n            max_sum_2[_MPC_PLAINTEXT__11_0] = max_sum_4[(_MPC_PLAINTEXT__11_0 - std::uint32_t(1))];\n        }\n\n        _3_2[_MPC_PLAINTEXT__11_0] = (current_sum_5[_MPC_PLAINTEXT__11_0] > max_sum_2[_MPC_PLAINTEXT__11_0]);\n        max_sum_4[_MPC_PLAINTEXT__11_0] = _3_2[_MPC_PLAINTEXT__11_0].Mux(current_sum_5[_MPC_PLAINTEXT__11_0].Get(), max_sum_2[_MPC_PLAINTEXT__11_0].Get());\n\n    }\n\n    _9_0 = drop_dim_monoreturn(vectorized_access(max_sum_4, {_MPC_PLAINTEXT_N_0}, {true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0});\n    return _9_0;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = sint(0)\n    current_sum_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0",
                "B": "program.options.binary = 32\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = siv32(0)\n    current_sum_1 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = siv32(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = sint(0)\n    current_sum_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = sint(0)\n    current_sum_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = siv32(0)\n    current_sum_1 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = siv32(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = sint(0)\n    current_sum_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0",
                "B": "program.options.binary = 32\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = siv32(0)\n    current_sum_1 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = siv32(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = sint(0)\n    current_sum_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = sint(0)\n    current_sum_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = siv32(0)\n    current_sum_1 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = siv32(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0"
            },
            "time": {
                "A": "program.options.binary = 32\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = sint(0)\n    current_sum_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0",
                "B": "program.options.binary = 32\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = siv32(0)\n    current_sum_1 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = siv32(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = sint(0)\n    current_sum_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = sint(0)\n    current_sum_1 = sint(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = sint(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef max_sum_between_syms(Seq_0, N_0, Sym_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_2 = [None] * (N_0)\n    _2_2 = [None] * (N_0)\n    _3_2 = [None] * (N_0)\n    _4_0 = [None] * (N_0)\n    _5_0 = [None] * (N_0)\n    _6_0 = [None] * (N_0)\n    _7_0 = [None] * (N_0)\n    current_sum_2 = [None] * (N_0)\n    current_sum_3 = [None] * (N_0)\n    current_sum_5 = [None] * (N_0)\n    max_sum_2 = [None] * (N_0)\n    max_sum_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    max_sum_1 = siv32(0)\n    current_sum_1 = siv32(0)\n    _6_0 = _v.lift(lambda indices: (Seq_0[indices[0]]), [N_0])\n    _7_0 = _v.lift(lambda indices: Sym_0, [N_0])\n    current_sum_4 = siv32(0)\n    _4_0 = _v.lift(lambda indices: max_sum_1, [N_0])\n    _5_0 = _v.lift(lambda indices: current_sum_1, [N_0])\n    _v.vectorized_assign(_1_2, [N_0], [None], (_v.vectorized_access_simd(_6_0, [N_0], [None]) == _v.vectorized_access_simd(_7_0, [N_0], [None])))\n    _v.vectorized_assign(_2_2, [N_0], [None], (_v.vectorized_access_simd(_1_2, [N_0], [None]).bit_not()))\n    for _10_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _10_0 == 0:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(_5_0, [N_0], [_10_0]))\n        else:\n            _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n        _v.vectorized_assign(current_sum_3, [N_0], [_10_0], (_v.vectorized_access_simd(current_sum_2, [N_0], [_10_0]) + _v.vectorized_access_simd(_6_0, [N_0], [_10_0])))\n        _v.iterative_mux(current_sum_5,_2_2,current_sum_3,current_sum_4,[N_0],[_10_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(current_sum_2, [N_0], [_10_0], _v.vectorized_access(current_sum_5, [N_0], [(_10_0 - 1)]))\n    for _11_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _11_0 == 0:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(_4_0, [N_0], [_11_0]))\n        else:\n            _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n        _v.vectorized_assign(_3_2, [N_0], [_11_0], (_v.vectorized_access_simd(current_sum_5, [N_0], [_11_0]) > _v.vectorized_access_simd(max_sum_2, [N_0], [_11_0])))\n        _v.iterative_mux(max_sum_4,_3_2,current_sum_5,max_sum_2,[N_0],[_11_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(max_sum_2, [N_0], [_11_0], _v.vectorized_access(max_sum_4, [N_0], [(_11_0 - 1)]))\n    _9_0 = _v.drop_dim(max_sum_4, [N_0])\n    return _9_0"
            }
        }
    },
    "minimal_points": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> minimal_points(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _7_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper bx_2;\n    std::vector<encrypto::motion::ShareWrapper> bx_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> bx_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__7_1;\n    bool _MPC_PLAINTEXT_bx_2;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    bx_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_bx_2 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bx_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) & to_share_wrapper(vectorized_access(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}));\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, (to_share_wrapper(vectorized_access(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0})) | to_share_wrapper(vectorized_access(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}))));\n\n    }\n\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _7_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _7_1;\n\n}",
                "Y": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> minimal_points(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _7_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper bx_2;\n    std::vector<encrypto::motion::ShareWrapper> bx_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> bx_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__7_1;\n    bool _MPC_PLAINTEXT_bx_2;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    bx_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_bx_2 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bx_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) & to_share_wrapper(vectorized_access(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}));\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, (to_share_wrapper(vectorized_access(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0})) | to_share_wrapper(vectorized_access(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}))));\n\n    }\n\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _7_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _7_1;\n\n}",
                "mixed": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> minimal_points(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _7_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper bx_2;\n    std::vector<encrypto::motion::ShareWrapper> bx_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> bx_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__7_1;\n    bool _MPC_PLAINTEXT_bx_2;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0_Y(Y_coords_0.size());\n    vectorized_assign(Y_coords_0_Y, {Y_coords_0.size()}, {true}, {}, (vectorized_access(Y_coords_0, {Y_coords_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0_Y(X_coords_0.size());\n    vectorized_assign(X_coords_0_Y, {X_coords_0.size()}, {true}, {}, (vectorized_access(X_coords_0, {X_coords_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _16_0_Y((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_16_0_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0_Y[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _17_0_Y((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_17_0_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0_Y[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    bx_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_bx_2 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0_Y[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0_Y[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0_Y[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0_Y[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bx_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    std::vector<encrypto::motion::ShareWrapper> _3_3_B((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_3_3_B, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    vectorized_assign(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    std::vector<encrypto::motion::ShareWrapper> _4_3_B((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_4_3_B, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    vectorized_assign(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_3_3_B, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) & to_share_wrapper(vectorized_access(_4_3_B, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}));\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, (to_share_wrapper(vectorized_access(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0})) | to_share_wrapper(vectorized_access(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}))));\n\n    }\n\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _7_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _7_1;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> minimal_points(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _7_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper bx_2;\n    std::vector<encrypto::motion::ShareWrapper> bx_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> bx_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__7_1;\n    bool _MPC_PLAINTEXT_bx_2;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    bx_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_bx_2 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bx_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) & to_share_wrapper(vectorized_access(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}));\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, (to_share_wrapper(vectorized_access(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0})) | to_share_wrapper(vectorized_access(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}))));\n\n    }\n\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _7_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _7_1;\n\n}",
                "Y": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> minimal_points(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _7_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper bx_2;\n    std::vector<encrypto::motion::ShareWrapper> bx_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> bx_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__7_1;\n    bool _MPC_PLAINTEXT_bx_2;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    bx_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_bx_2 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bx_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) & to_share_wrapper(vectorized_access(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}));\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, (to_share_wrapper(vectorized_access(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0})) | to_share_wrapper(vectorized_access(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}))));\n\n    }\n\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _7_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _7_1;\n\n}",
                "mixed": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> minimal_points(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _7_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper bx_2;\n    std::vector<encrypto::motion::ShareWrapper> bx_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> bx_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__7_1;\n    bool _MPC_PLAINTEXT_bx_2;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    bx_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_bx_2 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bx_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) & to_share_wrapper(vectorized_access(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}));\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, (to_share_wrapper(vectorized_access(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0})) | to_share_wrapper(vectorized_access(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}))));\n\n    }\n\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _7_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _7_1;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> minimal_points(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _7_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper bx_2;\n    std::vector<encrypto::motion::ShareWrapper> bx_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> bx_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__7_1;\n    bool _MPC_PLAINTEXT_bx_2;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    bx_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_bx_2 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bx_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) & to_share_wrapper(vectorized_access(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}));\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, (to_share_wrapper(vectorized_access(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0})) | to_share_wrapper(vectorized_access(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}))));\n\n    }\n\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _7_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _7_1;\n\n}",
                "Y": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> minimal_points(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _7_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper bx_2;\n    std::vector<encrypto::motion::ShareWrapper> bx_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> bx_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__7_1;\n    bool _MPC_PLAINTEXT_bx_2;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    bx_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_bx_2 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bx_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    vectorized_assign(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) & to_share_wrapper(vectorized_access(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}));\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, (to_share_wrapper(vectorized_access(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0})) | to_share_wrapper(vectorized_access(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}))));\n\n    }\n\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _7_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _7_1;\n\n}",
                "mixed": "std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> minimal_points(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,\n    std::uint32_t _MPC_PLAINTEXT_N_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _10_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _11_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _12_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _13_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _14_0((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _15_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _16_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _17_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger _18_0;\n    std::vector<encrypto::motion::ShareWrapper> _3_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _4_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _5_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> _6_2((_MPC_PLAINTEXT_N_0));\n    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _7_1;\n    std::vector<encrypto::motion::SecureUnsignedInteger> _8_0((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _9_0((_MPC_PLAINTEXT_N_0));\n    encrypto::motion::SecureUnsignedInteger N_0;\n    encrypto::motion::ShareWrapper bx_2;\n    std::vector<encrypto::motion::ShareWrapper> bx_3((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::ShareWrapper> bx_4((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_X_4((_MPC_PLAINTEXT_N_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_Y_4((_MPC_PLAINTEXT_N_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__18_0;\n    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__7_1;\n    bool _MPC_PLAINTEXT_bx_2;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n\n    // Input Protocol Convertions\n    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0_Y(Y_coords_0.size());\n    vectorized_assign(Y_coords_0_Y, {Y_coords_0.size()}, {true}, {}, (vectorized_access(Y_coords_0, {Y_coords_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0_Y(X_coords_0.size());\n    vectorized_assign(X_coords_0_Y, {X_coords_0.size()}, {true}, {}, (vectorized_access(X_coords_0, {X_coords_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_X_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_Y_0;}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_16_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _16_0_Y((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_16_0_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0_Y[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_17_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _17_0_Y((_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_17_0_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0_Y[indices[0]];}), {_MPC_PLAINTEXT_N_0}));\n    bx_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_bx_2 = false;\n    vectorized_assign(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return X_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[1]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return Y_coords_0[indices[0]];}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return bx_2;}), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_12_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_11_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    std::vector<encrypto::motion::ShareWrapper> _3_3_Y((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_3_3_Y, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_3_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    vectorized_assign(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_14_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}) > vectorized_access(_13_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})));\n    std::vector<encrypto::motion::ShareWrapper> _4_3_Y((_MPC_PLAINTEXT_N_0) * (_MPC_PLAINTEXT_N_0));\n    vectorized_assign(_4_3_Y, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (vectorized_access(_4_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    vectorized_assign(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_3_3_Y, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {})) & to_share_wrapper(vectorized_access(_4_3_Y, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__18_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(_10_0, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}));\n    for (; _MPC_PLAINTEXT__18_0 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT__18_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__18_0 != std::uint32_t(0)) {\n            vectorized_assign(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {(_MPC_PLAINTEXT__18_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}, (to_share_wrapper(vectorized_access(bx_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0})) | to_share_wrapper(vectorized_access(_5_3, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, false}, {_MPC_PLAINTEXT__18_0}))));\n\n    }\n\n    vectorized_assign(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, drop_dim(vectorized_access(bx_4, {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_N_0, _MPC_PLAINTEXT_N_0}));\n    vectorized_assign(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, (~vectorized_access(_15_0, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_16_0_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(_6_2, {_MPC_PLAINTEXT_N_0}, {true}, {}).Mux(vectorized_access(_17_0_Y, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get(), vectorized_access(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}).Get()));\n    vectorized_assign(result_X_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_8_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_X_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    vectorized_assign(result_Y_2, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_update(_9_0, {_MPC_PLAINTEXT_N_0}, {true}, {}, vectorized_access(val_Y_4, {_MPC_PLAINTEXT_N_0}, {true}, {})));\n    _7_1 = std::make_tuple(result_X_2, result_Y_2);\n    return _7_1;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sint(_v.sbool(False))\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1",
                "B": "program.options.binary = 32\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sbit(0)\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sint(_v.sbool(False))\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sint(_v.sbool(False))\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sbit(0)\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sint(_v.sbool(False))\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1",
                "B": "program.options.binary = 32\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sbit(0)\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sint(_v.sbool(False))\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sint(_v.sbool(False))\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sbit(0)\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1"
            },
            "time": {
                "A": "program.options.binary = 32\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sint(_v.sbool(False))\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1",
                "B": "program.options.binary = 32\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sbit(0)\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sint(_v.sbool(False))\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sint(_v.sbool(False))\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _10_0 = [None] * (N_0 * N_0)\n    _11_0 = [None] * (N_0 * N_0)\n    _12_0 = [None] * (N_0 * N_0)\n    _13_0 = [None] * (N_0 * N_0)\n    _14_0 = [None] * (N_0 * N_0)\n    _15_0 = [None] * (N_0)\n    _16_0 = [None] * (N_0)\n    _17_0 = [None] * (N_0)\n    _3_3 = [None] * (N_0 * N_0)\n    _4_3 = [None] * (N_0 * N_0)\n    _5_3 = [None] * (N_0 * N_0)\n    _6_2 = [None] * (N_0)\n    _8_0 = [None] * (N_0)\n    _9_0 = [None] * (N_0)\n    bx_3 = [None] * (N_0 * N_0)\n    bx_4 = [None] * (N_0 * N_0)\n    result_X_2 = [None] * (N_0)\n    result_Y_2 = [None] * (N_0)\n    val_X_4 = [None] * (N_0)\n    val_Y_4 = [None] * (N_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])\n    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])\n    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])\n    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])\n    bx_2 = sbit(0)\n    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])\n    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])\n    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])\n    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])\n    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])\n    _v.vectorized_assign(_3_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_11_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_12_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_4_3, [N_0, N_0], [None, None], (_v.vectorized_access_simd(_13_0, [N_0, N_0], [None, None]) < _v.vectorized_access_simd(_14_0, [N_0, N_0], [None, None])))\n    _v.vectorized_assign(_5_3, [N_0, N_0], [None, None], _v.vectorized_access_simd(_3_3, [N_0, N_0], [None, None]).bit_and(_v.vectorized_access_simd(_4_3, [N_0, N_0], [None, None])))\n    for _18_0 in range(0, N_0):\n        # Set \u03d5 value\n        if _18_0 == 0:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(_10_0, [N_0, N_0], [None, _18_0]))\n        else:\n            _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n        _v.vectorized_assign(bx_4, [N_0, N_0], [None, _18_0], OR(_v.vectorized_access_simd(bx_3, [N_0, N_0], [None, _18_0]), _v.vectorized_access_simd(_5_3, [N_0, N_0], [None, _18_0])))\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(bx_3, [N_0, N_0], [None, _18_0], _v.vectorized_access(bx_4, [N_0, N_0], [None, (_18_0 - 1)]))\n    _v.vectorized_assign(_15_0, [N_0], [None], _v.drop_dim(bx_4, [N_0, N_0]))\n    _v.vectorized_assign(_6_2, [N_0], [None], (_v.vectorized_access_simd(_15_0, [N_0], [None]).bit_not()))\n    _v.iterative_mux(val_X_4,_6_2,_16_0,_8_0,[N_0],[None])\n    _v.iterative_mux(val_Y_4,_6_2,_17_0,_9_0,[N_0],[None])\n    _v.vectorized_assign(_8_0, [N_0], [None], _v.vectorized_access(val_X_4, [N_0], [None])); _v.vectorized_assign(result_X_2, [N_0], [None], _v.vectorized_access(_8_0, [N_0], [None]))\n    _v.vectorized_assign(_9_0, [N_0], [None], _v.vectorized_access(val_Y_4, [N_0], [None])); _v.vectorized_assign(result_Y_2, [N_0], [None], _v.vectorized_access(_9_0, [N_0], [None]))\n    _7_1 = (result_X_2,result_Y_2,)\n    return _7_1"
            }
        }
    },
    "mnist_relu": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> mnist_relu(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> input_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0,\n    std::uint32_t _MPC_PLAINTEXT_len_outer_0,\n    std::uint32_t _MPC_PLAINTEXT_len_inner_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    encrypto::motion::SecureUnsignedInteger len_inner_0;\n    encrypto::motion::SecureUnsignedInteger len_outer_0;\n    encrypto::motion::SecureUnsignedInteger val_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_val_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return input_0[((indices[0] * _MPC_PLAINTEXT_len_inner_0) + indices[1])];}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    val_3 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_val_3 = std::uint32_t(1);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, (vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}) > decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}))));\n    vectorized_assign(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Mux(vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Get(), decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0})).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_update(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> mnist_relu(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> input_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0,\n    std::uint32_t _MPC_PLAINTEXT_len_outer_0,\n    std::uint32_t _MPC_PLAINTEXT_len_inner_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    encrypto::motion::SecureUnsignedInteger len_inner_0;\n    encrypto::motion::SecureUnsignedInteger len_outer_0;\n    encrypto::motion::SecureUnsignedInteger val_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_val_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return input_0[((indices[0] * _MPC_PLAINTEXT_len_inner_0) + indices[1])];}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    val_3 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_val_3 = std::uint32_t(1);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, (vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}) > decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}))));\n    vectorized_assign(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Mux(vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Get(), decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0})).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_update(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> mnist_relu(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> input_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0,\n    std::uint32_t _MPC_PLAINTEXT_len_outer_0,\n    std::uint32_t _MPC_PLAINTEXT_len_inner_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    encrypto::motion::SecureUnsignedInteger len_inner_0;\n    encrypto::motion::SecureUnsignedInteger len_outer_0;\n    encrypto::motion::SecureUnsignedInteger val_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_val_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n    std::vector<encrypto::motion::SecureUnsignedInteger> input_0_Y(input_0.size());\n    vectorized_assign(input_0_Y, {input_0.size()}, {true}, {}, (vectorized_access(input_0, {input_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return input_0[((indices[0] * _MPC_PLAINTEXT_len_inner_0) + indices[1])];}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _4_0_Y((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    vectorized_assign(_4_0_Y, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return input_0_Y[((indices[0] * _MPC_PLAINTEXT_len_inner_0) + indices[1])];}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    val_3 = _MPC_CONSTANT_1;\n    encrypto::motion::SecureUnsignedInteger val_3_Y;\n    val_3_Y = _MPC_CONSTANT_1_Y;\n    _MPC_PLAINTEXT_val_3 = std::uint32_t(1);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, (vectorized_access(_4_0_Y, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}) > decltype(val_3_Y)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3_Y;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}))));\n    std::vector<encrypto::motion::ShareWrapper> _1_3_B((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    vectorized_assign(_1_3_B, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, (vectorized_access(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    vectorized_assign(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(_1_3_B, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Mux(vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Get(), decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0})).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_update(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> mnist_relu(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> input_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0,\n    std::uint32_t _MPC_PLAINTEXT_len_outer_0,\n    std::uint32_t _MPC_PLAINTEXT_len_inner_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    encrypto::motion::SecureUnsignedInteger len_inner_0;\n    encrypto::motion::SecureUnsignedInteger len_outer_0;\n    encrypto::motion::SecureUnsignedInteger val_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_val_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return input_0[((indices[0] * _MPC_PLAINTEXT_len_inner_0) + indices[1])];}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    val_3 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_val_3 = std::uint32_t(1);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, (vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}) > decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}))));\n    vectorized_assign(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Mux(vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Get(), decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0})).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_update(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> mnist_relu(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> input_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0,\n    std::uint32_t _MPC_PLAINTEXT_len_outer_0,\n    std::uint32_t _MPC_PLAINTEXT_len_inner_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    encrypto::motion::SecureUnsignedInteger len_inner_0;\n    encrypto::motion::SecureUnsignedInteger len_outer_0;\n    encrypto::motion::SecureUnsignedInteger val_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_val_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return input_0[((indices[0] * _MPC_PLAINTEXT_len_inner_0) + indices[1])];}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    val_3 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_val_3 = std::uint32_t(1);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, (vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}) > decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}))));\n    vectorized_assign(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Mux(vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Get(), decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0})).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_update(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> mnist_relu(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> input_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0,\n    std::uint32_t _MPC_PLAINTEXT_len_outer_0,\n    std::uint32_t _MPC_PLAINTEXT_len_inner_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    encrypto::motion::SecureUnsignedInteger len_inner_0;\n    encrypto::motion::SecureUnsignedInteger len_outer_0;\n    encrypto::motion::SecureUnsignedInteger val_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_val_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return input_0[((indices[0] * _MPC_PLAINTEXT_len_inner_0) + indices[1])];}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    val_3 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_val_3 = std::uint32_t(1);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, (vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}) > decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}))));\n    vectorized_assign(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Mux(vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Get(), decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0})).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_update(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> mnist_relu(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> input_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0,\n    std::uint32_t _MPC_PLAINTEXT_len_outer_0,\n    std::uint32_t _MPC_PLAINTEXT_len_inner_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    encrypto::motion::SecureUnsignedInteger len_inner_0;\n    encrypto::motion::SecureUnsignedInteger len_outer_0;\n    encrypto::motion::SecureUnsignedInteger val_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_val_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return input_0[((indices[0] * _MPC_PLAINTEXT_len_inner_0) + indices[1])];}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    val_3 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_val_3 = std::uint32_t(1);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, (vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}) > decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}))));\n    vectorized_assign(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Mux(vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Get(), decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0})).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_update(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> mnist_relu(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> input_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0,\n    std::uint32_t _MPC_PLAINTEXT_len_outer_0,\n    std::uint32_t _MPC_PLAINTEXT_len_inner_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    encrypto::motion::SecureUnsignedInteger len_inner_0;\n    encrypto::motion::SecureUnsignedInteger len_outer_0;\n    encrypto::motion::SecureUnsignedInteger val_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_val_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return input_0[((indices[0] * _MPC_PLAINTEXT_len_inner_0) + indices[1])];}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    val_3 = _MPC_CONSTANT_1;\n    _MPC_PLAINTEXT_val_3 = std::uint32_t(1);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, (vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}) > decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}))));\n    vectorized_assign(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Mux(vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Get(), decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0})).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_update(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> mnist_relu(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> input_0,\n    std::vector<std::uint32_t> _MPC_PLAINTEXT_OUTPUT_res_0,\n    std::uint32_t _MPC_PLAINTEXT_len_outer_0,\n    std::uint32_t _MPC_PLAINTEXT_len_inner_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _3_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_0;\n    std::vector<encrypto::motion::SecureUnsignedInteger> OUTPUT_res_3((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    encrypto::motion::SecureUnsignedInteger len_inner_0;\n    encrypto::motion::SecureUnsignedInteger len_outer_0;\n    encrypto::motion::SecureUnsignedInteger val_3;\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_5((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT_val_3;\n\n    // Constant initializations\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1 = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_1_Y = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::ToInput(std::uint32_t(1)), 0);\n\n    // Input Protocol Convertions\n    std::vector<encrypto::motion::SecureUnsignedInteger> input_0_Y(input_0.size());\n    vectorized_assign(input_0_Y, {input_0.size()}, {true}, {}, (vectorized_access(input_0, {input_0.size()}, {true}, {}).Get().Convert<encrypto::motion::MpcProtocol::kBmr>()));\n\n    // Plaintext parameter assignments\n    OUTPUT_res_0.clear();\n    std::transform(_MPC_PLAINTEXT_OUTPUT_res_0.begin(), _MPC_PLAINTEXT_OUTPUT_res_0.end(), std::back_inserter(OUTPUT_res_0), [&](const auto &val) { return party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::ToInput(val), 0); });\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return OUTPUT_res_0;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return input_0[((indices[0] * _MPC_PLAINTEXT_len_inner_0) + indices[1])];}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));std::vector<encrypto::motion::SecureUnsignedInteger> _4_0_Y((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    vectorized_assign(_4_0_Y, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return input_0_Y[((indices[0] * _MPC_PLAINTEXT_len_inner_0) + indices[1])];}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    val_3 = _MPC_CONSTANT_1;\n    encrypto::motion::SecureUnsignedInteger val_3_Y;\n    val_3_Y = _MPC_CONSTANT_1_Y;\n    _MPC_PLAINTEXT_val_3 = std::uint32_t(1);\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return vectorized_access(_2_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Unsimdify();}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, (vectorized_access(_4_0_Y, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}) > decltype(val_3_Y)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3_Y;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}))));\n    std::vector<encrypto::motion::ShareWrapper> _1_3_B((_MPC_PLAINTEXT_len_outer_0) * (_MPC_PLAINTEXT_len_inner_0));\n    vectorized_assign(_1_3_B, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, (vectorized_access(_1_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Convert<encrypto::motion::MpcProtocol::kBooleanGmw>()));\n\n    vectorized_assign(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(_1_3_B, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Mux(vectorized_access(_4_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}).Get(), decltype(val_3)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return val_3;}), {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0})).Get()));\n    vectorized_assign(OUTPUT_res_3, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_update(_3_0, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {}, vectorized_access(val_5, {_MPC_PLAINTEXT_len_outer_0, _MPC_PLAINTEXT_len_inner_0}, {true, true}, {})));\n    return OUTPUT_res_3;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = sint(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3",
                "B": "program.options.binary = 32\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    OUTPUT_res_0 = [elem for elem in sint(OUTPUT_res_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = siv32(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = sint(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = sint(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    OUTPUT_res_0 = [elem for elem in sint(OUTPUT_res_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = siv32(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = sint(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3",
                "B": "program.options.binary = 32\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    OUTPUT_res_0 = [elem for elem in sint(OUTPUT_res_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = siv32(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = sint(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = sint(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    OUTPUT_res_0 = [elem for elem in sint(OUTPUT_res_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = siv32(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3"
            },
            "time": {
                "A": "program.options.binary = 32\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = sint(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3",
                "B": "program.options.binary = 32\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    OUTPUT_res_0 = [elem for elem in sint(OUTPUT_res_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = siv32(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = sint(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = sint(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef mnist_relu(input_0, OUTPUT_res_0, len_outer_0, len_inner_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    OUTPUT_res_0 = [elem for elem in sint(OUTPUT_res_0)]\n\n\n    \n    # Shared array declarations\n    _1_3 = [None] * (len_outer_0 * len_inner_0)\n    _2_0 = [None] * (len_outer_0 * len_inner_0)\n    _3_0 = [None] * (len_outer_0 * len_inner_0)\n    _4_0 = [None] * (len_outer_0 * len_inner_0)\n    OUTPUT_res_3 = [None] * (len_outer_0 * len_inner_0)\n    val_5 = [None] * (len_outer_0 * len_inner_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: OUTPUT_res_0, [len_outer_0, len_inner_0])\n    _4_0 = _v.lift(lambda indices: (input_0[((indices[0] * len_inner_0) + indices[1])]), [len_outer_0, len_inner_0])\n    val_3 = siv32(1)\n    _3_0 = _v.lift(lambda indices: _v.vectorized_access(_2_0, [len_outer_0, len_inner_0], [None, None]), [len_outer_0, len_inner_0])\n    _v.vectorized_assign(_1_3, [len_outer_0, len_inner_0], [None, None], (_v.vectorized_access_simd(_4_0, [len_outer_0, len_inner_0], [None, None]) > val_3))\n    _v.iterative_mux(val_5,_1_3,_4_0,val_3,[len_outer_0, len_inner_0],[None, None])\n    _v.vectorized_assign(_3_0, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(val_5, [len_outer_0, len_inner_0], [None, None])); _v.vectorized_assign(OUTPUT_res_3, [len_outer_0, len_inner_0], [None, None], _v.vectorized_access(_3_0, [len_outer_0, len_inner_0], [None, None]))\n    return OUTPUT_res_3"
            }
        }
    },
    "psi": {
        "MOTION": {
            "commRounds": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> psi(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_R_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger R_0;\n    encrypto::motion::ShareWrapper flag_2;\n    std::vector<encrypto::motion::ShareWrapper> flag_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    encrypto::motion::ShareWrapper flag_4;\n    std::vector<encrypto::motion::ShareWrapper> flag_5((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_4((_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    bool _MPC_PLAINTEXT_flag_2;\n    bool _MPC_PLAINTEXT_flag_4;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0}));\n    flag_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_flag_2 = false;\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    flag_4 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_flag_4 = true;\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_2;}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_R_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(decltype(flag_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_4;}), {_MPC_PLAINTEXT_D_0})).Get(), vectorized_access(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n\n    }\n\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, drop_dim(vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Mux(vectorized_access(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get(), vectorized_access(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get()));\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_update(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {})));\n    return result_2;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> psi(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_R_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger R_0;\n    encrypto::motion::ShareWrapper flag_2;\n    std::vector<encrypto::motion::ShareWrapper> flag_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    encrypto::motion::ShareWrapper flag_4;\n    std::vector<encrypto::motion::ShareWrapper> flag_5((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_4((_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    bool _MPC_PLAINTEXT_flag_2;\n    bool _MPC_PLAINTEXT_flag_4;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0}));\n    flag_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_flag_2 = false;\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    flag_4 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_flag_4 = true;\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_2;}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_R_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(decltype(flag_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_4;}), {_MPC_PLAINTEXT_D_0})).Get(), vectorized_access(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n\n    }\n\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, drop_dim(vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Mux(vectorized_access(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get(), vectorized_access(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get()));\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_update(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {})));\n    return result_2;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> psi(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_R_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger R_0;\n    encrypto::motion::ShareWrapper flag_2;\n    std::vector<encrypto::motion::ShareWrapper> flag_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    encrypto::motion::ShareWrapper flag_4;\n    std::vector<encrypto::motion::ShareWrapper> flag_5((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_4((_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    bool _MPC_PLAINTEXT_flag_2;\n    bool _MPC_PLAINTEXT_flag_4;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0}));\n    flag_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_flag_2 = false;\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    flag_4 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_flag_4 = true;\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_2;}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_R_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(decltype(flag_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_4;}), {_MPC_PLAINTEXT_D_0})).Get(), vectorized_access(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n\n    }\n\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, drop_dim(vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Mux(vectorized_access(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get(), vectorized_access(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get()));\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_update(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {})));\n    return result_2;\n\n}"
            },
            "dataSent": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> psi(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_R_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger R_0;\n    encrypto::motion::ShareWrapper flag_2;\n    std::vector<encrypto::motion::ShareWrapper> flag_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    encrypto::motion::ShareWrapper flag_4;\n    std::vector<encrypto::motion::ShareWrapper> flag_5((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_4((_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    bool _MPC_PLAINTEXT_flag_2;\n    bool _MPC_PLAINTEXT_flag_4;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0}));\n    flag_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_flag_2 = false;\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    flag_4 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_flag_4 = true;\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_2;}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_R_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(decltype(flag_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_4;}), {_MPC_PLAINTEXT_D_0})).Get(), vectorized_access(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n\n    }\n\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, drop_dim(vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Mux(vectorized_access(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get(), vectorized_access(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get()));\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_update(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {})));\n    return result_2;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> psi(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_R_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger R_0;\n    encrypto::motion::ShareWrapper flag_2;\n    std::vector<encrypto::motion::ShareWrapper> flag_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    encrypto::motion::ShareWrapper flag_4;\n    std::vector<encrypto::motion::ShareWrapper> flag_5((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_4((_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    bool _MPC_PLAINTEXT_flag_2;\n    bool _MPC_PLAINTEXT_flag_4;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0}));\n    flag_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_flag_2 = false;\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    flag_4 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_flag_4 = true;\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_2;}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_R_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(decltype(flag_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_4;}), {_MPC_PLAINTEXT_D_0})).Get(), vectorized_access(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n\n    }\n\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, drop_dim(vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Mux(vectorized_access(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get(), vectorized_access(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get()));\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_update(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {})));\n    return result_2;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> psi(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_R_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger R_0;\n    encrypto::motion::ShareWrapper flag_2;\n    std::vector<encrypto::motion::ShareWrapper> flag_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    encrypto::motion::ShareWrapper flag_4;\n    std::vector<encrypto::motion::ShareWrapper> flag_5((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_4((_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    bool _MPC_PLAINTEXT_flag_2;\n    bool _MPC_PLAINTEXT_flag_4;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0}));\n    flag_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_flag_2 = false;\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    flag_4 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_flag_4 = true;\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_2;}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_R_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(decltype(flag_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_4;}), {_MPC_PLAINTEXT_D_0})).Get(), vectorized_access(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n\n    }\n\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, drop_dim(vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Mux(vectorized_access(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get(), vectorized_access(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get()));\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_update(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {})));\n    return result_2;\n\n}"
            },
            "time": {
                "A": "N/A",
                "B": "std::vector<encrypto::motion::SecureUnsignedInteger> psi(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_R_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger R_0;\n    encrypto::motion::ShareWrapper flag_2;\n    std::vector<encrypto::motion::ShareWrapper> flag_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    encrypto::motion::ShareWrapper flag_4;\n    std::vector<encrypto::motion::ShareWrapper> flag_5((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_4((_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    bool _MPC_PLAINTEXT_flag_2;\n    bool _MPC_PLAINTEXT_flag_4;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBooleanGmw>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0}));\n    flag_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_flag_2 = false;\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    flag_4 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_flag_4 = true;\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_2;}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_R_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(decltype(flag_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_4;}), {_MPC_PLAINTEXT_D_0})).Get(), vectorized_access(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n\n    }\n\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, drop_dim(vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Mux(vectorized_access(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get(), vectorized_access(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get()));\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_update(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {})));\n    return result_2;\n\n}",
                "Y": "std::vector<encrypto::motion::SecureUnsignedInteger> psi(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_R_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger R_0;\n    encrypto::motion::ShareWrapper flag_2;\n    std::vector<encrypto::motion::ShareWrapper> flag_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    encrypto::motion::ShareWrapper flag_4;\n    std::vector<encrypto::motion::ShareWrapper> flag_5((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_4((_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    bool _MPC_PLAINTEXT_flag_2;\n    bool _MPC_PLAINTEXT_flag_4;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0}));\n    flag_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_flag_2 = false;\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    flag_4 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_flag_4 = true;\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_2;}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_R_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(decltype(flag_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_4;}), {_MPC_PLAINTEXT_D_0})).Get(), vectorized_access(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n\n    }\n\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, drop_dim(vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Mux(vectorized_access(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get(), vectorized_access(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get()));\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_update(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {})));\n    return result_2;\n\n}",
                "mixed": "std::vector<encrypto::motion::SecureUnsignedInteger> psi(\n    encrypto::motion::PartyPointer &party,\n    std::vector<encrypto::motion::SecureUnsignedInteger> A_0,\n    std::uint32_t _MPC_PLAINTEXT_D_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> B_0,\n    std::uint32_t _MPC_PLAINTEXT_R_0,\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_0\n) {\n    // Shared variable declarations\n    std::vector<encrypto::motion::ShareWrapper> _1_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _2_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _3_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _4_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _5_0((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> _6_0((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::ShareWrapper> _7_0((_MPC_PLAINTEXT_D_0));\n    encrypto::motion::SecureUnsignedInteger _8_0;\n    encrypto::motion::SecureUnsignedInteger D_0;\n    encrypto::motion::SecureUnsignedInteger R_0;\n    encrypto::motion::ShareWrapper flag_2;\n    std::vector<encrypto::motion::ShareWrapper> flag_3((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    encrypto::motion::ShareWrapper flag_4;\n    std::vector<encrypto::motion::ShareWrapper> flag_5((_MPC_PLAINTEXT_D_0) * (_MPC_PLAINTEXT_R_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> result_2((_MPC_PLAINTEXT_D_0));\n    std::vector<encrypto::motion::SecureUnsignedInteger> val_4((_MPC_PLAINTEXT_D_0));\n\n    // Plaintext variable declarations\n    std::uint32_t _MPC_PLAINTEXT__8_0;\n    bool _MPC_PLAINTEXT_flag_2;\n    bool _MPC_PLAINTEXT_flag_4;\n\n    // Constant initializations\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, false), 0);\n    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<encrypto::motion::MpcProtocol::kBmr>(encrypto::motion::BitVector(1, true), 0);\n\n    // Input Protocol Convertions\n\n    // Plaintext parameter assignments\n\n    // Function body\n    vectorized_assign(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return result_0;}), {_MPC_PLAINTEXT_D_0}));\n    vectorized_assign(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0}));\n    flag_2 = _MPC_CONSTANT_false;\n    _MPC_PLAINTEXT_flag_2 = false;\n    vectorized_assign(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return A_0[indices[0]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return B_0[indices[1]];}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    flag_4 = _MPC_CONSTANT_true;\n    _MPC_PLAINTEXT_flag_4 = true;\n    vectorized_assign(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_2;}), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}, (to_share_wrapper(vectorized_access(_4_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {})) == to_share_wrapper(vectorized_access(_5_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}))));\n\n    // Initialize loop counter\n    _MPC_PLAINTEXT__8_0 = std::uint32_t(0);\n    // Initialize phi values\n    vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_3_0, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}));\n    for (; _MPC_PLAINTEXT__8_0 < _MPC_PLAINTEXT_R_0; _MPC_PLAINTEXT__8_0++) {\n        // Update phi values\n        if (_MPC_PLAINTEXT__8_0 != std::uint32_t(0)) {\n            vectorized_assign(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {(_MPC_PLAINTEXT__8_0 - std::uint32_t(1))}));\n        }\n\n        vectorized_assign(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}, vectorized_access(_1_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Mux(decltype(flag_4)::Simdify(lift(std::function([&](const std::vector<std::uint32_t> &indices){return flag_4;}), {_MPC_PLAINTEXT_D_0})).Get(), vectorized_access(flag_3, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, false}, {_MPC_PLAINTEXT__8_0}).Get()));\n\n    }\n\n    vectorized_assign(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, drop_dim(vectorized_access(flag_5, {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}, {true, true}, {}).Unsimdify(), {_MPC_PLAINTEXT_D_0, _MPC_PLAINTEXT_R_0}));\n    vectorized_assign(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(_7_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Mux(vectorized_access(_6_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get(), vectorized_access(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}).Get()));\n    vectorized_assign(result_2, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_update(_2_0, {_MPC_PLAINTEXT_D_0}, {true}, {}, vectorized_access(val_4, {_MPC_PLAINTEXT_D_0}, {true}, {})));\n    return result_2;\n\n}"
            }
        },
        "MP-SPDZ": {
            "commRounds": {
                "A": "program.options.binary = 32\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sint(_v.sbool(False))\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sint(_v.sbool(True))\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2",
                "B": "program.options.binary = 32\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sbit(0)\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sbit(1)\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sint(_v.sbool(False))\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sint(_v.sbool(True))\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sint(_v.sbool(False))\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sint(_v.sbool(True))\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sbit(0)\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sbit(1)\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2"
            },
            "dataSent": {
                "A": "program.options.binary = 32\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sint(_v.sbool(False))\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sint(_v.sbool(True))\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2",
                "B": "program.options.binary = 32\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sbit(0)\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sbit(1)\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sint(_v.sbool(False))\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sint(_v.sbool(True))\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sint(_v.sbool(False))\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sint(_v.sbool(True))\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sbit(0)\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sbit(1)\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2"
            },
            "time": {
                "A": "program.options.binary = 32\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sint(_v.sbool(False))\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sint(_v.sbool(True))\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2",
                "B": "program.options.binary = 32\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sbit(0)\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sbit(1)\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2",
                "X": "program.options.binary = 32\nprogram.use_dabit = True\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sint(_v.sbool(False))\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sint(_v.sbool(True))\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2",
                "Y": "program.options.binary = 32\nprogram.use_edabit(True)\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sint(_v.sbool(False))\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sint(_v.sbool(True))\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2",
                "mixed": "program.options.binary = 32\nprogram.use_dabit = True\ndef psi(A_0, D_0, B_0, R_0, result_0):\n    # Convertion functions\n    siv32 = sbitintvec.get_type(32)\n    sb32 = sbits.get_type(32)\n    \n    \n    # Shared array declarations\n    _1_3 = [None] * (D_0 * R_0)\n    _2_0 = [None] * (D_0)\n    _3_0 = [None] * (D_0 * R_0)\n    _4_0 = [None] * (D_0 * R_0)\n    _5_0 = [None] * (D_0 * R_0)\n    _6_0 = [None] * (D_0)\n    _7_0 = [None] * (D_0)\n    flag_3 = [None] * (D_0 * R_0)\n    flag_5 = [None] * (D_0 * R_0)\n    result_2 = [None] * (D_0)\n    val_4 = [None] * (D_0)\n    # Shared array convertion declarations\n    \n    # Function body\n    _2_0 = _v.lift(lambda indices: result_0, [D_0])\n    _6_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0])\n    flag_2 = sbit(0)\n    _4_0 = _v.lift(lambda indices: (A_0[indices[0]]), [D_0, R_0])\n    _5_0 = _v.lift(lambda indices: (B_0[indices[1]]), [D_0, R_0])\n    flag_4 = sbit(1)\n    _3_0 = _v.lift(lambda indices: flag_2, [D_0, R_0])\n    _v.vectorized_assign(_1_3, [D_0, R_0], [None, None], (_v.vectorized_access_simd(_4_0, [D_0, R_0], [None, None]) == _v.vectorized_access_simd(_5_0, [D_0, R_0], [None, None])))\n    for _8_0 in range(0, R_0):\n        # Set \u03d5 value\n        if _8_0 == 0:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(_3_0, [D_0, R_0], [None, _8_0]))\n        else:\n            _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n        _v.iterative_mux(flag_5,_1_3,flag_4,flag_3,[D_0, R_0],[None, _8_0])\n    # Loop exit \u03d5 values\n    _v.vectorized_assign(flag_3, [D_0, R_0], [None, _8_0], _v.vectorized_access(flag_5, [D_0, R_0], [None, (_8_0 - 1)]))\n    _v.vectorized_assign(_7_0, [D_0], [None], _v.drop_dim(flag_5, [D_0, R_0]))\n    _v.iterative_mux(val_4,_7_0,_6_0,_2_0,[D_0],[None])\n    _v.vectorized_assign(_2_0, [D_0], [None], _v.vectorized_access(val_4, [D_0], [None])); _v.vectorized_assign(result_2, [D_0], [None], _v.vectorized_access(_2_0, [D_0], [None]))\n    return result_2"
            }
        }
    }
}