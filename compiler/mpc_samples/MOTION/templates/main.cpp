#include <algorithm>
#include <chrono>
#include <iostream>
#include <regex>

#include <boost/lexical_cast.hpp>
#include <boost/program_options.hpp>
#include <fmt/format.h>

#include "base/party.h"
#include "communication/communication_layer.h"
#include "communication/tcp_transport.h"
#include "statistics/analysis.h"

#include "collect_stats.h"

#include "template_code.h"

namespace program_options = boost::program_options;

const std::regex kPartyArgRegex("([01]),([^,]+),(\\d{1,5})");

// We need to implement the below operator to let Boost support default
// values for vectors.
namespace std {
template <typename T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &vec)
{
    os << "[";
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        if (it != vec.begin()) {
            os << ", ";
        }
        os << *it;
    }
    os << "]";
    return os;
}

std::ostream &operator<<(std::ostream &os, const encrypto::motion::SecureUnsignedInteger &val)
{
    os << val.As<std::uint32_t>();
    return os;
}

std::ostream &operator<<(std::ostream &os, const encrypto::motion::ShareWrapper &val)
{
    if (val.As<bool>() == true) {
        os << "True";
    } else {
        os << "False";
    }
    return os;
}
} // namespace std

program_options::variables_map parse_options(const int argc, const char *const argv[])
{
    bool help;
    // clang-format off
    program_options::options_description description("Allowed options");
    description.add_options()
        ("help,h", program_options::bool_switch(&help)->default_value(false), "produce help message")
        ("my-id", program_options::value<std::size_t>(), "my party id")
        ("parties", program_options::value<std::vector<std::string>>()->multitoken()->default_value(std::vector<std::string>({"0,127.0.0.1,23000", "1,127.0.0.1,23001"})),
          "(party id, host, port, my role), e.g., --parties 0,127.0.0.1,23000 1,127.0.0.1,23001")
        // Autogenerated options for each shared input
        // clang-format on
    ;

    program_options::variables_map user_options;
    program_options::store(program_options::parse_command_line(argc, argv, description),
                           user_options);
    program_options::notify(user_options);

    if (help) {
        std::cout << description << std::endl;
        return user_options;
    }

    // error checking
    if (user_options.count("my-id") == 0) {
        throw std::runtime_error("my-id is not specified");
    }

    if (user_options.count("parties") == 0) {
        throw std::runtime_error("parties are not specified");
    } else {
        const std::vector<std::string> other_parties{
            user_options["parties"].as<std::vector<std::string>>()};
        if (other_parties.size() != 2)
            throw std::runtime_error(
                fmt::format("Incorrect number of parties {} (expected 2)", other_parties.size()));
        std::string parties("Other parties: ");
        for (auto &party : other_parties) {
            if (!std::regex_match(party, kPartyArgRegex)) {
                throw std::runtime_error(
                    fmt::format("Incorrect party argument syntax for party {}", party));
            }
        }
    }

    return user_options;
}

encrypto::motion::PartyPointer CreateParty(const program_options::variables_map &opts)
{
    const auto parties_strings = opts["parties"].as<std::vector<std::string>>();
    const auto my_id = opts["my-id"].as<std::size_t>();
    if (my_id >= parties_strings.size()) {
        throw std::runtime_error(fmt::format("my-id {} is out of range (must be between 0 and {})",
                                             my_id, parties_strings.size() - 1));
    }

    encrypto::motion::communication::TcpPartiesConfiguration parties_configuration(
        parties_strings.size());

    for (const auto &party_string : parties_strings) {
        std::smatch match;
        std::regex_match(party_string, match, kPartyArgRegex);
        const auto party_id = boost::lexical_cast<std::size_t>(match[1]);
        const auto host = match[2];
        const auto port = boost::lexical_cast<std::uint16_t>(match[3]);

        if (party_id >= parties_strings.size()) {
            throw std::runtime_error(
                fmt::format("party_id {} is out of range (must be between 0 and {})", party_id,
                            parties_strings.size() - 1));
        }

        parties_configuration.at(party_id) = std::make_pair(host, port);
    }

    encrypto::motion::communication::TcpSetupHelper helper(my_id, parties_configuration);
    auto communication_layer =
        std::make_unique<encrypto::motion::communication::CommunicationLayer>(
            my_id, helper.SetupConnections());
    auto party = std::make_unique<encrypto::motion::Party>(std::move(communication_layer));
    auto configuration = party->GetConfiguration();
    configuration->SetOnlineAfterSetup(true);
    return party;
}

// Helper function for generating output
template <typename T>
T to_output(const T &out)
{
    return out.Out();
}

// Helper function for generating output
template <typename T>
std::vector<T> to_output(const std::vector<T> &out)
{
    std::vector<T> output;
    for (const auto &v : out) {
        output.push_back(to_output(v));
    }
    return output;
}

int main(const int argc, const char *const argv[])
{
    auto user_options = parse_options(argc, argv);
    if (user_options["help"].as<bool>()) {
        return 0;
    }

    encrypto::motion::PartyPointer party = CreateParty(user_options);

    // clang-format off
    std::vector<std::uint32_t> list_A;
    encrypto::motion::SecureUnsignedInteger A;
    std::vector<std::uint32_t> list_B;
    encrypto::motion::SecureUnsignedInteger B;
    
    for (int i = 0; i < _vec_size; i++) {
        list_A.push_back(i);
        list_B.push_back(i);
    }

    _inputA_placeHolder
    _inputB_placeHolder
    
     //clang-format on

    auto circuit_gen_start = std::chrono::steady_clock::now();
    template_code(party, A, B);
    auto circuit_gen_end = std::chrono::steady_clock::now();
    auto circuit_gen_time = std::chrono::duration_cast<std::chrono::milliseconds>(circuit_gen_end - circuit_gen_start).count();
    
    party->Run();

    party->Finish();

    encrypto::motion::AccumulatedRunTimeStatistics accumulated_statistics;
    accumulated_statistics.Add(party->GetBackend()->GetRunTimeStatistics().front());

    encrypto::motion::AccumulatedCommunicationStatistics accumulated_communication_statistics;
    accumulated_communication_statistics.Add(
        party->GetBackend()->GetCommunicationLayer().GetTransportStatistics());

    std::cerr << encrypto::motion::PrintStatistics("", accumulated_statistics,
                                                   accumulated_communication_statistics)
              << std::endl;

    std::cout << collect_stats(party->GetBackend());
    std::cout << "circuit_gen_time: " << circuit_gen_time << std::endl;


    // std::cout<< "RESULT ===> " << output_output_type << std::endl;
    

    return 0;
}

// vim: set ft=cpp :

// Emacs:
// Local Variables:
// mode: cpp
// End: