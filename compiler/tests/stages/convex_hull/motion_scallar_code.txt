template <encrypto::motion::MpcProtocol Protocol>
std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> convex_hull(
    encrypto::motion::PartyPointer &party,
    std::vector<encrypto::motion::SecureUnsignedInteger> X_coords_0,
    std::vector<encrypto::motion::SecureUnsignedInteger> Y_coords_0,
    std::uint32_t _MPC_PLAINTEXT_N_0,
    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_X_0,
    std::vector<std::uint32_t> _MPC_PLAINTEXT_result_Y_0
) {
    // Shared variable declarations
    encrypto::motion::ShareWrapper _1_2;
    std::tuple<std::vector<encrypto::motion::SecureUnsignedInteger>, std::vector<encrypto::motion::SecureUnsignedInteger>> _10_1;
    encrypto::motion::ShareWrapper _2_2;
    encrypto::motion::ShareWrapper _3_2;
    encrypto::motion::ShareWrapper _6_3;
    encrypto::motion::ShareWrapper _7_3;
    encrypto::motion::ShareWrapper _8_3;
    encrypto::motion::ShareWrapper _9_3;
    encrypto::motion::SecureUnsignedInteger N_0;
    encrypto::motion::SecureUnsignedInteger i_1;
    encrypto::motion::ShareWrapper is_hull_2;
    encrypto::motion::ShareWrapper is_hull_3;
    encrypto::motion::ShareWrapper is_hull_4;
    encrypto::motion::ShareWrapper is_hull_5;
    encrypto::motion::ShareWrapper is_hull_6;
    encrypto::motion::SecureUnsignedInteger j_1;
    encrypto::motion::SecureUnsignedInteger p1_X_2;
    encrypto::motion::SecureUnsignedInteger p1_Y_2;
    encrypto::motion::SecureUnsignedInteger p2_X_3;
    encrypto::motion::SecureUnsignedInteger p2_Y_3;
    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_0;
    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_1((_MPC_PLAINTEXT_N_0));
    std::vector<encrypto::motion::SecureUnsignedInteger> result_X_2((_MPC_PLAINTEXT_N_0));
    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_0;
    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_1((_MPC_PLAINTEXT_N_0));
    std::vector<encrypto::motion::SecureUnsignedInteger> result_Y_2((_MPC_PLAINTEXT_N_0));
    encrypto::motion::SecureUnsignedInteger val_X_2;
    encrypto::motion::SecureUnsignedInteger val_X_4;
    encrypto::motion::SecureUnsignedInteger val_Y_2;
    encrypto::motion::SecureUnsignedInteger val_Y_4;

    // Plaintext variable declarations
    std::tuple<std::vector<std::uint32_t>, std::vector<std::uint32_t>> _MPC_PLAINTEXT__10_1;
    std::uint32_t _MPC_PLAINTEXT_i_1;
    bool _MPC_PLAINTEXT_is_hull_2;
    bool _MPC_PLAINTEXT_is_hull_4;
    std::uint32_t _MPC_PLAINTEXT_j_1;

    // Constant initializations
    encrypto::motion::SecureUnsignedInteger _MPC_CONSTANT_0 = party->In<Protocol>(encrypto::motion::ToInput(std::uint32_t(0)), 0);
    encrypto::motion::ShareWrapper _MPC_CONSTANT_false = party->In<Protocol>(encrypto::motion::BitVector(1, false), 0);
    encrypto::motion::ShareWrapper _MPC_CONSTANT_true = party->In<Protocol>(encrypto::motion::BitVector(1, true), 0);

    // Plaintext parameter assignments
    N_0 = party->In<Protocol>(encrypto::motion::ToInput(_MPC_PLAINTEXT_N_0), 0);
    result_X_0.clear();
    std::transform(_MPC_PLAINTEXT_result_X_0.begin(), _MPC_PLAINTEXT_result_X_0.end(), std::back_inserter(result_X_0), [&](const auto &val) { return party->In<Protocol>(encrypto::motion::ToInput(val), 0); });
    result_Y_0.clear();
    std::transform(_MPC_PLAINTEXT_result_Y_0.begin(), _MPC_PLAINTEXT_result_Y_0.end(), std::back_inserter(result_Y_0), [&](const auto &val) { return party->In<Protocol>(encrypto::motion::ToInput(val), 0); });

    // Function body

    // Initialize loop counter
    _MPC_PLAINTEXT_i_1 = std::uint32_t(0);
    // Initialize phi values
    result_X_1 = result_X_0;
    result_Y_1 = result_Y_0;
    for (; _MPC_PLAINTEXT_i_1 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT_i_1++) {
        // Update phi values
        if (_MPC_PLAINTEXT_i_1 != std::uint32_t(0)) {
            result_X_1 = result_X_2;
            result_Y_1 = result_Y_2;
        }

        is_hull_2 = _MPC_CONSTANT_true;
        _MPC_PLAINTEXT_is_hull_2 = true;
        p1_X_2 = X_coords_0[_MPC_PLAINTEXT_i_1];
        p1_Y_2 = Y_coords_0[_MPC_PLAINTEXT_i_1];
        _1_2 = ((_MPC_CONSTANT_0 > p1_X_2) | (to_share_wrapper(p1_X_2) == to_share_wrapper(_MPC_CONSTANT_0)));
        _2_2 = ((p1_Y_2 > _MPC_CONSTANT_0) | (to_share_wrapper(p1_Y_2) == to_share_wrapper(_MPC_CONSTANT_0)));
        _3_2 = (to_share_wrapper(_1_2) & to_share_wrapper(_2_2));

        // Initialize loop counter
        _MPC_PLAINTEXT_j_1 = std::uint32_t(0);
        // Initialize phi values
        is_hull_3 = is_hull_2;
        for (; _MPC_PLAINTEXT_j_1 < _MPC_PLAINTEXT_N_0; _MPC_PLAINTEXT_j_1++) {
            // Update phi values
            if (_MPC_PLAINTEXT_j_1 != std::uint32_t(0)) {
                is_hull_3 = is_hull_5;
            }

            p2_X_3 = X_coords_0[_MPC_PLAINTEXT_j_1];
            p2_Y_3 = Y_coords_0[_MPC_PLAINTEXT_j_1];
            _6_3 = ((p2_X_3 > p1_X_2) | (to_share_wrapper(p1_X_2) == to_share_wrapper(p2_X_3)));
            _7_3 = ((p1_Y_2 > p2_Y_3) | (to_share_wrapper(p1_Y_2) == to_share_wrapper(p2_Y_3)));
            _8_3 = (to_share_wrapper(_6_3) | to_share_wrapper(_7_3));
            _9_3 = (~_8_3);
            is_hull_4 = _MPC_CONSTANT_false;
            _MPC_PLAINTEXT_is_hull_4 = false;
            is_hull_5 = _9_3.Mux(is_hull_4.Get(), is_hull_3.Get());

        }

        is_hull_6 = _3_2.Mux(is_hull_3.Get(), is_hull_2.Get());
        val_X_2 = result_X_1[_MPC_PLAINTEXT_i_1];
        val_Y_2 = result_Y_1[_MPC_PLAINTEXT_i_1];
        val_X_4 = is_hull_6.Mux(p1_X_2.Get(), val_X_2.Get());
        val_Y_4 = is_hull_6.Mux(p1_Y_2.Get(), val_Y_2.Get());
        result_X_1[_MPC_PLAINTEXT_i_1] = val_X_4;
        result_X_2 = result_X_1;
        result_Y_1[_MPC_PLAINTEXT_i_1] = val_Y_4;
        result_Y_2 = result_Y_1;

    }

    _10_1 = std::make_tuple(result_X_1, result_Y_1);
    return _10_1;

}
